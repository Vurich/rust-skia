/* automatically generated by rust-bindgen 0.56.0 */

#![allow(clippy::all)]
#![allow(improper_ctypes)]
pub enum GrContext_Base {}
pub enum GrImageContext {}
pub enum GrImageContextPriv {}
pub enum GrContextThreadSafeProxy {}
pub enum GrContextThreadSafeProxyPriv {}
pub enum GrRecordingContextPriv {}
pub enum GrContextPriv {}
pub enum SkVerticesPriv {}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = __gnu_cxx___alloc_traits;
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = std_basic_string__Alloc_traits;
pub type std_basic_string_difference_type = std_basic_string__Alloc_traits;
pub type std_basic_string_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_const_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
pub type std_basic_string___sv_type<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string__If_sv = std_enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper<_CharT> {
    pub _M_sv: std_basic_string___sv_type<_CharT>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 =
    std_basic_string__bindgen_ty_1::_S_local_capacity;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_1 {
    _S_local_capacity = 0,
}
#[repr(C)]
pub union std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: *mut _CharT,
    pub _M_allocated_capacity: std_basic_string_size_type,
    _bindgen_union_align: u64,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::core::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::core::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
pub type std___enable_if_t = u8;
pub type std_enable_if_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
pub type std___array_traits__Type<_Tp> = *mut _Tp;
pub type std___array_traits__Is_swappable = std___is_swappable;
pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
pub type std_tuple__TCC = u8;
pub type std_tuple__ImplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ExplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ImplicitCtor = std___enable_if_t;
pub type std_tuple__ExplicitCtor = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__UseOtherCtor {
    pub _base: std_false_type,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::core::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::core::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = __gnu_cxx___alloc_traits;
pub type std__Vector_base_pointer = __gnu_cxx___alloc_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic_value_type<_Tp> = _Tp;
pub type std_string = [u64; 4usize];
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub _M_len: usize,
    pub _M_str: *const _CharT,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_pointer<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_reference<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_reference<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_iterator<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = usize;
pub type std_basic_string_view_difference_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
pub type std__Base_bitset__WordT = ::std::os::raw::c_ulong;
extern "C" {
    #[link_name = "\u{1}_M_do_left_shift"]
    pub fn std__Base_bitset__M_do_left_shift(this: *mut u8, __shift: usize);
}
extern "C" {
    #[link_name = "\u{1}_M_do_right_shift"]
    pub fn std__Base_bitset__M_do_right_shift(this: *mut u8, __shift: usize);
}
extern "C" {
    #[link_name = "\u{1}_M_do_to_ulong"]
    pub fn std__Base_bitset__M_do_to_ulong(this: *const u8) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_M_do_to_ullong"]
    pub fn std__Base_bitset__M_do_to_ullong(this: *const u8) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_M_do_find_first"]
    pub fn std__Base_bitset__M_do_find_first(this: *const u8, arg1: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_M_do_find_next"]
    pub fn std__Base_bitset__M_do_find_next(this: *const u8, arg1: usize, arg2: usize) -> usize;
}
pub type std_bitset__Base = u8;
pub type std_bitset__WordT = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct std_bitset_reference {
    pub _M_wp: *mut std_bitset__WordT,
    pub _M_bpos: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type U8CPU = ::std::os::raw::c_uint;
pub type SkFourByteTag = u32;
pub type SkUnichar = i32;
pub type SkGlyphID = u16;
pub type SkMSec = u32;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBudgeted {
    kNo = 0,
    kYes = 1,
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type FILE = _IO_FILE;
#[repr(C)]
pub struct SkRefCntBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCntBase {
    pub vtable_: *const SkRefCntBase__bindgen_vtable,
    pub fRefCnt: u32,
}
#[test]
fn bindgen_test_layout_SkRefCntBase() {
    assert_eq!(
        ::core::mem::size_of::<SkRefCntBase>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCntBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCntBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCntBase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRefCntBase>())).fRefCnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRefCntBase),
            "::",
            stringify!(fRefCnt)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRefCnt {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCnt))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkNVRefCnt {
    pub fRefCnt: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct sk_sp<T> {
    pub fPtr: *mut T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
pub type sk_sp_element_type<T> = T;
pub type SkScalar = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkAutoTMalloc {
    pub _address: u8,
}
impl SkTArray_ReallocType {
    pub const kGrowing: SkTArray_ReallocType = SkTArray_ReallocType::kExactFit;
}
impl SkTArray_ReallocType {
    pub const kShrinking: SkTArray_ReallocType = SkTArray_ReallocType::kExactFit;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTArray_ReallocType {
    kExactFit = 0,
}
pub type SkTArray_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkString {
    pub fRec: sk_sp<SkString_Rec>,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkString_Rec {
    pub fLength: u32,
    pub fRefCnt: u32,
    pub fBeginningOfData: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SkString_Rec() {
    assert_eq!(
        ::core::mem::size_of::<SkString_Rec>(),
        12usize,
        concat!("Size of: ", stringify!(SkString_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString_Rec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkString_Rec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkString_Rec>())).fLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkString_Rec>())).fRefCnt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fRefCnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkString_Rec>())).fBeginningOfData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fBeginningOfData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString3Rec4MakeEPKcm"]
    pub fn SkString_Rec_Make(
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) -> sk_sp<SkString_Rec>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString3Rec3refEv"]
    pub fn SkString_Rec_ref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString3Rec5unrefEv"]
    pub fn SkString_Rec_unref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString3Rec6uniqueEv"]
    pub fn SkString_Rec_unique(this: *const SkString_Rec) -> bool;
}
impl SkString_Rec {
    #[inline]
    pub unsafe fn Make(text: *const ::std::os::raw::c_char, len: usize) -> sk_sp<SkString_Rec> {
        SkString_Rec_Make(text, len)
    }
    #[inline]
    pub unsafe fn ref_(&self) {
        SkString_Rec_ref(self)
    }
    #[inline]
    pub unsafe fn unref(&self) {
        SkString_Rec_unref(self)
    }
    #[inline]
    pub unsafe fn unique(&self) -> bool {
        SkString_Rec_unique(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9gEmptyRecE"]
    pub static SkString_gEmptyRec: SkString_Rec;
}
#[test]
fn bindgen_test_layout_SkString() {
    assert_eq!(
        ::core::mem::size_of::<SkString>(),
        8usize,
        concat!("Size of: ", stringify!(SkString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkString))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkString>())).fRec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString),
            "::",
            stringify!(fRec)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString6equalsERKS_"]
    pub fn SkString_equals(this: *const SkString, arg1: *const SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString6equalsEPKc"]
    pub fn SkString_equals1(this: *const SkString, text: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkString6equalsEPKcm"]
    pub fn SkString_equals2(
        this: *const SkString,
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString12writable_strEv"]
    pub fn SkString_writable_str(this: *mut SkString) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString5resetEv"]
    pub fn SkString_reset(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString6resizeEm"]
    pub fn SkString_resize(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString3setEPKc"]
    pub fn SkString_set(this: *mut SkString, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString3setEPKcm"]
    pub fn SkString_set1(this: *mut SkString, text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString6insertEmPKc"]
    pub fn SkString_insert(this: *mut SkString, offset: usize, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString6insertEmPKcm"]
    pub fn SkString_insert1(
        this: *mut SkString,
        offset: usize,
        text: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString13insertUnicharEmi"]
    pub fn SkString_insertUnichar(this: *mut SkString, offset: usize, arg1: SkUnichar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9insertS32Emi"]
    pub fn SkString_insertS32(this: *mut SkString, offset: usize, value: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9insertS64Emli"]
    pub fn SkString_insertS64(
        this: *mut SkString,
        offset: usize,
        value: i64,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9insertU32Emj"]
    pub fn SkString_insertU32(this: *mut SkString, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9insertU64Emmi"]
    pub fn SkString_insertU64(
        this: *mut SkString,
        offset: usize,
        value: u64,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString9insertHexEmji"]
    pub fn SkString_insertHex(
        this: *mut SkString,
        offset: usize,
        value: u32,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString12insertScalarEmf"]
    pub fn SkString_insertScalar(this: *mut SkString, offset: usize, arg1: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString6printfEPKcz"]
    pub fn SkString_printf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString11printVAListEPKcP13__va_list_tag"]
    pub fn SkString_printVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString7appendfEPKcz"]
    pub fn SkString_appendf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString12appendVAListEPKcP13__va_list_tag"]
    pub fn SkString_appendVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString8prependfEPKcz"]
    pub fn SkString_prependf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString13prependVAListEPKcP13__va_list_tag"]
    pub fn SkString_prependVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString6removeEmm"]
    pub fn SkString_remove(this: *mut SkString, offset: usize, length: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkString4swapERS_"]
    pub fn SkString_swap(this: *mut SkString, other: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1Ev"]
    pub fn SkString_SkString(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1Em"]
    pub fn SkString_SkString1(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1EPKc"]
    pub fn SkString_SkString2(this: *mut SkString, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1EPKcm"]
    pub fn SkString_SkString3(this: *mut SkString, text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1ERKS_"]
    pub fn SkString_SkString4(this: *mut SkString, arg1: *const SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1EOS_"]
    pub fn SkString_SkString5(this: *mut SkString, arg1: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn SkString_SkString6(this: *mut SkString, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStringD1Ev"]
    pub fn SkString_SkString_destructor(this: *mut SkString);
}
impl SkString {
    #[inline]
    pub unsafe fn equals(&self, arg1: *const SkString) -> bool {
        SkString_equals(self, arg1)
    }
    #[inline]
    pub unsafe fn equals1(&self, text: *const ::std::os::raw::c_char) -> bool {
        SkString_equals1(self, text)
    }
    #[inline]
    pub unsafe fn equals2(&self, text: *const ::std::os::raw::c_char, len: usize) -> bool {
        SkString_equals2(self, text, len)
    }
    #[inline]
    pub unsafe fn writable_str(&mut self) -> *mut ::std::os::raw::c_char {
        SkString_writable_str(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkString_reset(self)
    }
    #[inline]
    pub unsafe fn resize(&mut self, len: usize) {
        SkString_resize(self, len)
    }
    #[inline]
    pub unsafe fn set(&mut self, text: *const ::std::os::raw::c_char) {
        SkString_set(self, text)
    }
    #[inline]
    pub unsafe fn set1(&mut self, text: *const ::std::os::raw::c_char, len: usize) {
        SkString_set1(self, text, len)
    }
    #[inline]
    pub unsafe fn insert(&mut self, offset: usize, text: *const ::std::os::raw::c_char) {
        SkString_insert(self, offset, text)
    }
    #[inline]
    pub unsafe fn insert1(
        &mut self,
        offset: usize,
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) {
        SkString_insert1(self, offset, text, len)
    }
    #[inline]
    pub unsafe fn insertUnichar(&mut self, offset: usize, arg1: SkUnichar) {
        SkString_insertUnichar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
        SkString_insertS32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertS64(
        &mut self,
        offset: usize,
        value: i64,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertS64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
        SkString_insertU32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertU64(
        &mut self,
        offset: usize,
        value: u64,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertU64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertHex(
        &mut self,
        offset: usize,
        value: u32,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertHex(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertScalar(&mut self, offset: usize, arg1: SkScalar) {
        SkString_insertScalar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn printVAList(
        &mut self,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) {
        SkString_printVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn appendVAList(
        &mut self,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) {
        SkString_appendVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn prependVAList(
        &mut self,
        format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) {
        SkString_prependVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn remove(&mut self, offset: usize, length: usize) {
        SkString_remove(self, offset, length)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkString) {
        SkString_swap(self, other)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString1(__bindgen_tmp.as_mut_ptr(), len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(text: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString2(__bindgen_tmp.as_mut_ptr(), text);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(text: *const ::std::os::raw::c_char, len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString3(__bindgen_tmp.as_mut_ptr(), text, len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *const SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(arg1: *mut SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString5(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString6(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkString_SkString_destructor(self)
    }
}
#[repr(C)]
pub struct SkStrings {
    pub strings: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkStrings() {
    assert_eq!(
        ::core::mem::size_of::<SkStrings>(),
        24usize,
        concat!("Size of: ", stringify!(SkStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStrings))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkStrings>())).strings as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrings),
            "::",
            stringify!(strings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIPoint {
    pub fX: i32,
    pub fY: i32,
}
#[test]
fn bindgen_test_layout_SkIPoint() {
    assert_eq!(
        ::core::mem::size_of::<SkIPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkIPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIPoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIPoint>())).fX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIPoint),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIPoint>())).fY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIPoint),
            "::",
            stringify!(fY)
        )
    );
}
pub type SkVector = SkPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint {
    pub fX: SkScalar,
    pub fY: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint() {
    assert_eq!(
        ::core::mem::size_of::<SkPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPoint>())).fX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPoint>())).fY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint),
            "::",
            stringify!(fY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint9normalizeEv"]
    pub fn SkPoint_normalize(this: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint12setNormalizeEff"]
    pub fn SkPoint_setNormalize(this: *mut SkPoint, x: SkScalar, y: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint9setLengthEf"]
    pub fn SkPoint_setLength(this: *mut SkPoint, length: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint9setLengthEfff"]
    pub fn SkPoint_setLength1(
        this: *mut SkPoint,
        x: SkScalar,
        y: SkScalar,
        length: SkScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPoint5scaleEfPS_"]
    pub fn SkPoint_scale(this: *const SkPoint, scale: SkScalar, dst: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint6LengthEff"]
    pub fn SkPoint_Length(x: SkScalar, y: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPoint9NormalizeEPS_"]
    pub fn SkPoint_Normalize(vec: *mut SkVector) -> SkScalar;
}
impl SkPoint {
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint_normalize(self)
    }
    #[inline]
    pub unsafe fn setNormalize(&mut self, x: SkScalar, y: SkScalar) -> bool {
        SkPoint_setNormalize(self, x, y)
    }
    #[inline]
    pub unsafe fn setLength(&mut self, length: SkScalar) -> bool {
        SkPoint_setLength(self, length)
    }
    #[inline]
    pub unsafe fn setLength1(&mut self, x: SkScalar, y: SkScalar, length: SkScalar) -> bool {
        SkPoint_setLength1(self, x, y, length)
    }
    #[inline]
    pub unsafe fn scale(&self, scale: SkScalar, dst: *mut SkPoint) {
        SkPoint_scale(self, scale, dst)
    }
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar) -> SkScalar {
        SkPoint_Length(x, y)
    }
    #[inline]
    pub unsafe fn Normalize(vec: *mut SkVector) -> SkScalar {
        SkPoint_Normalize(vec)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkISize {
    pub fWidth: i32,
    pub fHeight: i32,
}
#[test]
fn bindgen_test_layout_SkISize() {
    assert_eq!(
        ::core::mem::size_of::<SkISize>(),
        8usize,
        concat!("Size of: ", stringify!(SkISize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkISize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkISize))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkISize>())).fWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkISize),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkISize>())).fHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkISize),
            "::",
            stringify!(fHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSize {
    pub fWidth: SkScalar,
    pub fHeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkSize() {
    assert_eq!(
        ::core::mem::size_of::<SkSize>(),
        8usize,
        concat!("Size of: ", stringify!(SkSize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSize))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSize>())).fWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSize),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSize>())).fHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSize),
            "::",
            stringify!(fHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIRect {
    pub fLeft: i32,
    pub fTop: i32,
    pub fRight: i32,
    pub fBottom: i32,
}
#[test]
fn bindgen_test_layout_SkIRect() {
    assert_eq!(
        ::core::mem::size_of::<SkIRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkIRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIRect>())).fLeft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIRect>())).fTop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIRect>())).fRight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIRect>())).fBottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fBottom)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkIRect9intersectERKS_S1_"]
    pub fn SkIRect_intersect(this: *mut SkIRect, a: *const SkIRect, b: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkIRect4joinERKS_"]
    pub fn SkIRect_join(this: *mut SkIRect, r: *const SkIRect);
}
impl SkIRect {
    #[inline]
    pub unsafe fn intersect(&mut self, a: *const SkIRect, b: *const SkIRect) -> bool {
        SkIRect_intersect(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkIRect) {
        SkIRect_join(self, r)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRect {
    pub fLeft: SkScalar,
    pub fTop: SkScalar,
    pub fRight: SkScalar,
    pub fBottom: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRect() {
    assert_eq!(
        ::core::mem::size_of::<SkRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRect>())).fLeft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRect>())).fTop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRect>())).fRight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRect>())).fBottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fBottom)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkRect6toQuadEP7SkPoint"]
    pub fn SkRect_toQuad(this: *const SkRect, quad: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkRect14setBoundsCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkRect16setBoundsNoCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsNoCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkRect9intersectERKS_"]
    pub fn SkRect_intersect(this: *mut SkRect, r: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkRect9intersectERKS_S1_"]
    pub fn SkRect_intersect1(this: *mut SkRect, a: *const SkRect, b: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkRect4joinERKS_"]
    pub fn SkRect_join(this: *mut SkRect, r: *const SkRect);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkRect4dumpEb"]
    pub fn SkRect_dump(this: *const SkRect, asHex: bool);
}
impl SkRect {
    #[inline]
    pub unsafe fn toQuad(&self, quad: *mut SkPoint) {
        SkRect_toQuad(self, quad)
    }
    #[inline]
    pub unsafe fn setBoundsCheck(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool {
        SkRect_setBoundsCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn setBoundsNoCheck(&mut self, pts: *const SkPoint, count: ::std::os::raw::c_int) {
        SkRect_setBoundsNoCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn intersect(&mut self, r: *const SkRect) -> bool {
        SkRect_intersect(self, r)
    }
    #[inline]
    pub unsafe fn intersect1(&mut self, a: *const SkRect, b: *const SkRect) -> bool {
        SkRect_intersect1(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkRect) {
        SkRect_join(self, r)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRect_dump(self, asHex)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkApplyPerspectiveClip {
    No = 0,
    Yes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMatrix {
    pub fMat: [SkScalar; 9usize],
    pub fTypeMask: i32,
}
pub const SkMatrix_TypeMask_kIdentity_Mask: SkMatrix_TypeMask = 0;
pub const SkMatrix_TypeMask_kTranslate_Mask: SkMatrix_TypeMask = 1;
pub const SkMatrix_TypeMask_kScale_Mask: SkMatrix_TypeMask = 2;
pub const SkMatrix_TypeMask_kAffine_Mask: SkMatrix_TypeMask = 4;
pub const SkMatrix_TypeMask_kPerspective_Mask: SkMatrix_TypeMask = 8;
pub type SkMatrix_TypeMask = ::std::os::raw::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix_ScaleToFit {
    Fill = 0,
    Start = 1,
    Center = 2,
    End = 3,
}
pub type SkMatrix_MapXYProc = ::core::option::Option<
    unsafe extern "C" fn(mat: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint),
>;
pub type SkMatrix_MapPtsProc = ::core::option::Option<
    unsafe extern "C" fn(
        mat: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ),
>;
pub const SkMatrix_kMScaleX: ::std::os::raw::c_int = 0;
pub const SkMatrix_kMSkewX: ::std::os::raw::c_int = 1;
pub const SkMatrix_kMTransX: ::std::os::raw::c_int = 2;
pub const SkMatrix_kMSkewY: ::std::os::raw::c_int = 3;
pub const SkMatrix_kMScaleY: ::std::os::raw::c_int = 4;
pub const SkMatrix_kMTransY: ::std::os::raw::c_int = 5;
pub const SkMatrix_kMPersp0: ::std::os::raw::c_int = 6;
pub const SkMatrix_kMPersp1: ::std::os::raw::c_int = 7;
pub const SkMatrix_kMPersp2: ::std::os::raw::c_int = 8;
pub const SkMatrix_kAScaleX: ::std::os::raw::c_int = 0;
pub const SkMatrix_kASkewY: ::std::os::raw::c_int = 1;
pub const SkMatrix_kASkewX: ::std::os::raw::c_int = 2;
pub const SkMatrix_kAScaleY: ::std::os::raw::c_int = 3;
pub const SkMatrix_kATransX: ::std::os::raw::c_int = 4;
pub const SkMatrix_kATransY: ::std::os::raw::c_int = 5;
pub const SkMatrix_kRectStaysRect_Mask: ::std::os::raw::c_int = 16;
pub const SkMatrix_kOnlyPerspectiveValid_Mask: ::std::os::raw::c_int = 64;
pub const SkMatrix_kUnknown_Mask: ::std::os::raw::c_int = 128;
pub const SkMatrix_kORableMasks: ::std::os::raw::c_int = 15;
pub const SkMatrix_kAllMasks: ::std::os::raw::c_int = 31;
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix11gMapXYProcsE"]
    pub static mut SkMatrix_gMapXYProcs: [SkMatrix_MapXYProc; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix12gMapPtsProcsE"]
    pub static mut SkMatrix_gMapPtsProcs: [SkMatrix_MapPtsProc; 0usize];
}
#[test]
fn bindgen_test_layout_SkMatrix() {
    assert_eq!(
        ::core::mem::size_of::<SkMatrix>(),
        40usize,
        concat!("Size of: ", stringify!(SkMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkMatrix))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMatrix>())).fMat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix),
            "::",
            stringify!(fMat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMatrix>())).fTypeMask as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix),
            "::",
            stringify!(fTypeMask)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix12isSimilarityEf"]
    pub fn SkMatrix_isSimilarity(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix20preservesRightAnglesEf"]
    pub fn SkMatrix_preservesRightAngles(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix4set9EPKf"]
    pub fn SkMatrix_set9(this: *mut SkMatrix, buffer: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix5resetEv"]
    pub fn SkMatrix_reset(this: *mut SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix12setTranslateEff"]
    pub fn SkMatrix_setTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8setScaleEffff"]
    pub fn SkMatrix_setScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8setScaleEff"]
    pub fn SkMatrix_setScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setRotateEfff"]
    pub fn SkMatrix_setRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setRotateEf"]
    pub fn SkMatrix_setRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setSinCosEffff"]
    pub fn SkMatrix_setSinCos(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setSinCosEff"]
    pub fn SkMatrix_setSinCos1(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix10setRSXformERK9SkRSXform"]
    pub fn SkMatrix_setRSXform(this: *mut SkMatrix, rsxForm: *const SkRSXform) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix7setSkewEffff"]
    pub fn SkMatrix_setSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix7setSkewEff"]
    pub fn SkMatrix_setSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setConcatERKS_S1_"]
    pub fn SkMatrix_setConcat(
        this: *mut SkMatrix,
        a: *const SkMatrix,
        b: *const SkMatrix,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix12preTranslateEff"]
    pub fn SkMatrix_preTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8preScaleEffff"]
    pub fn SkMatrix_preScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8preScaleEff"]
    pub fn SkMatrix_preScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9preRotateEfff"]
    pub fn SkMatrix_preRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9preRotateEf"]
    pub fn SkMatrix_preRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix7preSkewEffff"]
    pub fn SkMatrix_preSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix7preSkewEff"]
    pub fn SkMatrix_preSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9preConcatERKS_"]
    pub fn SkMatrix_preConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix13postTranslateEff"]
    pub fn SkMatrix_postTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar)
        -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9postScaleEffff"]
    pub fn SkMatrix_postScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9postScaleEff"]
    pub fn SkMatrix_postScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix10postRotateEfff"]
    pub fn SkMatrix_postRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix10postRotateEf"]
    pub fn SkMatrix_postRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8postSkewEffff"]
    pub fn SkMatrix_postSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix8postSkewEff"]
    pub fn SkMatrix_postSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix10postConcatERKS_"]
    pub fn SkMatrix_postConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix13setRectToRectERK6SkRectS2_NS_10ScaleToFitE"]
    pub fn SkMatrix_setRectToRect(
        this: *mut SkMatrix,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix13setPolyToPolyEPK7SkPointS2_i"]
    pub fn SkMatrix_setPolyToPoly(
        this: *mut SkMatrix,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix17SetAffineIdentityEPf"]
    pub fn SkMatrix_SetAffineIdentity(affine: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix8asAffineEPf"]
    pub fn SkMatrix_asAffine(this: *const SkMatrix, affine: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix9setAffineEPKf"]
    pub fn SkMatrix_setAffine(this: *mut SkMatrix, affine: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix9mapPointsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PKS0_i"]
    pub fn SkMatrix_mapHomogeneousPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PK7SkPointi"]
    pub fn SkMatrix_mapHomogeneousPoints1(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix5mapXYEffP7SkPoint"]
    pub fn SkMatrix_mapXY(this: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix10mapVectorsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapVectors(
        this: *const SkMatrix,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix7mapRectEP6SkRectRKS0_22SkApplyPerspectiveClip"]
    pub fn SkMatrix_mapRect(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix21mapRectScaleTranslateEP6SkRectRKS0_"]
    pub fn SkMatrix_mapRectScaleTranslate(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix9mapRadiusEf"]
    pub fn SkMatrix_mapRadius(this: *const SkMatrix, radius: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix4dumpEv"]
    pub fn SkMatrix_dump(this: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix11getMinScaleEv"]
    pub fn SkMatrix_getMinScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix11getMaxScaleEv"]
    pub fn SkMatrix_getMaxScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix15getMinMaxScalesEPf"]
    pub fn SkMatrix_getMinMaxScales(this: *const SkMatrix, scaleFactors: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkMatrix14decomposeScaleEP6SkSizePS_"]
    pub fn SkMatrix_decomposeScale(
        this: *const SkMatrix,
        scale: *mut SkSize,
        remaining: *mut SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix1IEv"]
    pub fn SkMatrix_I() -> *const SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkMatrix13InvalidMatrixEv"]
    pub fn SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
impl SkMatrix {
    #[inline]
    pub unsafe fn isSimilarity(&self, tol: SkScalar) -> bool {
        SkMatrix_isSimilarity(self, tol)
    }
    #[inline]
    pub unsafe fn preservesRightAngles(&self, tol: SkScalar) -> bool {
        SkMatrix_preservesRightAngles(self, tol)
    }
    #[inline]
    pub unsafe fn set9(&mut self, buffer: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_set9(self, buffer)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkMatrix {
        SkMatrix_reset(self)
    }
    #[inline]
    pub unsafe fn setTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn setScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn setScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn setRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn setRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_setRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn setSinCos(
        &mut self,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSinCos(self, sinValue, cosValue, px, py)
    }
    #[inline]
    pub unsafe fn setSinCos1(&mut self, sinValue: SkScalar, cosValue: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSinCos1(self, sinValue, cosValue)
    }
    #[inline]
    pub unsafe fn setRSXform(&mut self, rsxForm: *const SkRSXform) -> *mut SkMatrix {
        SkMatrix_setRSXform(self, rsxForm)
    }
    #[inline]
    pub unsafe fn setSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn setSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix, b: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn preScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn preRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn preRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_preRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn preSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn preSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_preSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_preConcat(self, other)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn postScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn postScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn postRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn postRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_postRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn postSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn postSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_postSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn postConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_postConcat(self, other)
    }
    #[inline]
    pub unsafe fn setRectToRect(
        &mut self,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool {
        SkMatrix_setRectToRect(self, src, dst, stf)
    }
    #[inline]
    pub unsafe fn setPolyToPoly(
        &mut self,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool {
        SkMatrix_setPolyToPoly(self, src, dst, count)
    }
    #[inline]
    pub unsafe fn SetAffineIdentity(affine: *mut SkScalar) {
        SkMatrix_SetAffineIdentity(affine)
    }
    #[inline]
    pub unsafe fn asAffine(&self, affine: *mut SkScalar) -> bool {
        SkMatrix_asAffine(self, affine)
    }
    #[inline]
    pub unsafe fn setAffine(&mut self, affine: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_setAffine(self, affine)
    }
    #[inline]
    pub unsafe fn mapPoints(
        &self,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints1(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints1(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapXY(&self, x: SkScalar, y: SkScalar, result: *mut SkPoint) {
        SkMatrix_mapXY(self, x, y, result)
    }
    #[inline]
    pub unsafe fn mapVectors(
        &self,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapVectors(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapRect(
        &self,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool {
        SkMatrix_mapRect(self, dst, src, pc)
    }
    #[inline]
    pub unsafe fn mapRectScaleTranslate(&self, dst: *mut SkRect, src: *const SkRect) {
        SkMatrix_mapRectScaleTranslate(self, dst, src)
    }
    #[inline]
    pub unsafe fn mapRadius(&self, radius: SkScalar) -> SkScalar {
        SkMatrix_mapRadius(self, radius)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkMatrix_dump(self)
    }
    #[inline]
    pub unsafe fn getMinScale(&self) -> SkScalar {
        SkMatrix_getMinScale(self)
    }
    #[inline]
    pub unsafe fn getMaxScale(&self) -> SkScalar {
        SkMatrix_getMaxScale(self)
    }
    #[inline]
    pub unsafe fn getMinMaxScales(&self, scaleFactors: *mut SkScalar) -> bool {
        SkMatrix_getMinMaxScales(self, scaleFactors)
    }
    #[inline]
    pub unsafe fn decomposeScale(&self, scale: *mut SkSize, remaining: *mut SkMatrix) -> bool {
        SkMatrix_decomposeScale(self, scale, remaining)
    }
    #[inline]
    pub unsafe fn I() -> *const SkMatrix {
        SkMatrix_I()
    }
    #[inline]
    pub unsafe fn InvalidMatrix() -> *const SkMatrix {
        SkMatrix_InvalidMatrix()
    }
}
impl SkEncodedOrigin {
    pub const Default: SkEncodedOrigin = SkEncodedOrigin::TopLeft;
}
impl SkEncodedOrigin {
    pub const Last: SkEncodedOrigin = SkEncodedOrigin::LeftBottom;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedOrigin {
    TopLeft = 1,
    TopRight = 2,
    BottomRight = 3,
    BottomLeft = 4,
    LeftTop = 5,
    RightTop = 6,
    RightBottom = 7,
    LeftBottom = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_DisposalMethod {
    kKeep = 1,
    kRestoreBGColor = 2,
    kRestorePrevious = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_Blend {
    kSrcOver = 0,
    kSrc = 1,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkOnce {
    pub fState: u8,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkOnce_State {
    NotStarted = 0,
    Claimed = 1,
    Done = 2,
}
#[test]
fn bindgen_test_layout_SkOnce() {
    assert_eq!(
        ::core::mem::size_of::<SkOnce>(),
        1usize,
        concat!("Size of: ", stringify!(SkOnce))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOnce>(),
        1usize,
        concat!("Alignment of ", stringify!(SkOnce))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkOnce>())).fState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOnce),
            "::",
            stringify!(fState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x3 {
    pub vals: [[f32; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x3() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x3>(),
        36usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x3))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_Matrix3x3>())).vals as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Matrix3x3),
            "::",
            stringify!(vals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x4 {
    pub vals: [[f32; 4usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x4() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x4>(),
        48usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x4))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x4>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_Matrix3x4>())).vals as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Matrix3x4),
            "::",
            stringify!(vals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_TransferFunction {
    pub g: f32,
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_skcms_TransferFunction() {
    assert_eq!(
        ::core::mem::size_of::<skcms_TransferFunction>(),
        28usize,
        concat!("Size of: ", stringify!(skcms_TransferFunction))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_TransferFunction>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_TransferFunction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).g as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).a as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).e as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_TransferFunction>())).f as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skcms_Curve {
    pub __bindgen_anon_1: skcms_Curve__bindgen_ty_1,
    pub __bindgen_anon_2: skcms_Curve__bindgen_ty_2,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_1 {
    pub alias_of_table_entries: u32,
    pub parametric: skcms_TransferFunction,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_Curve__bindgen_ty_1>())).alias_of_table_entries
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_1),
            "::",
            stringify!(alias_of_table_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_Curve__bindgen_ty_1>())).parametric as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_1),
            "::",
            stringify!(parametric)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_2 {
    pub table_entries: u32,
    pub table_8: *const u8,
    pub table_16: *const u8,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_Curve__bindgen_ty_2>())).table_entries as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_Curve__bindgen_ty_2>())).table_8 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_Curve__bindgen_ty_2>())).table_16 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_16)
        )
    );
}
#[test]
fn bindgen_test_layout_skcms_Curve() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_A2B {
    pub input_channels: u32,
    pub input_curves: [skcms_Curve; 4usize],
    pub grid_points: [u8; 4usize],
    pub grid_8: *const u8,
    pub grid_16: *const u8,
    pub matrix_channels: u32,
    pub matrix_curves: [skcms_Curve; 3usize],
    pub matrix: skcms_Matrix3x4,
    pub output_channels: u32,
    pub output_curves: [skcms_Curve; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_A2B() {
    assert_eq!(
        ::core::mem::size_of::<skcms_A2B>(),
        416usize,
        concat!("Size of: ", stringify!(skcms_A2B))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_A2B>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_A2B))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).input_channels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(input_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).input_curves as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(input_curves)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).grid_points as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).grid_8 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).grid_16 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).matrix_channels as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).matrix_curves as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix_curves)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).matrix as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).output_channels as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(output_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_A2B>())).output_curves as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(output_curves)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_ICCProfile {
    pub buffer: *const u8,
    pub size: u32,
    pub data_color_space: u32,
    pub pcs: u32,
    pub tag_count: u32,
    pub has_trc: bool,
    pub trc: [skcms_Curve; 3usize],
    pub has_toXYZD50: bool,
    pub toXYZD50: skcms_Matrix3x3,
    pub has_A2B: bool,
    pub A2B: skcms_A2B,
}
#[test]
fn bindgen_test_layout_skcms_ICCProfile() {
    assert_eq!(
        ::core::mem::size_of::<skcms_ICCProfile>(),
        592usize,
        concat!("Size of: ", stringify!(skcms_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_ICCProfile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<skcms_ICCProfile>())).data_color_space as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(data_color_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).pcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(pcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).tag_count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(tag_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).has_trc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).trc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).has_toXYZD50 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_toXYZD50)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).toXYZD50 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(toXYZD50)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).has_A2B as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_A2B)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skcms_ICCProfile>())).A2B as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(A2B)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_PixelFormat {
    skcms_PixelFormat_A_8 = 0,
    skcms_PixelFormat_A_8_ = 1,
    skcms_PixelFormat_G_8 = 2,
    skcms_PixelFormat_G_8_ = 3,
    skcms_PixelFormat_RGBA_8888_Palette8 = 4,
    skcms_PixelFormat_BGRA_8888_Palette8 = 5,
    skcms_PixelFormat_RGB_565 = 6,
    skcms_PixelFormat_BGR_565 = 7,
    skcms_PixelFormat_ABGR_4444 = 8,
    skcms_PixelFormat_ARGB_4444 = 9,
    skcms_PixelFormat_RGB_888 = 10,
    skcms_PixelFormat_BGR_888 = 11,
    skcms_PixelFormat_RGBA_8888 = 12,
    skcms_PixelFormat_BGRA_8888 = 13,
    skcms_PixelFormat_RGBA_8888_sRGB = 14,
    skcms_PixelFormat_BGRA_8888_sRGB = 15,
    skcms_PixelFormat_RGBA_1010102 = 16,
    skcms_PixelFormat_BGRA_1010102 = 17,
    skcms_PixelFormat_RGB_161616LE = 18,
    skcms_PixelFormat_BGR_161616LE = 19,
    skcms_PixelFormat_RGBA_16161616LE = 20,
    skcms_PixelFormat_BGRA_16161616LE = 21,
    skcms_PixelFormat_RGB_161616BE = 22,
    skcms_PixelFormat_BGR_161616BE = 23,
    skcms_PixelFormat_RGBA_16161616BE = 24,
    skcms_PixelFormat_BGRA_16161616BE = 25,
    skcms_PixelFormat_RGB_hhh_Norm = 26,
    skcms_PixelFormat_BGR_hhh_Norm = 27,
    skcms_PixelFormat_RGBA_hhhh_Norm = 28,
    skcms_PixelFormat_BGRA_hhhh_Norm = 29,
    skcms_PixelFormat_RGB_hhh = 30,
    skcms_PixelFormat_BGR_hhh = 31,
    skcms_PixelFormat_RGBA_hhhh = 32,
    skcms_PixelFormat_BGRA_hhhh = 33,
    skcms_PixelFormat_RGB_fff = 34,
    skcms_PixelFormat_BGR_fff = 35,
    skcms_PixelFormat_RGBA_ffff = 36,
    skcms_PixelFormat_BGRA_ffff = 37,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_AlphaFormat {
    skcms_AlphaFormat_Opaque = 0,
    skcms_AlphaFormat_Unpremul = 1,
    skcms_AlphaFormat_PremulAsEncoded = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkColorSpacePrimaries {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_SkColorSpacePrimaries() {
    assert_eq!(
        ::core::mem::size_of::<SkColorSpacePrimaries>(),
        32usize,
        concat!("Size of: ", stringify!(SkColorSpacePrimaries))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpacePrimaries>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpacePrimaries))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fRX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fRX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fRY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fGX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fGX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fGY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fGY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fBX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fBX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fBY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fBY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fWX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fWX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpacePrimaries>())).fWY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fWY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21SkColorSpacePrimaries8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpacePrimaries_toXYZD50(
        this: *const SkColorSpacePrimaries,
        toXYZD50: *mut skcms_Matrix3x3,
    ) -> bool;
}
impl SkColorSpacePrimaries {
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpacePrimaries_toXYZD50(self, toXYZD50)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorSpace {
    pub _base: SkNVRefCnt,
    pub fTransferFnHash: u32,
    pub fToXYZD50Hash: u32,
    pub fTransferFn: skcms_TransferFunction,
    pub fToXYZD50: skcms_Matrix3x3,
    pub fInvTransferFn: skcms_TransferFunction,
    pub fFromXYZD50: skcms_Matrix3x3,
    pub fLazyDstFieldsOnce: SkOnce,
}
#[test]
fn bindgen_test_layout_SkColorSpace() {
    assert_eq!(
        ::core::mem::size_of::<SkColorSpace>(),
        144usize,
        concat!("Size of: ", stringify!(SkColorSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpace>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fTransferFnHash as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fTransferFnHash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fToXYZD50Hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fToXYZD50Hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fTransferFn as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fTransferFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fToXYZD50 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fToXYZD50)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fInvTransferFn as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fInvTransferFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorSpace>())).fFromXYZD50 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fFromXYZD50)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkColorSpace>())).fLazyDstFieldsOnce as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fLazyDstFieldsOnce)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace8MakeSRGBEv"]
    pub fn SkColorSpace_MakeSRGB() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace14MakeSRGBLinearEv"]
    pub fn SkColorSpace_MakeSRGBLinear() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace7MakeRGBERK22skcms_TransferFunctionRK15skcms_Matrix3x3"]
    pub fn SkColorSpace_MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace4MakeERK16skcms_ICCProfile"]
    pub fn SkColorSpace_Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace9toProfileEP16skcms_ICCProfile"]
    pub fn SkColorSpace_toProfile(this: *const SkColorSpace, arg1: *mut skcms_ICCProfile);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace16gammaCloseToSRGBEv"]
    pub fn SkColorSpace_gammaCloseToSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace13gammaIsLinearEv"]
    pub fn SkColorSpace_gammaIsLinear(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace21isNumericalTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_isNumericalTransferFn(
        this: *const SkColorSpace,
        fn_: *mut skcms_TransferFunction,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpace_toXYZD50(this: *const SkColorSpace, toXYZD50: *mut skcms_Matrix3x3)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace15makeLinearGammaEv"]
    pub fn SkColorSpace_makeLinearGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace13makeSRGBGammaEv"]
    pub fn SkColorSpace_makeSRGBGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace13makeColorSpinEv"]
    pub fn SkColorSpace_makeColorSpin(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace6isSRGBEv"]
    pub fn SkColorSpace_isSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace9serializeEv"]
    pub fn SkColorSpace_serialize(this: *const SkColorSpace) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace13writeToMemoryEPv"]
    pub fn SkColorSpace_writeToMemory(
        this: *const SkColorSpace,
        memory: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace11DeserializeEPKvm"]
    pub fn SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkColorSpace6EqualsEPKS_S1_"]
    pub fn SkColorSpace_Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace10transferFnEPf"]
    pub fn SkColorSpace_transferFn(this: *const SkColorSpace, gabcdef: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace10transferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_transferFn1(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace13invTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_invTransferFn(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkColorSpace16gamutTransformToEPKS_P15skcms_Matrix3x3"]
    pub fn SkColorSpace_gamutTransformTo(
        this: *const SkColorSpace,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    );
}
impl SkColorSpace {
    #[inline]
    pub unsafe fn MakeSRGB() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGB()
    }
    #[inline]
    pub unsafe fn MakeSRGBLinear() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGBLinear()
    }
    #[inline]
    pub unsafe fn MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeRGB(transferFn, toXYZ)
    }
    #[inline]
    pub unsafe fn Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace> {
        SkColorSpace_Make(arg1)
    }
    #[inline]
    pub unsafe fn toProfile(&self, arg1: *mut skcms_ICCProfile) {
        SkColorSpace_toProfile(self, arg1)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorSpace_gammaCloseToSRGB(self)
    }
    #[inline]
    pub unsafe fn gammaIsLinear(&self) -> bool {
        SkColorSpace_gammaIsLinear(self)
    }
    #[inline]
    pub unsafe fn isNumericalTransferFn(&self, fn_: *mut skcms_TransferFunction) -> bool {
        SkColorSpace_isNumericalTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpace_toXYZD50(self, toXYZD50)
    }
    #[inline]
    pub unsafe fn makeLinearGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeLinearGamma(self)
    }
    #[inline]
    pub unsafe fn makeSRGBGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeSRGBGamma(self)
    }
    #[inline]
    pub unsafe fn makeColorSpin(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeColorSpin(self)
    }
    #[inline]
    pub unsafe fn isSRGB(&self) -> bool {
        SkColorSpace_isSRGB(self)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkColorSpace_serialize(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, memory: *mut ::core::ffi::c_void) -> usize {
        SkColorSpace_writeToMemory(self, memory)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_Deserialize(data, length)
    }
    #[inline]
    pub unsafe fn Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool {
        SkColorSpace_Equals(arg1, arg2)
    }
    #[inline]
    pub unsafe fn transferFn(&self, gabcdef: *mut f32) {
        SkColorSpace_transferFn(self, gabcdef)
    }
    #[inline]
    pub unsafe fn transferFn1(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_transferFn1(self, fn_)
    }
    #[inline]
    pub unsafe fn invTransferFn(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_invTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn gamutTransformTo(
        &self,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    ) {
        SkColorSpace_gamutTransformTo(self, dst, src_to_dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkReadBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkWriteBuffer {
    _unused: [u8; 0],
}
impl SkAlphaType {
    pub const LastEnum: SkAlphaType = SkAlphaType::Unpremul;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkAlphaType {
    Unknown = 0,
    Opaque = 1,
    Premul = 2,
    Unpremul = 3,
}
impl SkColorType {
    pub const kLastEnum_SkColorType: SkColorType = SkColorType::kR16G16B16A16_unorm_SkColorType;
}
impl SkColorType {
    pub const kN32_SkColorType: SkColorType = SkColorType::kBGRA_8888_SkColorType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorType {
    kUnknown_SkColorType = 0,
    kAlpha_8_SkColorType = 1,
    kRGB_565_SkColorType = 2,
    kARGB_4444_SkColorType = 3,
    kRGBA_8888_SkColorType = 4,
    kRGB_888x_SkColorType = 5,
    kBGRA_8888_SkColorType = 6,
    kRGBA_1010102_SkColorType = 7,
    kBGRA_1010102_SkColorType = 8,
    kRGB_101010x_SkColorType = 9,
    kBGR_101010x_SkColorType = 10,
    kGray_8_SkColorType = 11,
    kRGBA_F16Norm_SkColorType = 12,
    kRGBA_F16_SkColorType = 13,
    kRGBA_F32_SkColorType = 14,
    kR8G8_unorm_SkColorType = 15,
    kA16_float_SkColorType = 16,
    kR16G16_float_SkColorType = 17,
    kA16_unorm_SkColorType = 18,
    kR16G16_unorm_SkColorType = 19,
    kR16G16B16A16_unorm_SkColorType = 20,
}
extern "C" {
    #[link_name = "\u{1}_Z24SkColorTypeBytesPerPixel11SkColorType"]
    pub fn SkColorTypeBytesPerPixel(ct: SkColorType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z25SkColorTypeIsAlwaysOpaque11SkColorType"]
    pub fn SkColorTypeIsAlwaysOpaque(ct: SkColorType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z28SkColorTypeValidateAlphaType11SkColorType11SkAlphaTypePS0_"]
    pub fn SkColorTypeValidateAlphaType(
        colorType: SkColorType,
        alphaType: SkAlphaType,
        canonical: *mut SkAlphaType,
    ) -> bool;
}
impl SkYUVColorSpace {
    pub const LastEnum: SkYUVColorSpace = SkYUVColorSpace::Identity;
}
impl SkYUVColorSpace {
    pub const JPEG: SkYUVColorSpace = SkYUVColorSpace::JPEG_Full;
}
impl SkYUVColorSpace {
    pub const Rec601: SkYUVColorSpace = SkYUVColorSpace::Rec601_Limited;
}
impl SkYUVColorSpace {
    pub const Rec709: SkYUVColorSpace = SkYUVColorSpace::Rec709_Limited;
}
impl SkYUVColorSpace {
    pub const BT2020: SkYUVColorSpace = SkYUVColorSpace::BT2020_8bit_Limited;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVColorSpace {
    JPEG_Full = 0,
    Rec601_Limited = 1,
    Rec709_Full = 2,
    Rec709_Limited = 3,
    BT2020_8bit_Full = 4,
    BT2020_8bit_Limited = 5,
    BT2020_10bit_Full = 6,
    BT2020_10bit_Limited = 7,
    BT2020_12bit_Full = 8,
    BT2020_12bit_Limited = 9,
    Identity = 10,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorInfo {
    pub fColorSpace: sk_sp<SkColorSpace>,
    pub fColorType: SkColorType,
    pub fAlphaType: SkAlphaType,
}
#[test]
fn bindgen_test_layout_SkColorInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkColorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorInfo>())).fColorSpace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fColorSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorInfo>())).fColorType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fColorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorInfo>())).fAlphaType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fAlphaType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkColorInfo13bytesPerPixelEv"]
    pub fn SkColorInfo_bytesPerPixel(this: *const SkColorInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkColorInfo13shiftPerPixelEv"]
    pub fn SkColorInfo_shiftPerPixel(this: *const SkColorInfo) -> ::std::os::raw::c_int;
}
impl SkColorInfo {
    #[inline]
    pub unsafe fn bytesPerPixel(&self) -> ::std::os::raw::c_int {
        SkColorInfo_bytesPerPixel(self)
    }
    #[inline]
    pub unsafe fn shiftPerPixel(&self) -> ::std::os::raw::c_int {
        SkColorInfo_shiftPerPixel(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImageInfo {
    pub fColorInfo: SkColorInfo,
    pub fDimensions: SkISize,
}
#[test]
fn bindgen_test_layout_SkImageInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkImageInfo>(),
        24usize,
        concat!("Size of: ", stringify!(SkImageInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageInfo>())).fColorInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageInfo),
            "::",
            stringify!(fColorInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageInfo>())).fDimensions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageInfo),
            "::",
            stringify!(fDimensions)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkImageInfo7MakeS32Eii11SkAlphaType"]
    pub fn SkImageInfo_MakeS32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkImageInfo13computeOffsetEiim"]
    pub fn SkImageInfo_computeOffset(
        this: *const SkImageInfo,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkImageInfo15computeByteSizeEm"]
    pub fn SkImageInfo_computeByteSize(this: *const SkImageInfo, rowBytes: usize) -> usize;
}
impl SkImageInfo {
    #[inline]
    pub unsafe fn MakeS32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_MakeS32(width, height, at)
    }
    #[inline]
    pub unsafe fn computeOffset(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> usize {
        SkImageInfo_computeOffset(self, x, y, rowBytes)
    }
    #[inline]
    pub unsafe fn computeByteSize(&self, rowBytes: usize) -> usize {
        SkImageInfo_computeByteSize(self, rowBytes)
    }
}
pub type SkColor = u32;
pub const SK_ColorTRANSPARENT: SkColor = 0;
pub const SK_ColorBLACK: SkColor = 4278190080;
pub const SK_ColorDKGRAY: SkColor = 4282664004;
pub const SK_ColorGRAY: SkColor = 4287137928;
pub const SK_ColorLTGRAY: SkColor = 4291611852;
pub const SK_ColorWHITE: SkColor = 4294967295;
pub const SK_ColorRED: SkColor = 4294901760;
pub const SK_ColorGREEN: SkColor = 4278255360;
pub const SK_ColorBLUE: SkColor = 4278190335;
pub const SK_ColorYELLOW: SkColor = 4294967040;
pub const SK_ColorCYAN: SkColor = 4278255615;
pub const SK_ColorMAGENTA: SkColor = 4294902015;
extern "C" {
    #[link_name = "\u{1}_Z10SkRGBToHSVjjjPf"]
    pub fn SkRGBToHSV(red: U8CPU, green: U8CPU, blue: U8CPU, hsv: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_Z12SkHSVToColorjPKf"]
    pub fn SkHSVToColor(alpha: U8CPU, hsv: *const SkScalar) -> SkColor;
}
pub type SkPMColor = u32;
extern "C" {
    #[link_name = "\u{1}_Z17SkPreMultiplyARGBjjjj"]
    pub fn SkPreMultiplyARGB(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "\u{1}_Z18SkPreMultiplyColorj"]
    pub fn SkPreMultiplyColor(c: SkColor) -> SkPMColor;
}
impl SkColorChannel {
    pub const LastEnum: SkColorChannel = SkColorChannel::A;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannel {
    R = 0,
    G = 1,
    B = 2,
    A = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannelFlag {
    kRed_SkColorChannelFlag = 1,
    kGreen_SkColorChannelFlag = 2,
    kBlue_SkColorChannelFlag = 4,
    kAlpha_SkColorChannelFlag = 8,
    kGray_SkColorChannelFlag = 16,
    kRG_SkColorChannelFlags = 3,
    kRGB_SkColorChannelFlags = 7,
    kRGBA_SkColorChannelFlags = 15,
}
extern "C" {
    #[link_name = "\u{1}FromColor"]
    pub fn SkRGBA4f_FromColor(color: SkColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toSkColor"]
    pub fn SkRGBA4f_toSkColor(this: *const u8) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}FromPMColor"]
    pub fn SkRGBA4f_FromPMColor(arg1: SkPMColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toBytes_RGBA"]
    pub fn SkRGBA4f_toBytes_RGBA(this: *const u8) -> u32;
}
extern "C" {
    #[link_name = "\u{1}FromBytes_RGBA"]
    pub fn SkRGBA4f_FromBytes_RGBA(color: u32) -> u8;
}
pub type SkColor4f = [u32; 4usize];
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedImageFormat {
    BMP = 0,
    GIF = 1,
    ICO = 2,
    JPEG = 3,
    PNG = 4,
    WBMP = 5,
    WEBP = 6,
    PKM = 7,
    KTX = 8,
    ASTC = 9,
    DNG = 10,
    HEIF = 11,
    AVIF = 12,
}
impl SkFilterQuality {
    pub const Last: SkFilterQuality = SkFilterQuality::High;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFilterQuality {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFilterMode {
    kNearest = 0,
    kLinear = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMipmapMode {
    None = 0,
    Nearest = 1,
    Linear = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicResampler {
    pub B: f32,
    pub C: f32,
}
#[test]
fn bindgen_test_layout_SkCubicResampler() {
    assert_eq!(
        ::core::mem::size_of::<SkCubicResampler>(),
        8usize,
        concat!("Size of: ", stringify!(SkCubicResampler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicResampler>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicResampler))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCubicResampler>())).B as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicResampler),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCubicResampler>())).C as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicResampler),
            "::",
            stringify!(C)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSamplingOptions {
    pub useCubic: bool,
    pub cubic: SkCubicResampler,
    pub filter: SkFilterMode,
    pub mipmap: SkMipmapMode,
}
#[test]
fn bindgen_test_layout_SkSamplingOptions() {
    assert_eq!(
        ::core::mem::size_of::<SkSamplingOptions>(),
        20usize,
        concat!("Size of: ", stringify!(SkSamplingOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSamplingOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSamplingOptions))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSamplingOptions>())).useCubic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(useCubic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSamplingOptions>())).cubic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(cubic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSamplingOptions>())).filter as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSamplingOptions>())).mipmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(mipmap)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkSamplingOptionsC1E15SkFilterQuality"]
    pub fn SkSamplingOptions_SkSamplingOptions(this: *mut SkSamplingOptions, arg1: SkFilterQuality);
}
impl SkSamplingOptions {
    #[inline]
    pub unsafe fn new(arg1: SkFilterQuality) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSamplingOptions_SkSamplingOptions(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPixmap {
    pub fPixels: *const ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fInfo: SkImageInfo,
}
#[test]
fn bindgen_test_layout_SkPixmap() {
    assert_eq!(
        ::core::mem::size_of::<SkPixmap>(),
        40usize,
        concat!("Size of: ", stringify!(SkPixmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPixmap>())).fPixels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fPixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPixmap>())).fRowBytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPixmap>())).fInfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fInfo)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPixmap5resetEv"]
    pub fn SkPixmap_reset(this: *mut SkPixmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPixmap5resetERK11SkImageInfoPKvm"]
    pub fn SkPixmap_reset1(
        this: *mut SkPixmap,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPixmap13setColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkPixmap_setColorSpace(this: *mut SkPixmap, colorSpace: sk_sp<SkColorSpace>);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPixmap5resetERK6SkMask"]
    pub fn SkPixmap_reset2(this: *mut SkPixmap, mask: *const SkMask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkPixmap_extractSubset(
        this: *const SkPixmap,
        subset: *mut SkPixmap,
        area: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap15computeIsOpaqueEv"]
    pub fn SkPixmap_computeIsOpaque(this: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap8getColorEii"]
    pub fn SkPixmap_getColor(
        this: *const SkPixmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap9getAlphafEii"]
    pub fn SkPixmap_getAlphaf(
        this: *const SkPixmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkPixmap_readPixels(
        this: *const SkPixmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap11scalePixelsERKS_RK17SkSamplingOptions"]
    pub fn SkPixmap_scalePixels(
        this: *const SkPixmap,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap5eraseEjRK7SkIRect"]
    pub fn SkPixmap_erase(this: *const SkPixmap, color: SkColor, subset: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkPixmap5eraseERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpacePK7SkIRect"]
    pub fn SkPixmap_erase1(
        this: *const SkPixmap,
        color: *const SkColor4f,
        cs: *mut SkColorSpace,
        subset: *const SkIRect,
    ) -> bool;
}
impl SkPixmap {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPixmap_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(
        &mut self,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    ) {
        SkPixmap_reset1(self, info, addr, rowBytes)
    }
    #[inline]
    pub unsafe fn setColorSpace(&mut self, colorSpace: sk_sp<SkColorSpace>) {
        SkPixmap_setColorSpace(self, colorSpace)
    }
    #[inline]
    pub unsafe fn reset2(&mut self, mask: *const SkMask) -> bool {
        SkPixmap_reset2(self, mask)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, subset: *mut SkPixmap, area: *const SkIRect) -> bool {
        SkPixmap_extractSubset(self, subset, area)
    }
    #[inline]
    pub unsafe fn computeIsOpaque(&self) -> bool {
        SkPixmap_computeIsOpaque(self)
    }
    #[inline]
    pub unsafe fn getColor(&self, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> SkColor {
        SkPixmap_getColor(self, x, y)
    }
    #[inline]
    pub unsafe fn getAlphaf(&self, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> f32 {
        SkPixmap_getAlphaf(self, x, y)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkPixmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn scalePixels(&self, dst: *const SkPixmap, arg1: *const SkSamplingOptions) -> bool {
        SkPixmap_scalePixels(self, dst, arg1)
    }
    #[inline]
    pub unsafe fn erase(&self, color: SkColor, subset: *const SkIRect) -> bool {
        SkPixmap_erase(self, color, subset)
    }
    #[inline]
    pub unsafe fn erase1(
        &self,
        color: *const SkColor4f,
        cs: *mut SkColorSpace,
        subset: *const SkIRect,
    ) -> bool {
        SkPixmap_erase1(self, color, cs, subset)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkData {
    pub _base: SkNVRefCnt,
    pub fReleaseProc: SkData_ReleaseProc,
    pub fReleaseProcContext: *mut ::core::ffi::c_void,
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
pub type SkData_ReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(ptr: *const ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
>;
pub type SkData_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkData() {
    assert_eq!(
        ::core::mem::size_of::<SkData>(),
        40usize,
        concat!("Size of: ", stringify!(SkData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkData>(),
        8usize,
        concat!("Alignment of ", stringify!(SkData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkData>())).fReleaseProc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fReleaseProc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkData>())).fReleaseProcContext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fReleaseProcContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkData>())).fPtr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkData>())).fSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkData9copyRangeEmmPv"]
    pub fn SkData_copyRange(
        this: *const SkData,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkData6equalsEPKS_"]
    pub fn SkData_equals(this: *const SkData, other: *const SkData) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData12MakeWithCopyEPKvm"]
    pub fn SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData17MakeUninitializedEm"]
    pub fn SkData_MakeUninitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData15MakeWithCStringEPKc"]
    pub fn SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData12MakeWithProcEPKvmPFvS1_PvES2_"]
    pub fn SkData_MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData14MakeFromMallocEPKvm"]
    pub fn SkData_MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData16MakeFromFileNameEPKc"]
    pub fn SkData_MakeFromFileName(path: *const ::std::os::raw::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData12MakeFromFILEEP8_IO_FILE"]
    pub fn SkData_MakeFromFILE(f: *mut FILE) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData10MakeFromFDEi"]
    pub fn SkData_MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData14MakeFromStreamEP8SkStreamm"]
    pub fn SkData_MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData10MakeSubsetEPKS_mm"]
    pub fn SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkData9MakeEmptyEv"]
    pub fn SkData_MakeEmpty() -> sk_sp<SkData>;
}
impl SkData {
    #[inline]
    pub unsafe fn copyRange(
        &self,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize {
        SkData_copyRange(self, offset, length, buffer)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const SkData) -> bool {
        SkData_equals(self, other)
    }
    #[inline]
    pub unsafe fn MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeWithCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeUninitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeUninitialized(length)
    }
    #[inline]
    pub unsafe fn MakeWithCString(cstr: *const ::std::os::raw::c_char) -> sk_sp<SkData> {
        SkData_MakeWithCString(cstr)
    }
    #[inline]
    pub unsafe fn MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData> {
        SkData_MakeWithProc(ptr, length, proc_, ctx)
    }
    #[inline]
    pub unsafe fn MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeFromMalloc(data, length)
    }
    #[inline]
    pub unsafe fn MakeFromFileName(path: *const ::std::os::raw::c_char) -> sk_sp<SkData> {
        SkData_MakeFromFileName(path)
    }
    #[inline]
    pub unsafe fn MakeFromFILE(f: *mut FILE) -> sk_sp<SkData> {
        SkData_MakeFromFILE(f)
    }
    #[inline]
    pub unsafe fn MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData> {
        SkData_MakeFromFD(fd)
    }
    #[inline]
    pub unsafe fn MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData> {
        SkData_MakeFromStream(arg1, size)
    }
    #[inline]
    pub unsafe fn MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData> {
        SkData_MakeSubset(src, offset, length)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkData> {
        SkData_MakeEmpty()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStream() {
    assert_eq!(
        ::core::mem::size_of::<SkStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStream))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream12MakeFromFileEPKc"]
    pub fn SkStream_MakeFromFile(path: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream6readS8EPa"]
    pub fn SkStream_readS8(this: *mut SkStream, arg1: *mut i8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream7readS16EPs"]
    pub fn SkStream_readS16(this: *mut SkStream, arg1: *mut i16) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream7readS32EPi"]
    pub fn SkStream_readS32(this: *mut SkStream, arg1: *mut i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream10readScalarEPf"]
    pub fn SkStream_readScalar(this: *mut SkStream, arg1: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkStream14readPackedUIntEPm"]
    pub fn SkStream_readPackedUInt(this: *mut SkStream, arg1: *mut usize) -> bool;
}
impl SkStream {
    #[inline]
    pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char) -> u64 {
        SkStream_MakeFromFile(path)
    }
    #[inline]
    pub unsafe fn readS8(&mut self, arg1: *mut i8) -> bool {
        SkStream_readS8(self, arg1)
    }
    #[inline]
    pub unsafe fn readS16(&mut self, arg1: *mut i16) -> bool {
        SkStream_readS16(self, arg1)
    }
    #[inline]
    pub unsafe fn readS32(&mut self, arg1: *mut i32) -> bool {
        SkStream_readS32(self, arg1)
    }
    #[inline]
    pub unsafe fn readScalar(&mut self, arg1: *mut SkScalar) -> bool {
        SkStream_readScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn readPackedUInt(&mut self, arg1: *mut usize) -> bool {
        SkStream_readPackedUInt(self, arg1)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamAsset {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamAsset() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamAsset>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamAsset))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamAsset>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamAsset))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamMemory {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamMemory() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamMemory>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamMemory))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkWStream() {
    assert_eq!(
        ::core::mem::size_of::<SkWStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWStream))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream14writeDecAsTextEi"]
    pub fn SkWStream_writeDecAsText(this: *mut SkWStream, arg1: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream17writeBigDecAsTextEli"]
    pub fn SkWStream_writeBigDecAsText(
        this: *mut SkWStream,
        arg1: i64,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream14writeHexAsTextEji"]
    pub fn SkWStream_writeHexAsText(
        this: *mut SkWStream,
        arg1: u32,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream17writeScalarAsTextEf"]
    pub fn SkWStream_writeScalarAsText(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream11writeScalarEf"]
    pub fn SkWStream_writeScalar(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream15writePackedUIntEm"]
    pub fn SkWStream_writePackedUInt(this: *mut SkWStream, arg1: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream11writeStreamEP8SkStreamm"]
    pub fn SkWStream_writeStream(this: *mut SkWStream, input: *mut SkStream, length: usize)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream16SizeOfPackedUIntEm"]
    pub fn SkWStream_SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int;
}
impl SkWStream {
    #[inline]
    pub unsafe fn writeDecAsText(&mut self, arg1: i32) -> bool {
        SkWStream_writeDecAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeBigDecAsText(
        &mut self,
        arg1: i64,
        minDigits: ::std::os::raw::c_int,
    ) -> bool {
        SkWStream_writeBigDecAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeHexAsText(&mut self, arg1: u32, minDigits: ::std::os::raw::c_int) -> bool {
        SkWStream_writeHexAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeScalarAsText(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalarAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeScalar(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn writePackedUInt(&mut self, arg1: usize) -> bool {
        SkWStream_writePackedUInt(self, arg1)
    }
    #[inline]
    pub unsafe fn writeStream(&mut self, input: *mut SkStream, length: usize) -> bool {
        SkWStream_writeStream(self, input, length)
    }
    #[inline]
    pub unsafe fn SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int {
        SkWStream_SizeOfPackedUInt(value)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStreamD1Ev"]
    pub fn SkWStream_SkWStream_destructor(this: *mut SkWStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkWStream5flushEv"]
    pub fn SkWStream_flush(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMemoryStream {
    pub _base: SkStreamMemory,
    pub fData: sk_sp<SkData>,
    pub fOffset: usize,
}
pub type SkMemoryStream_INHERITED = SkStreamMemory;
#[test]
fn bindgen_test_layout_SkMemoryStream() {
    assert_eq!(
        ::core::mem::size_of::<SkMemoryStream>(),
        24usize,
        concat!("Size of: ", stringify!(SkMemoryStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMemoryStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMemoryStream))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMemoryStream>())).fData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMemoryStream),
            "::",
            stringify!(fData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMemoryStream>())).fOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMemoryStream),
            "::",
            stringify!(fOffset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream8MakeCopyEPKvm"]
    pub fn SkMemoryStream_MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream10MakeDirectEPKvm"]
    pub fn SkMemoryStream_MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream4MakeE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_Make(data: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream14setMemoryOwnedEPKvm"]
    pub fn SkMemoryStream_setMemoryOwned(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream7setDataE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_setData(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream12skipToAlign4Ev"]
    pub fn SkMemoryStream_skipToAlign4(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream8getAtPosEv"]
    pub fn SkMemoryStream_getAtPos(this: *mut SkMemoryStream) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStreamC1Ev"]
    pub fn SkMemoryStream_SkMemoryStream(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStreamC1Em"]
    pub fn SkMemoryStream_SkMemoryStream1(this: *mut SkMemoryStream, length: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStreamC1EPKvmb"]
    pub fn SkMemoryStream_SkMemoryStream2(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStreamC1E5sk_spI6SkDataE"]
    pub fn SkMemoryStream_SkMemoryStream3(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
impl SkMemoryStream {
    #[inline]
    pub unsafe fn MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeDirect(data, length)
    }
    #[inline]
    pub unsafe fn Make(data: sk_sp<SkData>) -> u64 {
        SkMemoryStream_Make(data)
    }
    #[inline]
    pub unsafe fn setMemoryOwned(&mut self, data: *const ::core::ffi::c_void, length: usize) {
        SkMemoryStream_setMemoryOwned(self, data, length)
    }
    #[inline]
    pub unsafe fn setData(&mut self, data: sk_sp<SkData>) {
        SkMemoryStream_setData(self, data)
    }
    #[inline]
    pub unsafe fn skipToAlign4(&mut self) {
        SkMemoryStream_skipToAlign4(self)
    }
    #[inline]
    pub unsafe fn getAtPos(&mut self) -> *const ::core::ffi::c_void {
        SkMemoryStream_getAtPos(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(length: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream1(__bindgen_tmp.as_mut_ptr(), length);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(data: *const ::core::ffi::c_void, length: usize, copyData: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream2(__bindgen_tmp.as_mut_ptr(), data, length, copyData);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(data: sk_sp<SkData>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream3(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream9setMemoryEPKvmb"]
    pub fn SkMemoryStream_setMemory(
        this: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream4readEPvm"]
    pub fn SkMemoryStream_read(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkMemoryStream7isAtEndEv"]
    pub fn SkMemoryStream_isAtEnd(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkMemoryStream4peekEPvm"]
    pub fn SkMemoryStream_peek(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream6rewindEv"]
    pub fn SkMemoryStream_rewind(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkMemoryStream11getPositionEv"]
    pub fn SkMemoryStream_getPosition(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream4seekEm"]
    pub fn SkMemoryStream_seek(this: *mut ::core::ffi::c_void, position: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream4moveEl"]
    pub fn SkMemoryStream_move(
        this: *mut ::core::ffi::c_void,
        offset: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkMemoryStream9getLengthEv"]
    pub fn SkMemoryStream_getLength(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkMemoryStream13getMemoryBaseEv"]
    pub fn SkMemoryStream_getMemoryBase(
        this: *mut ::core::ffi::c_void,
    ) -> *const ::core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDynamicMemoryWStream {
    pub _base: SkWStream,
    pub fHead: *mut SkDynamicMemoryWStream_Block,
    pub fTail: *mut SkDynamicMemoryWStream_Block,
    pub fBytesWrittenBeforeTail: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDynamicMemoryWStream_Block {
    _unused: [u8; 0],
}
pub type SkDynamicMemoryWStream_INHERITED = SkWStream;
#[test]
fn bindgen_test_layout_SkDynamicMemoryWStream() {
    assert_eq!(
        ::core::mem::size_of::<SkDynamicMemoryWStream>(),
        32usize,
        concat!("Size of: ", stringify!(SkDynamicMemoryWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDynamicMemoryWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDynamicMemoryWStream))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkDynamicMemoryWStream>())).fHead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkDynamicMemoryWStream>())).fTail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fTail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDynamicMemoryWStream>())).fBytesWrittenBeforeTail as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fBytesWrittenBeforeTail)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream4readEPvmm"]
    pub fn SkDynamicMemoryWStream_read(
        this: *mut SkDynamicMemoryWStream,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22SkDynamicMemoryWStream6copyToEPv"]
    pub fn SkDynamicMemoryWStream_copyTo(
        this: *const SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22SkDynamicMemoryWStream13writeToStreamEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToStream(
        this: *const SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream14copyToAndResetEPv"]
    pub fn SkDynamicMemoryWStream_copyToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream15writeToAndResetEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream15writeToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_writeToAndReset1(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream17prependToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_prependToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream12detachAsDataEv"]
    pub fn SkDynamicMemoryWStream_detachAsData(this: *mut SkDynamicMemoryWStream) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream14detachAsStreamEv"]
    pub fn SkDynamicMemoryWStream_detachAsStream(this: *mut SkDynamicMemoryWStream) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream5resetEv"]
    pub fn SkDynamicMemoryWStream_reset(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream11padToAlign4Ev"]
    pub fn SkDynamicMemoryWStream_padToAlign4(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStreamC1EOS_"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream(
        this: *mut SkDynamicMemoryWStream,
        arg1: *mut SkDynamicMemoryWStream,
    );
}
impl SkDynamicMemoryWStream {
    #[inline]
    pub unsafe fn read(
        &mut self,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool {
        SkDynamicMemoryWStream_read(self, buffer, offset, size)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyTo(self, dst)
    }
    #[inline]
    pub unsafe fn writeToStream(&self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToStream(self, dst)
    }
    #[inline]
    pub unsafe fn copyToAndReset(&mut self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset(&mut self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset1(&mut self, dst: *mut SkDynamicMemoryWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset1(self, dst)
    }
    #[inline]
    pub unsafe fn prependToAndReset(&mut self, dst: *mut SkDynamicMemoryWStream) {
        SkDynamicMemoryWStream_prependToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn detachAsData(&mut self) -> sk_sp<SkData> {
        SkDynamicMemoryWStream_detachAsData(self)
    }
    #[inline]
    pub unsafe fn detachAsStream(&mut self) -> u64 {
        SkDynamicMemoryWStream_detachAsStream(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkDynamicMemoryWStream_reset(self)
    }
    #[inline]
    pub unsafe fn padToAlign4(&mut self) {
        SkDynamicMemoryWStream_padToAlign4(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkDynamicMemoryWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDynamicMemoryWStream_SkDynamicMemoryWStream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStreamD1Ev"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream_destructor(
        this: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22SkDynamicMemoryWStream5writeEPKvm"]
    pub fn SkDynamicMemoryWStream_write(
        this: *mut ::core::ffi::c_void,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22SkDynamicMemoryWStream12bytesWrittenEv"]
    pub fn SkDynamicMemoryWStream_bytesWritten(this: *mut ::core::ffi::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAIndex {
    pub fIndex: ::std::os::raw::c_int,
    pub fChannel: SkColorChannel,
}
impl SkYUVAIndex_Index {
    pub const Last: SkYUVAIndex_Index = SkYUVAIndex_Index::A;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAIndex_Index {
    Y = 0,
    U = 1,
    V = 2,
    A = 3,
}
pub const SkYUVAIndex_kIndexCount: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAIndex() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAIndex>(),
        8usize,
        concat!("Size of: ", stringify!(SkYUVAIndex))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAIndex>(),
        4usize,
        concat!("Alignment of ", stringify!(SkYUVAIndex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAIndex>())).fIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAIndex),
            "::",
            stringify!(fIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAIndex>())).fChannel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAIndex),
            "::",
            stringify!(fChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAInfo {
    pub fDimensions: SkISize,
    pub fPlaneConfig: SkYUVAInfo_PlaneConfig,
    pub fSubsampling: SkYUVAInfo_Subsampling,
    pub fYUVColorSpace: SkYUVColorSpace,
    pub fOrigin: SkEncodedOrigin,
    pub fSitingX: SkYUVAInfo_Siting,
    pub fSitingY: SkYUVAInfo_Siting,
}
impl SkYUVAInfo_PlaneConfig {
    pub const kLast: SkYUVAInfo_PlaneConfig = SkYUVAInfo_PlaneConfig::kUYVA;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_PlaneConfig {
    kUnknown = 0,
    kY_U_V = 1,
    kY_V_U = 2,
    kY_UV = 3,
    kY_VU = 4,
    kYUV = 5,
    kUYV = 6,
    kY_U_V_A = 7,
    kY_V_U_A = 8,
    kY_UV_A = 9,
    kY_VU_A = 10,
    kYUVA = 11,
    kUYVA = 12,
}
impl SkYUVAInfo_Subsampling {
    pub const kLast: SkYUVAInfo_Subsampling = SkYUVAInfo_Subsampling::k410;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Subsampling {
    kUnknown = 0,
    k444 = 1,
    k422 = 2,
    k420 = 3,
    k440 = 4,
    k411 = 5,
    k410 = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Siting {
    kCentered = 0,
}
pub const SkYUVAInfo_kMaxPlanes: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkYUVAInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkYUVAInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fDimensions as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fPlaneConfig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fPlaneConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fSubsampling as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSubsampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fYUVColorSpace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fYUVColorSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fOrigin as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fOrigin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fSitingX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSitingX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAInfo>())).fSitingY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSitingY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkYUVAInfo15PlaneDimensionsE7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkEncodedOriginPS0_"]
    pub fn SkYUVAInfo_PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkYUVAInfo14GetYUVAIndicesENS_11PlaneConfigEPKjP11SkYUVAIndex"]
    pub fn SkYUVAInfo_GetYUVAIndices(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
        indices: *mut SkYUVAIndex,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkYUVAInfo8HasAlphaENS_11PlaneConfigE"]
    pub fn SkYUVAInfo_HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkYUVAInfo17computeTotalBytesEPKmPm"]
    pub fn SkYUVAInfo_computeTotalBytes(
        this: *const SkYUVAInfo,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkYUVAInfo15makeSubsamplingENS_11SubsamplingE"]
    pub fn SkYUVAInfo_makeSubsampling(
        this: *const SkYUVAInfo,
        arg1: SkYUVAInfo_Subsampling,
    ) -> SkYUVAInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkYUVAInfoC1E7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkYUVColorSpace15SkEncodedOriginNS_6SitingES5_"]
    pub fn SkYUVAInfo_SkYUVAInfo(
        this: *mut SkYUVAInfo,
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    );
}
impl SkYUVAInfo {
    #[inline]
    pub unsafe fn PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::std::os::raw::c_int {
        SkYUVAInfo_PlaneDimensions(imageDimensions, arg1, arg2, arg3, planeDimensions)
    }
    #[inline]
    pub unsafe fn GetYUVAIndices(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
        indices: *mut SkYUVAIndex,
    ) -> bool {
        SkYUVAInfo_GetYUVAIndices(arg1, planeChannelFlags, indices)
    }
    #[inline]
    pub unsafe fn HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool {
        SkYUVAInfo_HasAlpha(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(
        &self,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize {
        SkYUVAInfo_computeTotalBytes(self, rowBytes, planeSizes)
    }
    #[inline]
    pub unsafe fn makeSubsampling(&self, arg1: SkYUVAInfo_Subsampling) -> SkYUVAInfo {
        SkYUVAInfo_makeSubsampling(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAInfo_SkYUVAInfo(
            __bindgen_tmp.as_mut_ptr(),
            dimensions,
            arg1,
            arg2,
            arg3,
            origin,
            sitingX,
            sitingY,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmapInfo {
    pub fYUVAInfo: SkYUVAInfo,
    pub fPlaneInfos: [u64; 12usize],
    pub fRowBytes: [u64; 4usize],
    pub fDataType: SkYUVAPixmapInfo_DataType,
}
pub use self::SkYUVAInfo_PlaneConfig as SkYUVAPixmapInfo_PlaneConfig;
pub use self::SkYUVAInfo_Subsampling as SkYUVAPixmapInfo_Subsampling;
impl SkYUVAPixmapInfo_DataType {
    pub const kLast: SkYUVAPixmapInfo_DataType = SkYUVAPixmapInfo_DataType::kUnorm10_Unorm2;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAPixmapInfo_DataType {
    kUnorm8 = 0,
    kUnorm16 = 1,
    kFloat16 = 2,
    kUnorm10_Unorm2 = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAPixmapInfo_SupportedDataTypes {
    pub fDataTypeSupport: u64,
}
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo_SupportedDataTypes() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo_SupportedDataTypes))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkYUVAPixmapInfo_SupportedDataTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkYUVAPixmapInfo_SupportedDataTypes>())).fDataTypeSupport
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo_SupportedDataTypes),
            "::",
            stringify!(fDataTypeSupport)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkYUVAPixmapInfo18SupportedDataTypes14enableDataTypeENS_8DataTypeEi"]
    pub fn SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(
        this: *mut SkYUVAPixmapInfo_SupportedDataTypes,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkYUVAPixmapInfo18SupportedDataTypesC1ERK14GrImageContext"]
    pub fn SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes(
        this: *mut SkYUVAPixmapInfo_SupportedDataTypes,
        arg1: *const GrImageContext,
    );
}
impl SkYUVAPixmapInfo_SupportedDataTypes {
    #[inline]
    pub unsafe fn enableDataType(
        &mut self,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::std::os::raw::c_int,
    ) {
        SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(self, arg1, numChannels)
    }
    #[inline]
    pub unsafe fn new(arg1: *const GrImageContext) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
pub const SkYUVAPixmapInfo_kMaxPlanes: ::std::os::raw::c_int = 4;
pub const SkYUVAPixmapInfo_kDataTypeCnt: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo>(),
        168usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmapInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmapInfo>())).fYUVAInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmapInfo>())).fPlaneInfos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fPlaneInfos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmapInfo>())).fRowBytes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmapInfo>())).fDataType as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fDataType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkYUVAPixmapInfo22NumChannelsAndDataTypeE11SkColorType"]
    pub fn SkYUVAPixmapInfo_NumChannelsAndDataType(arg1: SkColorType) -> std_tuple;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkYUVAPixmapInfo17computeTotalBytesEPm"]
    pub fn SkYUVAPixmapInfo_computeTotalBytes(
        this: *const SkYUVAPixmapInfo,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkYUVAPixmapInfo31initPixmapsFromSingleAllocationEPvP8SkPixmap"]
    pub fn SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(
        this: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkYUVAPixmapInfo11isSupportedERKNS_18SupportedDataTypesE"]
    pub fn SkYUVAPixmapInfo_isSupported(
        this: *const SkYUVAPixmapInfo,
        arg1: *const SkYUVAPixmapInfo_SupportedDataTypes,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoPK11SkColorTypePKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoNS_8DataTypeEPKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo1(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    );
}
impl SkYUVAPixmapInfo {
    #[inline]
    pub unsafe fn NumChannelsAndDataType(arg1: SkColorType) -> std_tuple {
        SkYUVAPixmapInfo_NumChannelsAndDataType(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(&self, planeSizes: *mut usize) -> usize {
        SkYUVAPixmapInfo_computeTotalBytes(self, planeSizes)
    }
    #[inline]
    pub unsafe fn initPixmapsFromSingleAllocation(
        &self,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool {
        SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(self, memory, pixmaps)
    }
    #[inline]
    pub unsafe fn isSupported(&self, arg1: *const SkYUVAPixmapInfo_SupportedDataTypes) -> bool {
        SkYUVAPixmapInfo_isSupported(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmaps {
    pub fPlanes: [u64; 20usize],
    pub fData: sk_sp<SkData>,
    pub fYUVAInfo: SkYUVAInfo,
    pub fDataType: SkYUVAPixmaps_DataType,
}
pub use self::SkYUVAPixmapInfo_DataType as SkYUVAPixmaps_DataType;
pub const SkYUVAPixmaps_kMaxPlanes: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmaps() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmaps>(),
        208usize,
        concat!("Size of: ", stringify!(SkYUVAPixmaps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmaps>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmaps))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmaps>())).fPlanes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmaps>())).fData as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmaps>())).fYUVAInfo as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVAPixmaps>())).fDataType as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fDataType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps24RecommendedRGBAColorTypeEN16SkYUVAPixmapInfo8DataTypeE"]
    pub fn SkYUVAPixmaps_RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps8AllocateERK16SkYUVAPixmapInfo"]
    pub fn SkYUVAPixmaps_Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps8FromDataERK16SkYUVAPixmapInfo5sk_spI6SkDataE"]
    pub fn SkYUVAPixmaps_FromData(
        arg1: *const SkYUVAPixmapInfo,
        arg2: sk_sp<SkData>,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps8MakeCopyERKS_"]
    pub fn SkYUVAPixmaps_MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps18FromExternalMemoryERK16SkYUVAPixmapInfoPv"]
    pub fn SkYUVAPixmaps_FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkYUVAPixmaps19FromExternalPixmapsERK10SkYUVAInfoPK8SkPixmap"]
    pub fn SkYUVAPixmaps_FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkYUVAPixmaps11pixmapsInfoEv"]
    pub fn SkYUVAPixmaps_pixmapsInfo(this: *const SkYUVAPixmaps) -> SkYUVAPixmapInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkYUVAPixmaps13toYUVAIndicesEP11SkYUVAIndex"]
    pub fn SkYUVAPixmaps_toYUVAIndices(this: *const SkYUVAPixmaps, arg1: *mut SkYUVAIndex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkYUVAPixmaps8toLegacyEP14SkYUVASizeInfoP11SkYUVAIndex"]
    pub fn SkYUVAPixmaps_toLegacy(
        this: *const SkYUVAPixmaps,
        arg1: *mut SkYUVASizeInfo,
        arg2: *mut SkYUVAIndex,
    ) -> bool;
}
impl SkYUVAPixmaps {
    #[inline]
    pub unsafe fn RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType {
        SkYUVAPixmaps_RecommendedRGBAColorType(arg1)
    }
    #[inline]
    pub unsafe fn Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps {
        SkYUVAPixmaps_Allocate(yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn FromData(arg1: *const SkYUVAPixmapInfo, arg2: sk_sp<SkData>) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps {
        SkYUVAPixmaps_MakeCopy(src)
    }
    #[inline]
    pub unsafe fn FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalMemory(arg1, memory)
    }
    #[inline]
    pub unsafe fn FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalPixmaps(arg1, arg2)
    }
    #[inline]
    pub unsafe fn pixmapsInfo(&self) -> SkYUVAPixmapInfo {
        SkYUVAPixmaps_pixmapsInfo(self)
    }
    #[inline]
    pub unsafe fn toYUVAIndices(&self, arg1: *mut SkYUVAIndex) -> bool {
        SkYUVAPixmaps_toYUVAIndices(self, arg1)
    }
    #[inline]
    pub unsafe fn toLegacy(&self, arg1: *mut SkYUVASizeInfo, arg2: *mut SkYUVAIndex) -> bool {
        SkYUVAPixmaps_toLegacy(self, arg1, arg2)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkEncodedInfo {
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fColor: SkEncodedInfo_Color,
    pub fAlpha: SkEncodedInfo_Alpha,
    pub fBitsPerComponent: u8,
    pub fProfile: u64,
}
#[repr(C)]
pub struct SkEncodedInfo_ICCProfile {
    pub fProfile: skcms_ICCProfile,
    pub fData: sk_sp<SkData>,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo_ICCProfile() {
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo_ICCProfile>(),
        600usize,
        concat!("Size of: ", stringify!(SkEncodedInfo_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo_ICCProfile))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkEncodedInfo_ICCProfile>())).fProfile as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo_ICCProfile),
            "::",
            stringify!(fProfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo_ICCProfile>())).fData as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo_ICCProfile),
            "::",
            stringify!(fData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkEncodedInfo10ICCProfile4MakeE5sk_spI6SkDataE"]
    pub fn SkEncodedInfo_ICCProfile_Make(arg1: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkEncodedInfo10ICCProfile4MakeERK16skcms_ICCProfile"]
    pub fn SkEncodedInfo_ICCProfile_Make1(arg1: *const skcms_ICCProfile) -> u64;
}
impl SkEncodedInfo_ICCProfile {
    #[inline]
    pub unsafe fn Make(arg1: sk_sp<SkData>) -> u64 {
        SkEncodedInfo_ICCProfile_Make(arg1)
    }
    #[inline]
    pub unsafe fn Make1(arg1: *const skcms_ICCProfile) -> u64 {
        SkEncodedInfo_ICCProfile_Make1(arg1)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Alpha {
    kOpaque_Alpha = 0,
    kUnpremul_Alpha = 1,
    kBinary_Alpha = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Color {
    kGray_Color = 0,
    kGrayAlpha_Color = 1,
    kXAlpha_Color = 2,
    k565_Color = 3,
    kPalette_Color = 4,
    kRGB_Color = 5,
    kRGBA_Color = 6,
    kBGR_Color = 7,
    kBGRX_Color = 8,
    kBGRA_Color = 9,
    kYUV_Color = 10,
    kYUVA_Color = 11,
    kInvertedCMYK_Color = 12,
    kYCCK_Color = 13,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkEncodedInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo>())).fWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo>())).fHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo>())).fColor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo>())).fAlpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkEncodedInfo>())).fBitsPerComponent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fBitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkEncodedInfo>())).fProfile as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fProfile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkNoncopyable {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkNoncopyable() {
    assert_eq!(
        ::core::mem::size_of::<SkNoncopyable>(),
        1usize,
        concat!("Size of: ", stringify!(SkNoncopyable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNoncopyable>(),
        1usize,
        concat!("Alignment of ", stringify!(SkNoncopyable))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPngChunkReader {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SkCodec__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct SkCodec {
    pub vtable_: *const SkCodec__bindgen_vtable,
    pub fEncodedInfo: SkEncodedInfo,
    pub fSrcXformFormat: SkCodec_XformFormat,
    pub fStream: u64,
    pub fNeedsRewind: bool,
    pub fOrigin: SkEncodedOrigin,
    pub fDstInfo: SkImageInfo,
    pub fOptions: SkCodec_Options,
    pub fXformTime: SkCodec_XformTime,
    pub fDstXformFormat: SkCodec_XformFormat,
    pub fDstProfile: skcms_ICCProfile,
    pub fDstXformAlphaFormat: skcms_AlphaFormat,
    pub fCurrScanline: ::std::os::raw::c_int,
    pub fStartedIncrementalDecode: bool,
    pub fAndroidCodecHandlesFrameIndex: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_Result {
    Success = 0,
    IncompleteInput = 1,
    ErrorInInput = 2,
    InvalidConversion = 3,
    InvalidScale = 4,
    InvalidParameters = 5,
    InvalidInput = 6,
    CouldNotRewind = 7,
    InternalError = 8,
    Unimplemented = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SelectionPolicy {
    PreferStillImage = 0,
    PreferAnimation = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_ZeroInitialized {
    Yes = 0,
    No = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_Options {
    pub fZeroInitialized: SkCodec_ZeroInitialized,
    pub fSubset: *const SkIRect,
    pub fFrameIndex: ::std::os::raw::c_int,
    pub fPriorFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkCodec_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec_Options>(),
        24usize,
        concat!("Size of: ", stringify!(SkCodec_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec_Options))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec_Options>())).fZeroInitialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fZeroInitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_Options>())).fSubset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fSubset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_Options>())).fFrameIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fFrameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_Options>())).fPriorFrame as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fPriorFrame)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SkScanlineOrder {
    kTopDown_SkScanlineOrder = 0,
    kBottomUp_SkScanlineOrder = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_FrameInfo {
    pub fRequiredFrame: ::std::os::raw::c_int,
    pub fDuration: ::std::os::raw::c_int,
    pub fFullyReceived: bool,
    pub fAlphaType: SkAlphaType,
    pub fHasAlphaWithinBounds: bool,
    pub fDisposalMethod: SkCodecAnimation_DisposalMethod,
    pub fBlend: SkCodecAnimation_Blend,
    pub fFrameRect: SkIRect,
}
#[test]
fn bindgen_test_layout_SkCodec_FrameInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec_FrameInfo>(),
        44usize,
        concat!("Size of: ", stringify!(SkCodec_FrameInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_FrameInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCodec_FrameInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fRequiredFrame as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fRequiredFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fDuration as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fFullyReceived as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fFullyReceived)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fAlphaType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fAlphaType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fHasAlphaWithinBounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fHasAlphaWithinBounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fDisposalMethod as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fDisposalMethod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fBlend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec_FrameInfo>())).fFrameRect as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fFrameRect)
        )
    );
}
pub use self::skcms_PixelFormat as SkCodec_XformFormat;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_XformTime {
    kNo_XformTime = 0,
    kPalette_XformTime = 1,
    kDecodeRow_XformTime = 2,
}
pub const SkCodec_kNoFrame: ::std::os::raw::c_int = -1;
pub const SkCodec_kRepetitionCountInfinite: ::std::os::raw::c_int = -1;
#[test]
fn bindgen_test_layout_SkCodec() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec>(),
        728usize,
        concat!("Size of: ", stringify!(SkCodec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fEncodedInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fEncodedInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fSrcXformFormat as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fSrcXformFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fStream as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fNeedsRewind as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fNeedsRewind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fOrigin as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fOrigin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fDstInfo as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fOptions as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fXformTime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fXformTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fDstXformFormat as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstXformFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fDstProfile as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstProfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fDstXformAlphaFormat as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstXformAlphaFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCodec>())).fCurrScanline as *const _ as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fCurrScanline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec>())).fStartedIncrementalDecode as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fStartedIncrementalDecode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCodec>())).fAndroidCodecHandlesFrameIndex as *const _ as usize
        },
        721usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fAndroidCodecHandlesFrameIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec14ResultToStringENS_6ResultE"]
    pub fn SkCodec_ResultToString(arg1: SkCodec_Result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec14MakeFromStreamESt10unique_ptrI8SkStreamSt14default_deleteIS1_EEPNS_6ResultEP16SkPngChunkReaderNS_15SelectionPolicyE"]
    pub fn SkCodec_MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec12MakeFromDataE5sk_spI6SkDataEP16SkPngChunkReader"]
    pub fn SkCodec_MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec9getPixelsERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_getPixels(
        this: *mut SkCodec,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkCodec13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkCodec_queryYUVAInfo(
        this: *const SkCodec,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkCodec_getYUVAPlanes(
        this: *mut SkCodec,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec22startIncrementalDecodeERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_startIncrementalDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec19startScanlineDecodeERK11SkImageInfoPKNS_7OptionsE"]
    pub fn SkCodec_startScanlineDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec12getScanlinesEPvim"]
    pub fn SkCodec_getScanlines(
        this: *mut SkCodec,
        dst: *mut ::core::ffi::c_void,
        countLines: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec13skipScanlinesEi"]
    pub fn SkCodec_skipScanlines(this: *mut SkCodec, countLines: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkCodec14outputScanlineEi"]
    pub fn SkCodec_outputScanline(
        this: *const SkCodec,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec12getFrameInfoEv"]
    pub fn SkCodec_getFrameInfo(this: *mut SkCodec) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec8RegisterEPFbPKvmEPFSt10unique_ptrIS_St14default_deleteIS_EES4_I8SkStreamS5_IS8_EEPNS_6ResultEE"]
    pub fn SkCodec_Register(
        peek: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *mut SkCodec_Result) -> u64,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec14rewindIfNeededEv"]
    pub fn SkCodec_rewindIfNeeded(this: *mut SkCodec) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkCodec15applyColorXformEPvPKvi"]
    pub fn SkCodec_applyColorXform(
        this: *const SkCodec,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodecC2EO13SkEncodedInfo17skcms_PixelFormatSt10unique_ptrI8SkStreamSt14default_deleteIS4_EE15SkEncodedOrigin"]
    pub fn SkCodec_SkCodec(
        this: *mut SkCodec,
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    );
}
impl SkCodec {
    #[inline]
    pub unsafe fn ResultToString(arg1: SkCodec_Result) -> *const ::std::os::raw::c_char {
        SkCodec_ResultToString(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64 {
        SkCodec_MakeFromStream(arg1, arg2, arg3, selectionPolicy)
    }
    #[inline]
    pub unsafe fn MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64 {
        SkCodec_MakeFromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_getPixels(self, info, pixels, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkCodec_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> SkCodec_Result {
        SkCodec_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn startIncrementalDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startIncrementalDecode(self, dstInfo, dst, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn startScanlineDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startScanlineDecode(self, dstInfo, options)
    }
    #[inline]
    pub unsafe fn getScanlines(
        &mut self,
        dst: *mut ::core::ffi::c_void,
        countLines: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> ::std::os::raw::c_int {
        SkCodec_getScanlines(self, dst, countLines, rowBytes)
    }
    #[inline]
    pub unsafe fn skipScanlines(&mut self, countLines: ::std::os::raw::c_int) -> bool {
        SkCodec_skipScanlines(self, countLines)
    }
    #[inline]
    pub unsafe fn outputScanline(
        &self,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkCodec_outputScanline(self, inputScanline)
    }
    #[inline]
    pub unsafe fn getFrameInfo(&mut self) -> u8 {
        SkCodec_getFrameInfo(self)
    }
    #[inline]
    pub unsafe fn Register(
        peek: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *mut SkCodec_Result) -> u64,
        >,
    ) {
        SkCodec_Register(peek, make)
    }
    #[inline]
    pub unsafe fn rewindIfNeeded(&mut self) -> bool {
        SkCodec_rewindIfNeeded(self)
    }
    #[inline]
    pub unsafe fn applyColorXform(
        &self,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::std::os::raw::c_int,
    ) {
        SkCodec_applyColorXform(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCodec_SkCodec(__bindgen_tmp.as_mut_ptr(), arg1, srcFormat, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodecD1Ev"]
    pub fn SkCodec_SkCodec_destructor(this: *mut SkCodec);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkCodec16onOutputScanlineEi"]
    pub fn SkCodec_onOutputScanline(
        this: *mut ::core::ffi::c_void,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkCodec19conversionSupportedERK11SkImageInfobb"]
    pub fn SkCodec_conversionSupported(
        this: *mut ::core::ffi::c_void,
        dst: *const SkImageInfo,
        srcIsOpaque: bool,
        needsColorXform: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z21SkAnnotateRectWithURLP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateRectWithURL(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}_Z26SkAnnotateNamedDestinationP8SkCanvasRK7SkPointP6SkData"]
    pub fn SkAnnotateNamedDestination(arg1: *mut SkCanvas, arg2: *const SkPoint, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}_Z27SkAnnotateLinkToDestinationP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateLinkToDestination(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
impl SkBlendMode {
    pub const LastCoeffMode: SkBlendMode = SkBlendMode::Screen;
}
impl SkBlendMode {
    pub const LastSeparableMode: SkBlendMode = SkBlendMode::Multiply;
}
impl SkBlendMode {
    pub const LastMode: SkBlendMode = SkBlendMode::Luminosity;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendMode {
    Clear = 0,
    Src = 1,
    Dst = 2,
    SrcOver = 3,
    DstOver = 4,
    SrcIn = 5,
    DstIn = 6,
    SrcOut = 7,
    DstOut = 8,
    SrcATop = 9,
    DstATop = 10,
    Xor = 11,
    Plus = 12,
    Modulate = 13,
    Screen = 14,
    Overlay = 15,
    Darken = 16,
    Lighten = 17,
    ColorDodge = 18,
    ColorBurn = 19,
    HardLight = 20,
    SoftLight = 21,
    Difference = 22,
    Exclusion = 23,
    Multiply = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendModeCoeff {
    Zero = 0,
    One = 1,
    SC = 2,
    ISC = 3,
    DC = 4,
    IDC = 5,
    SA = 6,
    ISA = 7,
    DA = 8,
    IDA = 9,
    CoeffCount = 10,
}
extern "C" {
    #[link_name = "\u{1}_Z19SkBlendMode_AsCoeff11SkBlendModeP16SkBlendModeCoeffS1_"]
    pub fn SkBlendMode_AsCoeff(
        mode: SkBlendMode,
        src: *mut SkBlendModeCoeff,
        dst: *mut SkBlendModeCoeff,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z16SkBlendMode_Name11SkBlendMode"]
    pub fn SkBlendMode_Name(blendMode: SkBlendMode) -> *const ::std::os::raw::c_char;
}
impl SkClipOp {
    pub const Max_EnumValue: SkClipOp = SkClipOp::Intersect;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkClipOp {
    Difference = 0,
    Intersect = 1,
    ExtraEnumNeedInternallyPleaseIgnoreWillGoAway2 = 2,
    ExtraEnumNeedInternallyPleaseIgnoreWillGoAway3 = 3,
    ExtraEnumNeedInternallyPleaseIgnoreWillGoAway4 = 4,
    ExtraEnumNeedInternallyPleaseIgnoreWillGoAway5 = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextEncoding {
    kUTF8 = 0,
    kUTF16 = 1,
    kUTF32 = 2,
    kGlyphID = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontHinting {
    None = 0,
    Slight = 1,
    Normal = 2,
    Full = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SkV2() {
    assert_eq!(
        ::core::mem::size_of::<SkV2>(),
        8usize,
        concat!("Size of: ", stringify!(SkV2))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV2>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_SkV3() {
    assert_eq!(
        ::core::mem::size_of::<SkV3>(),
        12usize,
        concat!("Size of: ", stringify!(SkV3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_SkV4() {
    assert_eq!(
        ::core::mem::size_of::<SkV4>(),
        16usize,
        concat!("Size of: ", stringify!(SkV4))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV4>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkV4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkM44 {
    pub fMat: [SkScalar; 16usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_Uninitialized_Constructor {
    kUninitialized_Constructor = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_NaN_Constructor {
    kNaN_Constructor = 0,
}
#[test]
fn bindgen_test_layout_SkM44() {
    assert_eq!(
        ::core::mem::size_of::<SkM44>(),
        64usize,
        concat!("Size of: ", stringify!(SkM44))
    );
    assert_eq!(
        ::core::mem::align_of::<SkM44>(),
        4usize,
        concat!("Alignment of ", stringify!(SkM44))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkM44>())).fMat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkM44),
            "::",
            stringify!(fMat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5SkM4411getRowMajorEPf"]
    pub fn SkM44_getRowMajor(this: *const SkM44, v: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM4419setRotateUnitSinCosE4SkV3ff"]
    pub fn SkM44_setRotateUnitSinCos(
        this: *mut SkM44,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM449setRotateE4SkV3f"]
    pub fn SkM44_setRotate(this: *mut SkM44, axis: SkV3, radians: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM449setConcatERKS_S1_"]
    pub fn SkM44_setConcat(this: *mut SkM44, a: *const SkM44, b: *const SkM44) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM4420normalizePerspectiveEv"]
    pub fn SkM44_normalizePerspective(this: *mut SkM44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5SkM446invertEPS_"]
    pub fn SkM44_invert(this: *const SkM44, inverse: *mut SkM44) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5SkM449transposeEv"]
    pub fn SkM44_transpose(this: *const SkM44) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5SkM444dumpEv"]
    pub fn SkM44_dump(this: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5SkM443mapEffff"]
    pub fn SkM44_map(this: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM4412preTranslateEfff"]
    pub fn SkM44_preTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM4413postTranslateEfff"]
    pub fn SkM44_postTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM448preScaleEff"]
    pub fn SkM44_preScale(this: *mut SkM44, x: SkScalar, y: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkM449preConcatERK8SkMatrix"]
    pub fn SkM44_preConcat(this: *mut SkM44, arg1: *const SkMatrix) -> *mut SkM44;
}
impl SkM44 {
    #[inline]
    pub unsafe fn getRowMajor(&self, v: *mut SkScalar) {
        SkM44_getRowMajor(self, v)
    }
    #[inline]
    pub unsafe fn setRotateUnitSinCos(
        &mut self,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44 {
        SkM44_setRotateUnitSinCos(self, axis, sinAngle, cosAngle)
    }
    #[inline]
    pub unsafe fn setRotate(&mut self, axis: SkV3, radians: SkScalar) -> *mut SkM44 {
        SkM44_setRotate(self, axis, radians)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkM44, b: *const SkM44) -> *mut SkM44 {
        SkM44_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn normalizePerspective(&mut self) {
        SkM44_normalizePerspective(self)
    }
    #[inline]
    pub unsafe fn invert(&self, inverse: *mut SkM44) -> bool {
        SkM44_invert(self, inverse)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> SkM44 {
        SkM44_transpose(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkM44_dump(self)
    }
    #[inline]
    pub unsafe fn map(&self, x: f32, y: f32, z: f32, w: f32) -> SkV4 {
        SkM44_map(self, x, y, z, w)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_preTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_postTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, x: SkScalar, y: SkScalar) -> *mut SkM44 {
        SkM44_preScale(self, x, y)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, arg1: *const SkMatrix) -> *mut SkM44 {
        SkM44_preConcat(self, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}_Z9Sk3LookAtRK4SkV3S1_S1_"]
    pub fn Sk3LookAt(eye: *const SkV3, center: *const SkV3, up: *const SkV3) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}_Z14Sk3Perspectivefff"]
    pub fn Sk3Perspective(near: f32, far: f32, angle: f32) -> SkM44;
}
#[repr(C)]
pub struct SkPaint {
    pub fPathEffect: sk_sp<SkPathEffect>,
    pub fShader: sk_sp<SkShader>,
    pub fMaskFilter: sk_sp<SkMaskFilter>,
    pub fColorFilter: sk_sp<SkColorFilter>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fColor4f: SkColor4f,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub __bindgen_anon_1: SkPaint__bindgen_ty_1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Style {
    Fill = 0,
    Stroke = 1,
    StrokeAndFill = 2,
}
impl SkPaint_Cap {
    pub const Last: SkPaint_Cap = SkPaint_Cap::Square;
}
impl SkPaint_Cap {
    pub const Default: SkPaint_Cap = SkPaint_Cap::Butt;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Cap {
    Butt = 0,
    Round = 1,
    Square = 2,
}
impl SkPaint_Join {
    pub const Last: SkPaint_Join = SkPaint_Join::Bevel;
}
impl SkPaint_Join {
    pub const Default: SkPaint_Join = SkPaint_Join::Miter;
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Join {
    Miter = 0,
    Round = 1,
    Bevel = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkPaint__bindgen_ty_1 {
    pub fBitfields: SkPaint__bindgen_ty_1__bindgen_ty_1,
    pub fBitfieldsUInt: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SkPaint__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fAntiAlias(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fAntiAlias(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDither(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDither(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fCapType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fCapType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoinType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fJoinType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fStyle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fStyle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fFilterQuality(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fFilterQuality(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fBlendMode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_fBlendMode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn fPadding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_fPadding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fAntiAlias: ::std::os::raw::c_uint,
        fDither: ::std::os::raw::c_uint,
        fCapType: ::std::os::raw::c_uint,
        fJoinType: ::std::os::raw::c_uint,
        fStyle: ::std::os::raw::c_uint,
        fFilterQuality: ::std::os::raw::c_uint,
        fBlendMode: ::std::os::raw::c_uint,
        fPadding: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fAntiAlias: u32 = unsafe { ::core::mem::transmute(fAntiAlias) };
            fAntiAlias as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDither: u32 = unsafe { ::core::mem::transmute(fDither) };
            fDither as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fCapType: u32 = unsafe { ::core::mem::transmute(fCapType) };
            fCapType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fJoinType: u32 = unsafe { ::core::mem::transmute(fJoinType) };
            fJoinType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fStyle: u32 = unsafe { ::core::mem::transmute(fStyle) };
            fStyle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let fFilterQuality: u32 = unsafe { ::core::mem::transmute(fFilterQuality) };
            fFilterQuality as u64
        });
        __bindgen_bitfield_unit.set(10usize, 8u8, {
            let fBlendMode: u32 = unsafe { ::core::mem::transmute(fBlendMode) };
            fBlendMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let fPadding: u32 = unsafe { ::core::mem::transmute(fPadding) };
            fPadding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPaint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPaint__bindgen_ty_1>())).fBitfields as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint__bindgen_ty_1),
            "::",
            stringify!(fBitfields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPaint__bindgen_ty_1>())).fBitfieldsUInt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint__bindgen_ty_1),
            "::",
            stringify!(fBitfieldsUInt)
        )
    );
}
pub const SkPaint_kStyleCount: ::std::os::raw::c_int = 3;
pub const SkPaint_kCapCount: ::std::os::raw::c_int = 3;
pub const SkPaint_kJoinCount: ::std::os::raw::c_int = 3;
#[test]
fn bindgen_test_layout_SkPaint() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint>(),
        72usize,
        concat!("Size of: ", stringify!(SkPaint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPaint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fPathEffect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fPathEffect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fShader as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fShader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fMaskFilter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fMaskFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fColorFilter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fColorFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fImageFilter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fImageFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fColor4f as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fColor4f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fWidth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPaint>())).fMiterLimit as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fMiterLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint7getHashEv"]
    pub fn SkPaint_getHash(this: *const SkPaint) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint5resetEv"]
    pub fn SkPaint_reset(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint16setFilterQualityE15SkFilterQuality"]
    pub fn SkPaint_setFilterQuality(this: *mut SkPaint, quality: SkFilterQuality);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint8setStyleENS_5StyleE"]
    pub fn SkPaint_setStyle(this: *mut SkPaint, style: SkPaint_Style);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint9setStrokeEb"]
    pub fn SkPaint_setStroke(this: *mut SkPaint, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint8setColorEj"]
    pub fn SkPaint_setColor(this: *mut SkPaint, color: SkColor);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint8setColorERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_setColor1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint9setAlphafEf"]
    pub fn SkPaint_setAlphaf(this: *mut SkPaint, a: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint7setARGBEjjjj"]
    pub fn SkPaint_setARGB(this: *mut SkPaint, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint14setStrokeWidthEf"]
    pub fn SkPaint_setStrokeWidth(this: *mut SkPaint, width: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint14setStrokeMiterEf"]
    pub fn SkPaint_setStrokeMiter(this: *mut SkPaint, miter: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint12setStrokeCapENS_3CapE"]
    pub fn SkPaint_setStrokeCap(this: *mut SkPaint, cap: SkPaint_Cap);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint13setStrokeJoinENS_4JoinE"]
    pub fn SkPaint_setStrokeJoin(this: *mut SkPaint, join: SkPaint_Join);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint11getFillPathERK6SkPathPS0_PK6SkRectf"]
    pub fn SkPaint_getFillPath(
        this: *const SkPaint,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        resScale: SkScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint9refShaderEv"]
    pub fn SkPaint_refShader(this: *const SkPaint) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint9setShaderE5sk_spI8SkShaderE"]
    pub fn SkPaint_setShader(this: *mut SkPaint, shader: sk_sp<SkShader>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint14refColorFilterEv"]
    pub fn SkPaint_refColorFilter(this: *const SkPaint) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint14setColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkPaint_setColorFilter(this: *mut SkPaint, colorFilter: sk_sp<SkColorFilter>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint13refPathEffectEv"]
    pub fn SkPaint_refPathEffect(this: *const SkPaint) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint13setPathEffectE5sk_spI12SkPathEffectE"]
    pub fn SkPaint_setPathEffect(this: *mut SkPaint, pathEffect: sk_sp<SkPathEffect>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint13refMaskFilterEv"]
    pub fn SkPaint_refMaskFilter(this: *const SkPaint) -> sk_sp<SkMaskFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint13setMaskFilterE5sk_spI12SkMaskFilterE"]
    pub fn SkPaint_setMaskFilter(this: *mut SkPaint, maskFilter: sk_sp<SkMaskFilter>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint14refImageFilterEv"]
    pub fn SkPaint_refImageFilter(this: *const SkPaint) -> sk_sp<SkImageFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaint14setImageFilterE5sk_spI13SkImageFilterE"]
    pub fn SkPaint_setImageFilter(this: *mut SkPaint, imageFilter: sk_sp<SkImageFilter>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint13nothingToDrawEv"]
    pub fn SkPaint_nothingToDraw(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint20canComputeFastBoundsEv"]
    pub fn SkPaint_canComputeFastBounds(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkPaint19doComputeFastBoundsERK6SkRectPS0_NS_5StyleE"]
    pub fn SkPaint_doComputeFastBounds(
        this: *const SkPaint,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaintC1Ev"]
    pub fn SkPaint_SkPaint(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaintC1ERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_SkPaint1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaintC1ERKS_"]
    pub fn SkPaint_SkPaint2(this: *mut SkPaint, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaintC1EOS_"]
    pub fn SkPaint_SkPaint3(this: *mut SkPaint, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkPaintD1Ev"]
    pub fn SkPaint_SkPaint_destructor(this: *mut SkPaint);
}
impl SkPaint {
    #[inline]
    pub unsafe fn getHash(&self) -> u32 {
        SkPaint_getHash(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPaint_reset(self)
    }
    #[inline]
    pub unsafe fn setFilterQuality(&mut self, quality: SkFilterQuality) {
        SkPaint_setFilterQuality(self, quality)
    }
    #[inline]
    pub unsafe fn setStyle(&mut self, style: SkPaint_Style) {
        SkPaint_setStyle(self, style)
    }
    #[inline]
    pub unsafe fn setStroke(&mut self, arg1: bool) {
        SkPaint_setStroke(self, arg1)
    }
    #[inline]
    pub unsafe fn setColor(&mut self, color: SkColor) {
        SkPaint_setColor(self, color)
    }
    #[inline]
    pub unsafe fn setColor1(&mut self, color: *const SkColor4f, colorSpace: *mut SkColorSpace) {
        SkPaint_setColor1(self, color, colorSpace)
    }
    #[inline]
    pub unsafe fn setAlphaf(&mut self, a: f32) {
        SkPaint_setAlphaf(self, a)
    }
    #[inline]
    pub unsafe fn setARGB(&mut self, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) {
        SkPaint_setARGB(self, a, r, g, b)
    }
    #[inline]
    pub unsafe fn setStrokeWidth(&mut self, width: SkScalar) {
        SkPaint_setStrokeWidth(self, width)
    }
    #[inline]
    pub unsafe fn setStrokeMiter(&mut self, miter: SkScalar) {
        SkPaint_setStrokeMiter(self, miter)
    }
    #[inline]
    pub unsafe fn setStrokeCap(&mut self, cap: SkPaint_Cap) {
        SkPaint_setStrokeCap(self, cap)
    }
    #[inline]
    pub unsafe fn setStrokeJoin(&mut self, join: SkPaint_Join) {
        SkPaint_setStrokeJoin(self, join)
    }
    #[inline]
    pub unsafe fn getFillPath(
        &self,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        resScale: SkScalar,
    ) -> bool {
        SkPaint_getFillPath(self, src, dst, cullRect, resScale)
    }
    #[inline]
    pub unsafe fn refShader(&self) -> sk_sp<SkShader> {
        SkPaint_refShader(self)
    }
    #[inline]
    pub unsafe fn setShader(&mut self, shader: sk_sp<SkShader>) {
        SkPaint_setShader(self, shader)
    }
    #[inline]
    pub unsafe fn refColorFilter(&self) -> sk_sp<SkColorFilter> {
        SkPaint_refColorFilter(self)
    }
    #[inline]
    pub unsafe fn setColorFilter(&mut self, colorFilter: sk_sp<SkColorFilter>) {
        SkPaint_setColorFilter(self, colorFilter)
    }
    #[inline]
    pub unsafe fn refPathEffect(&self) -> sk_sp<SkPathEffect> {
        SkPaint_refPathEffect(self)
    }
    #[inline]
    pub unsafe fn setPathEffect(&mut self, pathEffect: sk_sp<SkPathEffect>) {
        SkPaint_setPathEffect(self, pathEffect)
    }
    #[inline]
    pub unsafe fn refMaskFilter(&self) -> sk_sp<SkMaskFilter> {
        SkPaint_refMaskFilter(self)
    }
    #[inline]
    pub unsafe fn setMaskFilter(&mut self, maskFilter: sk_sp<SkMaskFilter>) {
        SkPaint_setMaskFilter(self, maskFilter)
    }
    #[inline]
    pub unsafe fn refImageFilter(&self) -> sk_sp<SkImageFilter> {
        SkPaint_refImageFilter(self)
    }
    #[inline]
    pub unsafe fn setImageFilter(&mut self, imageFilter: sk_sp<SkImageFilter>) {
        SkPaint_setImageFilter(self, imageFilter)
    }
    #[inline]
    pub unsafe fn nothingToDraw(&self) -> bool {
        SkPaint_nothingToDraw(self)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkPaint_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn doComputeFastBounds(
        &self,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect {
        SkPaint_doComputeFastBounds(self, orig, storage, style)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(color: *const SkColor4f, colorSpace: *mut SkColorSpace) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint1(__bindgen_tmp.as_mut_ptr(), color, colorSpace);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(paint: *const SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint2(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(paint: *mut SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint3(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPaint_SkPaint_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator {
    pub _bindgen_opaque_blob: u64,
}
pub type SkRasterHandleAllocator_Handle = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator_Rec {
    pub fReleaseProc: ::core::option::Option<
        unsafe extern "C" fn(pixels: *mut ::core::ffi::c_void, ctx: *mut ::core::ffi::c_void),
    >,
    pub fReleaseCtx: *mut ::core::ffi::c_void,
    pub fPixels: *mut ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fHandle: SkRasterHandleAllocator_Handle,
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator_Rec() {
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator_Rec>(),
        40usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator_Rec))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRasterHandleAllocator_Rec>())).fReleaseProc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fReleaseProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRasterHandleAllocator_Rec>())).fReleaseCtx as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fReleaseCtx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRasterHandleAllocator_Rec>())).fPixels as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fPixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRasterHandleAllocator_Rec>())).fRowBytes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRasterHandleAllocator_Rec>())).fHandle as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fHandle)
        )
    );
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkRasterHandleAllocator10MakeCanvasESt10unique_ptrIS_St14default_deleteIS_EERK11SkImageInfoPKNS_3RecE"]
    pub fn SkRasterHandleAllocator_MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
    ) -> u64;
}
impl SkRasterHandleAllocator {
    #[inline]
    pub unsafe fn MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
    ) -> u64 {
        SkRasterHandleAllocator_MakeCanvas(arg1, arg2, rec)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelGeometry {
    kUnknown_SkPixelGeometry = 0,
    kRGB_H_SkPixelGeometry = 1,
    kBGR_H_SkPixelGeometry = 2,
    kRGB_V_SkPixelGeometry = 3,
    kBGR_V_SkPixelGeometry = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurfaceProps {
    pub fFlags: u32,
    pub fPixelGeometry: SkPixelGeometry,
}
pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag: SkSurfaceProps_Flags = 1;
pub type SkSurfaceProps_Flags = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN14SkSurfaceProps27kUseDistanceFieldFonts_FlagE"]
    pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag: SkSurfaceProps_Flags;
}
#[test]
fn bindgen_test_layout_SkSurfaceProps() {
    assert_eq!(
        ::core::mem::size_of::<SkSurfaceProps>(),
        8usize,
        concat!("Size of: ", stringify!(SkSurfaceProps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurfaceProps>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSurfaceProps))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSurfaceProps>())).fFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSurfaceProps),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkSurfaceProps>())).fPixelGeometry as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSurfaceProps),
            "::",
            stringify!(fPixelGeometry)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkSurfacePropsC1Ev"]
    pub fn SkSurfaceProps_SkSurfaceProps(this: *mut SkSurfaceProps);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkSurfacePropsC1Ej15SkPixelGeometry"]
    pub fn SkSurfaceProps_SkSurfaceProps1(
        this: *mut SkSurfaceProps,
        flags: u32,
        arg1: SkPixelGeometry,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkSurfacePropsC1ERKS_"]
    pub fn SkSurfaceProps_SkSurfaceProps2(this: *mut SkSurfaceProps, arg1: *const SkSurfaceProps);
}
impl SkSurfaceProps {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(flags: u32, arg1: SkPixelGeometry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps1(__bindgen_tmp.as_mut_ptr(), flags, arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Block {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Iter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDeque_Iter_IterStart {
    kFront_IterStart = 0,
    kBack_IterStart = 1,
}
#[test]
fn bindgen_test_layout_SkDeque_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_Iter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_Iter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque4Iter4nextEv"]
    pub fn SkDeque_Iter_next(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque4Iter4prevEv"]
    pub fn SkDeque_Iter_prev(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque4Iter5resetERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_reset(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque4IterC1Ev"]
    pub fn SkDeque_Iter_Iter(this: *mut SkDeque_Iter);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque4IterC1ERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_Iter1(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
impl SkDeque_Iter {
    #[inline]
    pub unsafe fn next(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_next(self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_prev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) {
        SkDeque_Iter_reset(self, d, startLoc)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), d, startLoc);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_F2BIter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter;
#[test]
fn bindgen_test_layout_SkDeque_F2BIter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_F2BIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_F2BIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_F2BIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_F2BIter))
    );
}
#[test]
fn bindgen_test_layout_SkDeque() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque>(),
        56usize,
        concat!("Size of: ", stringify!(SkDeque))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque10push_frontEv"]
    pub fn SkDeque_push_front(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque9push_backEv"]
    pub fn SkDeque_push_back(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque9pop_frontEv"]
    pub fn SkDeque_pop_front(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDeque8pop_backEv"]
    pub fn SkDeque_pop_back(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDequeC1Emi"]
    pub fn SkDeque_SkDeque(this: *mut SkDeque, elemSize: usize, allocCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDequeC1EmPvmi"]
    pub fn SkDeque_SkDeque1(
        this: *mut SkDeque,
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkDequeD1Ev"]
    pub fn SkDeque_SkDeque_destructor(this: *mut SkDeque);
}
impl SkDeque {
    #[inline]
    pub unsafe fn push_front(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_front(self)
    }
    #[inline]
    pub unsafe fn push_back(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_back(self)
    }
    #[inline]
    pub unsafe fn pop_front(&mut self) {
        SkDeque_pop_front(self)
    }
    #[inline]
    pub unsafe fn pop_back(&mut self) {
        SkDeque_pop_back(self)
    }
    #[inline]
    pub unsafe fn new(elemSize: usize, allocCount: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque(__bindgen_tmp.as_mut_ptr(), elemSize, allocCount);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque1(
            __bindgen_tmp.as_mut_ptr(),
            elemSize,
            storage,
            storageSize,
            allocCount,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeque_SkDeque_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrRecordingContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrRenderTargetContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBaseDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawShadowRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGlyphRunBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMarkerStack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface_Base {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SkCanvas__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct SkCanvas {
    pub vtable_: *const SkCanvas__bindgen_vtable,
    pub fMCStack: SkDeque,
    pub fMCRec: *mut SkCanvas_MCRec,
    pub fMarkerStack: sk_sp<SkMarkerStack>,
    pub fMCRecStorage: [isize; 384usize],
    pub fBaseDevice: sk_sp<SkBaseDevice>,
    pub fProps: SkSurfaceProps,
    pub fSaveCount: ::std::os::raw::c_int,
    pub fAllocator: u64,
    pub fSurfaceBase: *mut SkSurface_Base,
    pub fClipRestrictionRect: SkIRect,
    pub fIsScaleTranslate: bool,
    pub fQuickRejectBounds: SkRect,
    pub fScratchGlyphRunBuilder: u64,
}
pub const SkCanvas_SaveLayerFlagsSet_kPreserveLCDText_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet = 2;
pub const SkCanvas_SaveLayerFlagsSet_kInitWithPrevious_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet =
    4;
pub const SkCanvas_SaveLayerFlagsSet_kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag:
    SkCanvas_SaveLayerFlagsSet = 8;
pub const SkCanvas_SaveLayerFlagsSet_kF16ColorType: SkCanvas_SaveLayerFlagsSet = 16;
pub type SkCanvas_SaveLayerFlagsSet = ::std::os::raw::c_uint;
pub type SkCanvas_SaveLayerFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_SaveLayerRec {
    pub fBounds: *const SkRect,
    pub fPaint: *const SkPaint,
    pub fBackdrop: *const SkImageFilter,
    pub fSaveLayerFlags: SkCanvas_SaveLayerFlags,
}
#[test]
fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_SaveLayerRec>(),
        32usize,
        concat!("Size of: ", stringify!(SkCanvas_SaveLayerRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_SaveLayerRec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_SaveLayerRec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_SaveLayerRec>())).fBounds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_SaveLayerRec>())).fPaint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fPaint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_SaveLayerRec>())).fBackdrop as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fBackdrop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_SaveLayerRec>())).fSaveLayerFlags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fSaveLayerFlags)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_PointMode {
    Points = 0,
    Lines = 1,
    Polygon = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SrcRectConstraint {
    Strict = 0,
    Fast = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_Lattice {
    pub fXDivs: *const ::std::os::raw::c_int,
    pub fYDivs: *const ::std::os::raw::c_int,
    pub fRectTypes: *const SkCanvas_Lattice_RectType,
    pub fXCount: ::std::os::raw::c_int,
    pub fYCount: ::std::os::raw::c_int,
    pub fBounds: *const SkIRect,
    pub fColors: *const SkColor,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_Lattice_RectType {
    Default = 0,
    Transparent = 1,
    FixedColor = 2,
}
#[test]
fn bindgen_test_layout_SkCanvas_Lattice() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_Lattice>(),
        48usize,
        concat!("Size of: ", stringify!(SkCanvas_Lattice))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_Lattice>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_Lattice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fXDivs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fXDivs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fYDivs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fYDivs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fRectTypes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fRectTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fXCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fXCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fYCount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fYCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fBounds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_Lattice>())).fColors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fColors)
        )
    );
}
pub const SkCanvas_QuadAAFlags_kLeft_QuadAAFlag: SkCanvas_QuadAAFlags = 1;
pub const SkCanvas_QuadAAFlags_kTop_QuadAAFlag: SkCanvas_QuadAAFlags = 2;
pub const SkCanvas_QuadAAFlags_kRight_QuadAAFlag: SkCanvas_QuadAAFlags = 4;
pub const SkCanvas_QuadAAFlags_kBottom_QuadAAFlag: SkCanvas_QuadAAFlags = 8;
pub const SkCanvas_QuadAAFlags_kNone_QuadAAFlags: SkCanvas_QuadAAFlags = 0;
pub const SkCanvas_QuadAAFlags_kAll_QuadAAFlags: SkCanvas_QuadAAFlags = 15;
pub type SkCanvas_QuadAAFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_ImageSetEntry {
    pub fImage: sk_sp<SkImage>,
    pub fSrcRect: SkRect,
    pub fDstRect: SkRect,
    pub fMatrixIndex: ::std::os::raw::c_int,
    pub fAlpha: f32,
    pub fAAFlags: ::std::os::raw::c_uint,
    pub fHasClip: bool,
}
#[test]
fn bindgen_test_layout_SkCanvas_ImageSetEntry() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_ImageSetEntry>(),
        56usize,
        concat!("Size of: ", stringify!(SkCanvas_ImageSetEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_ImageSetEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_ImageSetEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fImage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fSrcRect as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fSrcRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fDstRect as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fDstRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fMatrixIndex as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fMatrixIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fAlpha as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fAAFlags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fAAFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas_ImageSetEntry>())).fHasClip as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fHasClip)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_ifjb"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::std::os::raw::c_int,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
        hasClip: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_fj"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry1(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13ImageSetEntryC1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry2(this: *mut SkCanvas_ImageSetEntry);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13ImageSetEntryC1ERKS0_"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry3(
        this: *mut SkCanvas_ImageSetEntry,
        arg1: *const SkCanvas_ImageSetEntry,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13ImageSetEntryD1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry_destructor(this: *mut SkCanvas_ImageSetEntry);
}
impl SkCanvas_ImageSetEntry {
    #[inline]
    pub unsafe fn new(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::std::os::raw::c_int,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
        hasClip: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            matrixIndex,
            alpha,
            aaFlags,
            hasClip,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry1(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            alpha,
            aaFlags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const SkCanvas_ImageSetEntry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_ImageSetEntry_ImageSetEntry_destructor(self)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SaveLayerStrategy {
    kFullLayer_SaveLayerStrategy = 0,
    kNoLayer_SaveLayerStrategy = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ClipEdgeStyle {
    kHard_ClipEdgeStyle = 0,
    kSoft_ClipEdgeStyle = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ShaderOverrideOpacity {
    kNone_ShaderOverrideOpacity = 0,
    kOpaque_ShaderOverrideOpacity = 1,
    kNotOpaque_ShaderOverrideOpacity = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_MCRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_AutoValidateClip {
    _unused: [u8; 0],
}
pub type SkCanvas_INHERITED = SkRefCnt;
pub const SkCanvas_kMCRecSize: ::std::os::raw::c_int = 96;
pub const SkCanvas_kMCRecCount: ::std::os::raw::c_int = 32;
#[test]
fn bindgen_test_layout_SkCanvas() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas>(),
        3240usize,
        concat!("Size of: ", stringify!(SkCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fMCStack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fMCRec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCRec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fMarkerStack as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMarkerStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fMCRecStorage as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCRecStorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fBaseDevice as *const _ as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fBaseDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fProps as *const _ as usize },
        3160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fProps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fSaveCount as *const _ as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fSaveCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fAllocator as *const _ as usize },
        3176usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fAllocator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fSurfaceBase as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fSurfaceBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fClipRestrictionRect as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fClipRestrictionRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fIsScaleTranslate as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fIsScaleTranslate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCanvas>())).fQuickRejectBounds as *const _ as usize },
        3212usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fQuickRejectBounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCanvas>())).fScratchGlyphRunBuilder as *const _ as usize
        },
        3232usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fScratchGlyphRunBuilder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps"]
    pub fn SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas9imageInfoEv"]
    pub fn SkCanvas_imageInfo(this: *const SkCanvas) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas8getPropsEP14SkSurfaceProps"]
    pub fn SkCanvas_getProps(this: *const SkCanvas, props: *mut SkSurfaceProps) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas5flushEv"]
    pub fn SkCanvas_flush(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11makeSurfaceERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkCanvas_makeSurface(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas10getSurfaceEv"]
    pub fn SkCanvas_getSurface(this: *const SkCanvas) -> *mut SkSurface;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas20accessTopLayerPixelsEP11SkImageInfoPmP8SkIPoint"]
    pub fn SkCanvas_accessTopLayerPixels(
        this: *mut SkCanvas,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas21accessTopRasterHandleEv"]
    pub fn SkCanvas_accessTopRasterHandle(this: *const SkCanvas) -> SkRasterHandleAllocator_Handle;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10peekPixelsEP8SkPixmap"]
    pub fn SkCanvas_peekPixels(this: *mut SkCanvas, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkCanvas_readPixels(
        this: *mut SkCanvas,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10readPixelsERK8SkPixmapii"]
    pub fn SkCanvas_readPixels1(
        this: *mut SkCanvas,
        pixmap: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10readPixelsERK8SkBitmapii"]
    pub fn SkCanvas_readPixels2(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11writePixelsERK11SkImageInfoPKvmii"]
    pub fn SkCanvas_writePixels(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11writePixelsERK8SkBitmapii"]
    pub fn SkCanvas_writePixels1(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas4saveEv"]
    pub fn SkCanvas_save(this: *mut SkCanvas) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9saveLayerEPK6SkRectPK7SkPaint"]
    pub fn SkCanvas_saveLayer(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14saveLayerAlphaEPK6SkRectj"]
    pub fn SkCanvas_saveLayerAlpha(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        alpha: U8CPU,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9saveLayerERKNS_12SaveLayerRecE"]
    pub fn SkCanvas_saveLayer1(
        this: *mut SkCanvas,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas7restoreEv"]
    pub fn SkCanvas_restore(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas12getSaveCountEv"]
    pub fn SkCanvas_getSaveCount(this: *const SkCanvas) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14restoreToCountEi"]
    pub fn SkCanvas_restoreToCount(this: *mut SkCanvas, saveCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9translateEff"]
    pub fn SkCanvas_translate(this: *mut SkCanvas, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas5scaleEff"]
    pub fn SkCanvas_scale(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas6rotateEf"]
    pub fn SkCanvas_rotate(this: *mut SkCanvas, degrees: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas6rotateEfff"]
    pub fn SkCanvas_rotate1(this: *mut SkCanvas, degrees: SkScalar, px: SkScalar, py: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas4skewEff"]
    pub fn SkCanvas_skew(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas6concatERK8SkMatrix"]
    pub fn SkCanvas_concat(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas6concatERK5SkM44"]
    pub fn SkCanvas_concat1(this: *mut SkCanvas, arg1: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas7markCTMEPKc"]
    pub fn SkCanvas_markCTM(this: *mut SkCanvas, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas13findMarkedCTMEPKcP5SkM44"]
    pub fn SkCanvas_findMarkedCTM(
        this: *const SkCanvas,
        name: *const ::std::os::raw::c_char,
        arg1: *mut SkM44,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9setMatrixERK5SkM44"]
    pub fn SkCanvas_setMatrix(this: *mut SkCanvas, matrix: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9setMatrixERK8SkMatrix"]
    pub fn SkCanvas_setMatrix1(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11resetMatrixEv"]
    pub fn SkCanvas_resetMatrix(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8clipRectERK6SkRect8SkClipOpb"]
    pub fn SkCanvas_clipRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas41androidFramework_setDeviceClipRestrictionERK7SkIRect"]
    pub fn SkCanvas_androidFramework_setDeviceClipRestriction(
        this: *mut SkCanvas,
        rect: *const SkIRect,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9clipRRectERK7SkRRect8SkClipOpb"]
    pub fn SkCanvas_clipRRect(
        this: *mut SkCanvas,
        rrect: *const SkRRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8clipPathERK6SkPath8SkClipOpb"]
    pub fn SkCanvas_clipPath(
        this: *mut SkCanvas,
        path: *const SkPath,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10clipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_clipShader(this: *mut SkCanvas, arg1: sk_sp<SkShader>, arg2: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10clipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_clipRegion(this: *mut SkCanvas, deviceRgn: *const SkRegion, op: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas11quickRejectERK6SkRect"]
    pub fn SkCanvas_quickReject(this: *const SkCanvas, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas11quickRejectERK6SkPath"]
    pub fn SkCanvas_quickReject1(this: *const SkCanvas, path: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas18getLocalClipBoundsEv"]
    pub fn SkCanvas_getLocalClipBounds(this: *const SkCanvas) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas19getDeviceClipBoundsEv"]
    pub fn SkCanvas_getDeviceClipBounds(this: *const SkCanvas) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawColorERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_drawColor(this: *mut SkCanvas, color: *const SkColor4f, mode: SkBlendMode);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawPaintERK7SkPaint"]
    pub fn SkCanvas_drawPaint(this: *mut SkCanvas, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10drawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_drawPoints(
        this: *mut SkCanvas,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawPointEffRK7SkPaint"]
    pub fn SkCanvas_drawPoint(this: *mut SkCanvas, x: SkScalar, y: SkScalar, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8drawLineEffffRK7SkPaint"]
    pub fn SkCanvas_drawLine(
        this: *mut SkCanvas,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8drawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawRect(this: *mut SkCanvas, rect: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10drawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_drawRegion(this: *mut SkCanvas, region: *const SkRegion, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8drawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawOval(this: *mut SkCanvas, oval: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_drawRRect(this: *mut SkCanvas, rrect: *const SkRRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10drawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_drawDRRect(
        this: *mut SkCanvas,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10drawCircleEfffRK7SkPaint"]
    pub fn SkCanvas_drawCircle(
        this: *mut SkCanvas,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas7drawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_drawArc(
        this: *mut SkCanvas,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawRoundRectERK6SkRectffRK7SkPaint"]
    pub fn SkCanvas_drawRoundRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas8drawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_drawPath(this: *mut SkCanvas, path: *const SkPath, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawImageEPK7SkImageffPK7SkPaint"]
    pub fn SkCanvas_drawImage(
        this: *mut SkCanvas,
        image: *const SkImage,
        left: SkScalar,
        top: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectS5_PK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawImageRect(
        this: *mut SkCanvas,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawImageRectEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawImageRect1(
        this: *mut SkCanvas,
        image: *const SkImage,
        isrc: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectPK7SkPaint"]
    pub fn SkCanvas_drawImageRect2(
        this: *mut SkCanvas,
        image: *const SkImage,
        dst: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawImageEPK7SkImageffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImage1(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectS5_RK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImageRect3(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13drawImageNineEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaint"]
    pub fn SkCanvas_drawImageNine(
        this: *mut SkCanvas,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10drawBitmapERK8SkBitmapffPK7SkPaint"]
    pub fn SkCanvas_drawBitmap(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        left: SkScalar,
        top: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK6SkRectS5_PK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawBitmapRect(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK7SkIRectRK6SkRectPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawBitmapRect1(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        isrc: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK6SkRectPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawBitmapRect2(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas16drawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRectPK7SkPaint"]
    pub fn SkCanvas_drawImageLattice(
        this: *mut SkCanvas,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas27experimental_DrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_experimental_DrawEdgeAAQuad(
        this: *mut SkCanvas,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas31experimental_DrawEdgeAAImageSetEPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_experimental_DrawEdgeAAImageSet(
        this: *mut SkCanvas,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14drawSimpleTextEPKvm14SkTextEncodingffRK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawSimpleText(
        this: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12drawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_drawTextBlob(
        this: *mut SkCanvas,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11drawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_drawPicture(
        this: *mut SkCanvas,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12drawVerticesEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices(
        this: *mut SkCanvas,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12drawVerticesERK5sk_spI10SkVerticesE11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices1(
        this: *mut SkCanvas,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawPatch(
        this: *mut SkCanvas,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9drawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeS8_PK7SkPaint"]
    pub fn SkCanvas_drawAtlas(
        this: *mut SkCanvas,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::std::os::raw::c_int,
        mode: SkBlendMode,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12drawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_drawDrawable(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12drawDrawableEP10SkDrawableff"]
    pub fn SkCanvas_drawDrawable1(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        x: SkScalar,
        y: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14drawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_drawAnnotation(
        this: *mut SkCanvas,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas16getLocalToDeviceEv"]
    pub fn SkCanvas_getLocalToDevice(this: *const SkCanvas) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas14getTotalMatrixEv"]
    pub fn SkCanvas_getTotalMatrix(this: *const SkCanvas) -> SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas20legacy_drawImageRectEPK7SkImagePK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_legacy_drawImageRect(
        this: *mut SkCanvas,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas29temporary_internal_getRgnClipEP8SkRegion"]
    pub fn SkCanvas_temporary_internal_getRgnClip(this: *mut SkCanvas, region: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas23private_draw_shadow_recERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_private_draw_shadow_rec(
        this: *mut SkCanvas,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14clipRectBoundsEPK6SkRectP7SkIRectPK13SkImageFilter"]
    pub fn SkCanvas_clipRectBounds(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        intersection: *mut SkIRect,
        imageFilter: *const SkImageFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas12getTopDeviceEv"]
    pub fn SkCanvas_getTopDevice(this: *const SkCanvas) -> *mut SkBaseDevice;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1Ev"]
    pub fn SkCanvas_SkCanvas(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1EiiPK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas1(
        this: *mut SkCanvas,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1E5sk_spI12SkBaseDeviceE"]
    pub fn SkCanvas_SkCanvas2(this: *mut SkCanvas, device: sk_sp<SkBaseDevice>);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1ERK8SkBitmap"]
    pub fn SkCanvas_SkCanvas3(this: *mut SkCanvas, bitmap: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1ERK8SkBitmapRK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas4(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasC1ERK7SkIRect"]
    pub fn SkCanvas_SkCanvas5(this: *mut SkCanvas, bounds: *const SkIRect);
}
impl SkCanvas {
    #[inline]
    pub unsafe fn MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64 {
        SkCanvas_MakeRasterDirect(info, pixels, rowBytes, props)
    }
    #[inline]
    pub unsafe fn imageInfo(&self) -> SkImageInfo {
        SkCanvas_imageInfo(self)
    }
    #[inline]
    pub unsafe fn getProps(&self, props: *mut SkSurfaceProps) -> bool {
        SkCanvas_getProps(self, props)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        SkCanvas_flush(self)
    }
    #[inline]
    pub unsafe fn makeSurface(
        &mut self,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkCanvas_makeSurface(self, info, props)
    }
    #[inline]
    pub unsafe fn getSurface(&self) -> *mut SkSurface {
        SkCanvas_getSurface(self)
    }
    #[inline]
    pub unsafe fn accessTopLayerPixels(
        &mut self,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void {
        SkCanvas_accessTopLayerPixels(self, info, rowBytes, origin)
    }
    #[inline]
    pub unsafe fn accessTopRasterHandle(&self) -> SkRasterHandleAllocator_Handle {
        SkCanvas_accessTopRasterHandle(self)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkCanvas_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        pixmap: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels1(self, pixmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        bitmap: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels2(self, bitmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_writePixels(self, info, pixels, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        bitmap: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_writePixels1(self, bitmap, x, y)
    }
    #[inline]
    pub unsafe fn save(&mut self) -> ::std::os::raw::c_int {
        SkCanvas_save(self)
    }
    #[inline]
    pub unsafe fn saveLayer(
        &mut self,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayer(self, bounds, paint)
    }
    #[inline]
    pub unsafe fn saveLayerAlpha(
        &mut self,
        bounds: *const SkRect,
        alpha: U8CPU,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayerAlpha(self, bounds, alpha)
    }
    #[inline]
    pub unsafe fn saveLayer1(
        &mut self,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayer1(self, layerRec)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        SkCanvas_restore(self)
    }
    #[inline]
    pub unsafe fn getSaveCount(&self) -> ::std::os::raw::c_int {
        SkCanvas_getSaveCount(self)
    }
    #[inline]
    pub unsafe fn restoreToCount(&mut self, saveCount: ::std::os::raw::c_int) {
        SkCanvas_restoreToCount(self, saveCount)
    }
    #[inline]
    pub unsafe fn translate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkCanvas_translate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn scale(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_scale(self, sx, sy)
    }
    #[inline]
    pub unsafe fn rotate(&mut self, degrees: SkScalar) {
        SkCanvas_rotate(self, degrees)
    }
    #[inline]
    pub unsafe fn rotate1(&mut self, degrees: SkScalar, px: SkScalar, py: SkScalar) {
        SkCanvas_rotate1(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn skew(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_skew(self, sx, sy)
    }
    #[inline]
    pub unsafe fn concat(&mut self, matrix: *const SkMatrix) {
        SkCanvas_concat(self, matrix)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, arg1: *const SkM44) {
        SkCanvas_concat1(self, arg1)
    }
    #[inline]
    pub unsafe fn markCTM(&mut self, name: *const ::std::os::raw::c_char) {
        SkCanvas_markCTM(self, name)
    }
    #[inline]
    pub unsafe fn findMarkedCTM(
        &self,
        name: *const ::std::os::raw::c_char,
        arg1: *mut SkM44,
    ) -> bool {
        SkCanvas_findMarkedCTM(self, name, arg1)
    }
    #[inline]
    pub unsafe fn setMatrix(&mut self, matrix: *const SkM44) {
        SkCanvas_setMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn setMatrix1(&mut self, matrix: *const SkMatrix) {
        SkCanvas_setMatrix1(self, matrix)
    }
    #[inline]
    pub unsafe fn resetMatrix(&mut self) {
        SkCanvas_resetMatrix(self)
    }
    #[inline]
    pub unsafe fn clipRect(&mut self, rect: *const SkRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRect(self, rect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn androidFramework_setDeviceClipRestriction(&mut self, rect: *const SkIRect) {
        SkCanvas_androidFramework_setDeviceClipRestriction(self, rect)
    }
    #[inline]
    pub unsafe fn clipRRect(&mut self, rrect: *const SkRRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRRect(self, rrect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipPath(&mut self, path: *const SkPath, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipPath(self, path, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipShader(&mut self, arg1: sk_sp<SkShader>, arg2: SkClipOp) {
        SkCanvas_clipShader(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn clipRegion(&mut self, deviceRgn: *const SkRegion, op: SkClipOp) {
        SkCanvas_clipRegion(self, deviceRgn, op)
    }
    #[inline]
    pub unsafe fn quickReject(&self, rect: *const SkRect) -> bool {
        SkCanvas_quickReject(self, rect)
    }
    #[inline]
    pub unsafe fn quickReject1(&self, path: *const SkPath) -> bool {
        SkCanvas_quickReject1(self, path)
    }
    #[inline]
    pub unsafe fn getLocalClipBounds(&self) -> SkRect {
        SkCanvas_getLocalClipBounds(self)
    }
    #[inline]
    pub unsafe fn getDeviceClipBounds(&self) -> SkIRect {
        SkCanvas_getDeviceClipBounds(self)
    }
    #[inline]
    pub unsafe fn drawColor(&mut self, color: *const SkColor4f, mode: SkBlendMode) {
        SkCanvas_drawColor(self, color, mode)
    }
    #[inline]
    pub unsafe fn drawPaint(&mut self, paint: *const SkPaint) {
        SkCanvas_drawPaint(self, paint)
    }
    #[inline]
    pub unsafe fn drawPoints(
        &mut self,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPoints(self, mode, count, pts, paint)
    }
    #[inline]
    pub unsafe fn drawPoint(&mut self, x: SkScalar, y: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawPoint(self, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawLine(
        &mut self,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawLine(self, x0, y0, x1, y1, paint)
    }
    #[inline]
    pub unsafe fn drawRect(&mut self, rect: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawRect(self, rect, paint)
    }
    #[inline]
    pub unsafe fn drawRegion(&mut self, region: *const SkRegion, paint: *const SkPaint) {
        SkCanvas_drawRegion(self, region, paint)
    }
    #[inline]
    pub unsafe fn drawOval(&mut self, oval: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawOval(self, oval, paint)
    }
    #[inline]
    pub unsafe fn drawRRect(&mut self, rrect: *const SkRRect, paint: *const SkPaint) {
        SkCanvas_drawRRect(self, rrect, paint)
    }
    #[inline]
    pub unsafe fn drawDRRect(
        &mut self,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawDRRect(self, outer, inner, paint)
    }
    #[inline]
    pub unsafe fn drawCircle(
        &mut self,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawCircle(self, cx, cy, radius, paint)
    }
    #[inline]
    pub unsafe fn drawArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawArc(self, oval, startAngle, sweepAngle, useCenter, paint)
    }
    #[inline]
    pub unsafe fn drawRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawRoundRect(self, rect, rx, ry, paint)
    }
    #[inline]
    pub unsafe fn drawPath(&mut self, path: *const SkPath, paint: *const SkPaint) {
        SkCanvas_drawPath(self, path, paint)
    }
    #[inline]
    pub unsafe fn drawImage(
        &mut self,
        image: *const SkImage,
        left: SkScalar,
        top: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImage(self, image, left, top, paint)
    }
    #[inline]
    pub unsafe fn drawImageRect(
        &mut self,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawImageRect(self, image, src, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawImageRect1(
        &mut self,
        image: *const SkImage,
        isrc: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawImageRect1(self, image, isrc, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawImageRect2(
        &mut self,
        image: *const SkImage,
        dst: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageRect2(self, image, dst, paint)
    }
    #[inline]
    pub unsafe fn drawImage1(
        &mut self,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImage1(self, arg1, x, y, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageRect3(
        &mut self,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImageRect3(self, arg1, src, dst, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageNine(
        &mut self,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageNine(self, image, center, dst, paint)
    }
    #[inline]
    pub unsafe fn drawBitmap(
        &mut self,
        bitmap: *const SkBitmap,
        left: SkScalar,
        top: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawBitmap(self, bitmap, left, top, paint)
    }
    #[inline]
    pub unsafe fn drawBitmapRect(
        &mut self,
        bitmap: *const SkBitmap,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawBitmapRect(self, bitmap, src, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawBitmapRect1(
        &mut self,
        bitmap: *const SkBitmap,
        isrc: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawBitmapRect1(self, bitmap, isrc, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawBitmapRect2(
        &mut self,
        bitmap: *const SkBitmap,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawBitmapRect2(self, bitmap, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn drawImageLattice(
        &mut self,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageLattice(self, image, lattice, dst, paint)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAQuad(
        &mut self,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    ) {
        SkCanvas_experimental_DrawEdgeAAQuad(self, rect, clip, aaFlags, color, mode)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAImageSet(
        &mut self,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_experimental_DrawEdgeAAImageSet(
            self,
            imageSet,
            cnt,
            dstClips,
            preViewMatrices,
            paint,
            constraint,
        )
    }
    #[inline]
    pub unsafe fn drawSimpleText(
        &mut self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawSimpleText(self, text, byteLength, encoding, x, y, font, paint)
    }
    #[inline]
    pub unsafe fn drawTextBlob(
        &mut self,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawTextBlob(self, blob, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPicture(
        &mut self,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPicture(self, picture, matrix, paint)
    }
    #[inline]
    pub unsafe fn drawVertices(
        &mut self,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawVertices1(
        &mut self,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices1(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawPatch(
        &mut self,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPatch(self, cubics, colors, texCoords, mode, paint)
    }
    #[inline]
    pub unsafe fn drawAtlas(
        &mut self,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::std::os::raw::c_int,
        mode: SkBlendMode,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawAtlas(
            self, atlas, xform, tex, colors, count, mode, cullRect, paint,
        )
    }
    #[inline]
    pub unsafe fn drawDrawable(&mut self, drawable: *mut SkDrawable, matrix: *const SkMatrix) {
        SkCanvas_drawDrawable(self, drawable, matrix)
    }
    #[inline]
    pub unsafe fn drawDrawable1(&mut self, drawable: *mut SkDrawable, x: SkScalar, y: SkScalar) {
        SkCanvas_drawDrawable1(self, drawable, x, y)
    }
    #[inline]
    pub unsafe fn drawAnnotation(
        &mut self,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    ) {
        SkCanvas_drawAnnotation(self, rect, key, value)
    }
    #[inline]
    pub unsafe fn getLocalToDevice(&self) -> SkM44 {
        SkCanvas_getLocalToDevice(self)
    }
    #[inline]
    pub unsafe fn getTotalMatrix(&self) -> SkMatrix {
        SkCanvas_getTotalMatrix(self)
    }
    #[inline]
    pub unsafe fn legacy_drawImageRect(
        &mut self,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_legacy_drawImageRect(self, image, src, dst, paint, constraint)
    }
    #[inline]
    pub unsafe fn temporary_internal_getRgnClip(&mut self, region: *mut SkRegion) {
        SkCanvas_temporary_internal_getRgnClip(self, region)
    }
    #[inline]
    pub unsafe fn private_draw_shadow_rec(
        &mut self,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    ) {
        SkCanvas_private_draw_shadow_rec(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn clipRectBounds(
        &mut self,
        bounds: *const SkRect,
        intersection: *mut SkIRect,
        imageFilter: *const SkImageFilter,
    ) -> bool {
        SkCanvas_clipRectBounds(self, bounds, intersection, imageFilter)
    }
    #[inline]
    pub unsafe fn getTopDevice(&self) -> *mut SkBaseDevice {
        SkCanvas_getTopDevice(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas1(__bindgen_tmp.as_mut_ptr(), width, height, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(device: sk_sp<SkBaseDevice>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas2(__bindgen_tmp.as_mut_ptr(), device);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(bitmap: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas3(__bindgen_tmp.as_mut_ptr(), bitmap);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(bitmap: *const SkBitmap, props: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas4(__bindgen_tmp.as_mut_ptr(), bitmap, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(bounds: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas5(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvasD1Ev"]
    pub fn SkCanvas_SkCanvas_destructor(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas16getBaseLayerSizeEv"]
    pub fn SkCanvas_getBaseLayerSize(this: *mut ::core::ffi::c_void) -> SkISize;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas16recordingContextEv"]
    pub fn SkCanvas_recordingContext(this: *mut ::core::ffi::c_void) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas11isClipEmptyEv"]
    pub fn SkCanvas_isClipEmpty(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas10isClipRectEv"]
    pub fn SkCanvas_isClipRect(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas50internal_private_accessTopLayerRenderTargetContextEv"]
    pub fn SkCanvas_internal_private_accessTopLayerRenderTargetContext(
        this: *mut ::core::ffi::c_void,
    ) -> *mut GrRenderTargetContext;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onNewSurfaceERK11SkImageInfoRK14SkSurfaceProps"]
    pub fn SkCanvas_onNewSurface(
        this: *mut ::core::ffi::c_void,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onPeekPixelsEP8SkPixmap"]
    pub fn SkCanvas_onPeekPixels(this: *mut ::core::ffi::c_void, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas22onAccessTopLayerPixelsEP8SkPixmap"]
    pub fn SkCanvas_onAccessTopLayerPixels(
        this: *mut ::core::ffi::c_void,
        pixmap: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas11onImageInfoEv"]
    pub fn SkCanvas_onImageInfo(this: *mut ::core::ffi::c_void) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkCanvas10onGetPropsEP14SkSurfaceProps"]
    pub fn SkCanvas_onGetProps(this: *mut ::core::ffi::c_void, props: *mut SkSurfaceProps) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas7onFlushEv"]
    pub fn SkCanvas_onFlush(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onDrawPaintERK7SkPaint"]
    pub fn SkCanvas_onDrawPaint(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onDrawBehindERK7SkPaint"]
    pub fn SkCanvas_onDrawBehind(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10onDrawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onDrawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onDrawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_onDrawDRRect(
        this: *mut ::core::ffi::c_void,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10onDrawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawOval(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9onDrawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_onDrawArc(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10onDrawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_onDrawPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onDrawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_onDrawRegion(
        this: *mut ::core::ffi::c_void,
        region: *const SkRegion,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14onDrawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_onDrawTextBlob(
        this: *mut ::core::ffi::c_void,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onDrawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawPatch(
        this: *mut ::core::ffi::c_void,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onDrawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_onDrawPoints(
        this: *mut ::core::ffi::c_void,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas20onDrawVerticesObjectEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawVerticesObject(
        this: *mut ::core::ffi::c_void,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onDrawImageEPK7SkImageffPK7SkPaint"]
    pub fn SkCanvas_onDrawImage(
        this: *mut ::core::ffi::c_void,
        image: *const SkImage,
        dx: SkScalar,
        dy: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas15onDrawImageRectEPK7SkImagePK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawImageRect(
        this: *mut ::core::ffi::c_void,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas15onDrawImageNineEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaint"]
    pub fn SkCanvas_onDrawImageNine(
        this: *mut ::core::ffi::c_void,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas18onDrawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRectPK7SkPaint"]
    pub fn SkCanvas_onDrawImageLattice(
        this: *mut ::core::ffi::c_void,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onDrawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeS8_PK7SkPaint"]
    pub fn SkCanvas_onDrawAtlas(
        this: *mut ::core::ffi::c_void,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        rect: *const SkRect,
        colors: *const SkColor,
        count: ::std::os::raw::c_int,
        mode: SkBlendMode,
        cull: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas16onDrawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_onDrawAnnotation(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas15onDrawShadowRecERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_onDrawShadowRec(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas14onDrawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_onDrawDrawable(
        this: *mut ::core::ffi::c_void,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas13onDrawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_onDrawPicture(
        this: *mut ::core::ffi::c_void,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas16onDrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_onDrawEdgeAAQuad(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas20onDrawEdgeAAImageSetEPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawEdgeAAImageSet(
        this: *mut ::core::ffi::c_void,
        imageSet: *const SkCanvas_ImageSetEntry,
        count: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10onClipRectERK6SkRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas11onClipRRectERK7SkRRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas10onClipPathERK6SkPath8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onClipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_onClipShader(
        this: *mut ::core::ffi::c_void,
        arg1: sk_sp<SkShader>,
        arg2: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas12onClipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_onClipRegion(
        this: *mut ::core::ffi::c_void,
        deviceRgn: *const SkRegion,
        op: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkCanvas9onDiscardEv"]
    pub fn SkCanvas_onDiscard(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkAutoCanvasRestore {
    pub fCanvas: *mut SkCanvas,
    pub fSaveCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkAutoCanvasRestore() {
    assert_eq!(
        ::core::mem::size_of::<SkAutoCanvasRestore>(),
        16usize,
        concat!("Size of: ", stringify!(SkAutoCanvasRestore))
    );
    assert_eq!(
        ::core::mem::align_of::<SkAutoCanvasRestore>(),
        8usize,
        concat!("Alignment of ", stringify!(SkAutoCanvasRestore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkAutoCanvasRestore>())).fCanvas as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkAutoCanvasRestore),
            "::",
            stringify!(fCanvas)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkAutoCanvasRestore>())).fSaveCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkAutoCanvasRestore),
            "::",
            stringify!(fSaveCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSerialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeserialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFlattenable_Type {
    SkColorFilter = 0,
    SkDrawable = 1,
    SkDrawLooper = 2,
    SkImageFilter = 3,
    SkMaskFilter = 4,
    SkPathEffect = 5,
    SkPixelRef = 6,
    SkUnused_Type4 = 7,
    SkShaderBase = 8,
    SkUnused = 9,
    SkUnused_Type2 = 10,
    SkUnused_Type3 = 11,
}
pub type SkFlattenable_Factory =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut SkReadBuffer) -> sk_sp<SkFlattenable>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable_PrivateInitializer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!("Size of: ", stringify!(SkFlattenable_PrivateInitializer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SkFlattenable_PrivateInitializer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable18PrivateInitializer11InitEffectsEv"]
    pub fn SkFlattenable_PrivateInitializer_InitEffects();
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable18PrivateInitializer16InitImageFiltersEv"]
    pub fn SkFlattenable_PrivateInitializer_InitImageFilters();
}
impl SkFlattenable_PrivateInitializer {
    #[inline]
    pub unsafe fn InitEffects() {
        SkFlattenable_PrivateInitializer_InitEffects()
    }
    #[inline]
    pub unsafe fn InitImageFilters() {
        SkFlattenable_PrivateInitializer_InitImageFilters()
    }
}
pub type SkFlattenable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFlattenable() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable>(),
        16usize,
        concat!("Size of: ", stringify!(SkFlattenable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFlattenable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable13NameToFactoryEPKc"]
    pub fn SkFlattenable_NameToFactory(
        name: *const ::std::os::raw::c_char,
    ) -> SkFlattenable_Factory;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable13FactoryToNameEPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_FactoryToName(
        arg1: SkFlattenable_Factory,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable8RegisterEPKcPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_Register(name: *const ::std::os::raw::c_char, arg1: SkFlattenable_Factory);
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkFlattenable9serializeEPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize(
        this: *const SkFlattenable,
        arg1: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkFlattenable9serializeEPvmPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize1(
        this: *const SkFlattenable,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkFlattenable11DeserializeENS_4TypeEPKvmPK15SkDeserialProcs"]
    pub fn SkFlattenable_Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable>;
}
impl SkFlattenable {
    #[inline]
    pub unsafe fn NameToFactory(name: *const ::std::os::raw::c_char) -> SkFlattenable_Factory {
        SkFlattenable_NameToFactory(name)
    }
    #[inline]
    pub unsafe fn FactoryToName(arg1: SkFlattenable_Factory) -> *const ::std::os::raw::c_char {
        SkFlattenable_FactoryToName(arg1)
    }
    #[inline]
    pub unsafe fn Register(name: *const ::std::os::raw::c_char, arg1: SkFlattenable_Factory) {
        SkFlattenable_Register(name, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *const SkSerialProcs) -> sk_sp<SkData> {
        SkFlattenable_serialize(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize1(
        &self,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize {
        SkFlattenable_serialize1(self, memory, memory_size, arg1)
    }
    #[inline]
    pub unsafe fn Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable> {
        SkFlattenable_Deserialize(arg1, data, length, procs)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkColorFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub const SkColorFilter_Flags_kAlphaUnchanged_Flag: SkColorFilter_Flags = 1;
pub type SkColorFilter_Flags = ::std::os::raw::c_uint;
pub type SkColorFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkColorFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkColorFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter11asColorModeEPjP11SkBlendMode"]
    pub fn SkColorFilter_asColorMode(
        this: *const SkColorFilter,
        color: *mut SkColor,
        mode: *mut SkBlendMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter12asAColorModeEPjP11SkBlendMode"]
    pub fn SkColorFilter_asAColorMode(
        this: *const SkColorFilter,
        color: *mut SkColor,
        mode: *mut SkBlendMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter14asAColorMatrixEPf"]
    pub fn SkColorFilter_asAColorMatrix(this: *const SkColorFilter, matrix: *mut f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter8getFlagsEv"]
    pub fn SkColorFilter_getFlags(this: *const SkColorFilter) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter16isAlphaUnchangedEv"]
    pub fn SkColorFilter_isAlphaUnchanged(this: *const SkColorFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter11filterColorEj"]
    pub fn SkColorFilter_filterColor(this: *const SkColorFilter, arg1: SkColor) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter13filterColor4fERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpaceS6_"]
    pub fn SkColorFilter_filterColor4f(
        this: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkColorFilter12makeComposedE5sk_spIS_E"]
    pub fn SkColorFilter_makeComposed(
        this: *const SkColorFilter,
        inner: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkColorFilter>;
}
impl SkColorFilter {
    #[inline]
    pub unsafe fn asColorMode(&self, color: *mut SkColor, mode: *mut SkBlendMode) -> bool {
        SkColorFilter_asColorMode(self, color, mode)
    }
    #[inline]
    pub unsafe fn asAColorMode(&self, color: *mut SkColor, mode: *mut SkBlendMode) -> bool {
        SkColorFilter_asAColorMode(self, color, mode)
    }
    #[inline]
    pub unsafe fn asAColorMatrix(&self, matrix: *mut f32) -> bool {
        SkColorFilter_asAColorMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn getFlags(&self) -> u32 {
        SkColorFilter_getFlags(self)
    }
    #[inline]
    pub unsafe fn isAlphaUnchanged(&self) -> bool {
        SkColorFilter_isAlphaUnchanged(self)
    }
    #[inline]
    pub unsafe fn filterColor(&self, arg1: SkColor) -> SkColor {
        SkColorFilter_filterColor(self, arg1)
    }
    #[inline]
    pub unsafe fn filterColor4f(
        &self,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f {
        SkColorFilter_filterColor4f(self, srcColor, srcCS, dstCS)
    }
    #[inline]
    pub unsafe fn makeComposed(&self, inner: sk_sp<SkColorFilter>) -> sk_sp<SkColorFilter> {
        SkColorFilter_makeComposed(self, inner)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathFillType {
    Winding = 0,
    EvenOdd = 1,
    InverseWinding = 2,
    InverseEvenOdd = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathDirection {
    CW = 0,
    CCW = 1,
}
pub const SkPathSegmentMask_kLine_SkPathSegmentMask: SkPathSegmentMask = 1;
pub const SkPathSegmentMask_kQuad_SkPathSegmentMask: SkPathSegmentMask = 2;
pub const SkPathSegmentMask_kConic_SkPathSegmentMask: SkPathSegmentMask = 4;
pub const SkPathSegmentMask_kCubic_SkPathSegmentMask: SkPathSegmentMask = 8;
pub type SkPathSegmentMask = ::std::os::raw::c_uint;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathVerb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRRect {
    pub fRect: SkRect,
    pub fRadii: [SkVector; 4usize],
    pub fType: i32,
}
impl SkRRect_Type {
    pub const LastType: SkRRect_Type = SkRRect_Type::Complex;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Type {
    Empty = 0,
    Rect = 1,
    Oval = 2,
    Simple = 3,
    NinePatch = 4,
    Complex = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Corner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerRight = 2,
    LowerLeft = 3,
}
pub const SkRRect_kSizeInMemory: usize = 48;
#[test]
fn bindgen_test_layout_SkRRect() {
    assert_eq!(
        ::core::mem::size_of::<SkRRect>(),
        52usize,
        concat!("Size of: ", stringify!(SkRRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRRect>())).fRect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRRect>())).fRadii as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fRadii)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRRect>())).fType as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkRRect9setRectXYERK6SkRectff"]
    pub fn SkRRect_setRectXY(
        this: *mut SkRRect,
        rect: *const SkRect,
        xRad: SkScalar,
        yRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkRRect12setNinePatchERK6SkRectffff"]
    pub fn SkRRect_setNinePatch(
        this: *mut SkRRect,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkRRect12setRectRadiiERK6SkRectPK7SkPoint"]
    pub fn SkRRect_setRectRadii(this: *mut SkRRect, rect: *const SkRect, radii: *const SkVector);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect5insetEffPS_"]
    pub fn SkRRect_inset(this: *const SkRRect, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect8containsERK6SkRect"]
    pub fn SkRRect_contains(this: *const SkRRect, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect7isValidEv"]
    pub fn SkRRect_isValid(this: *const SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect13writeToMemoryEPv"]
    pub fn SkRRect_writeToMemory(this: *const SkRRect, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkRRect14readFromMemoryEPKvm"]
    pub fn SkRRect_readFromMemory(
        this: *mut SkRRect,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect9transformERK8SkMatrixPS_"]
    pub fn SkRRect_transform(
        this: *const SkRRect,
        matrix: *const SkMatrix,
        dst: *mut SkRRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect4dumpEb"]
    pub fn SkRRect_dump(this: *const SkRRect, asHex: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkRRect12dumpToStringEb"]
    pub fn SkRRect_dumpToString(this: *const SkRRect, asHex: bool) -> SkString;
}
impl SkRRect {
    #[inline]
    pub unsafe fn setRectXY(&mut self, rect: *const SkRect, xRad: SkScalar, yRad: SkScalar) {
        SkRRect_setRectXY(self, rect, xRad, yRad)
    }
    #[inline]
    pub unsafe fn setNinePatch(
        &mut self,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    ) {
        SkRRect_setNinePatch(self, rect, leftRad, topRad, rightRad, bottomRad)
    }
    #[inline]
    pub unsafe fn setRectRadii(&mut self, rect: *const SkRect, radii: *const SkVector) {
        SkRRect_setRectRadii(self, rect, radii)
    }
    #[inline]
    pub unsafe fn inset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect) {
        SkRRect_inset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn contains(&self, rect: *const SkRect) -> bool {
        SkRRect_contains(self, rect)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkRRect_isValid(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRRect_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRRect_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn transform(&self, matrix: *const SkMatrix, dst: *mut SkRRect) -> bool {
        SkRRect_transform(self, matrix, dst)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRRect_dump(self, asHex)
    }
    #[inline]
    pub unsafe fn dumpToString(&self, asHex: bool) -> SkString {
        SkRRect_dumpToString(self, asHex)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMutex {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMutex() {
    assert_eq!(
        ::core::mem::size_of::<SkMutex>(),
        16usize,
        concat!("Size of: ", stringify!(SkMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMutex))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTDArray<T> {
    pub fArray: *mut T,
    pub fReserve: ::std::os::raw::c_int,
    pub fCount: ::std::os::raw::c_int,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkIDChangeListener {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkIDChangeListener_List {
    pub fMutex: SkMutex,
    pub fListeners: SkTDArray<*mut SkIDChangeListener>,
}
#[test]
fn bindgen_test_layout_SkIDChangeListener_List() {
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener_List>(),
        32usize,
        concat!("Size of: ", stringify!(SkIDChangeListener_List))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener_List>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener_List))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkIDChangeListener_List>())).fMutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIDChangeListener_List),
            "::",
            stringify!(fMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkIDChangeListener_List>())).fListeners as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIDChangeListener_List),
            "::",
            stringify!(fListeners)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4List3addE5sk_spIS_Eb"]
    pub fn SkIDChangeListener_List_add(
        this: *mut SkIDChangeListener_List,
        listener: sk_sp<SkIDChangeListener>,
        singleThreaded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4List5countEv"]
    pub fn SkIDChangeListener_List_count(
        this: *mut SkIDChangeListener_List,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4List7changedEb"]
    pub fn SkIDChangeListener_List_changed(
        this: *mut SkIDChangeListener_List,
        singleThreaded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4List5resetEb"]
    pub fn SkIDChangeListener_List_reset(this: *mut SkIDChangeListener_List, singleThreaded: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4ListC1Ev"]
    pub fn SkIDChangeListener_List_List(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListener4ListD1Ev"]
    pub fn SkIDChangeListener_List_List_destructor(this: *mut SkIDChangeListener_List);
}
impl SkIDChangeListener_List {
    #[inline]
    pub unsafe fn add(&mut self, listener: sk_sp<SkIDChangeListener>, singleThreaded: bool) {
        SkIDChangeListener_List_add(self, listener, singleThreaded)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_int {
        SkIDChangeListener_List_count(self)
    }
    #[inline]
    pub unsafe fn changed(&mut self, singleThreaded: bool) {
        SkIDChangeListener_List_changed(self, singleThreaded)
    }
    #[inline]
    pub unsafe fn reset(&mut self, singleThreaded: bool) {
        SkIDChangeListener_List_reset(self, singleThreaded)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_List_List(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkIDChangeListener_List_List_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_SkIDChangeListener() {
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener>(),
        16usize,
        concat!("Size of: ", stringify!(SkIDChangeListener))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListenerC2Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener(this: *mut SkIDChangeListener);
}
impl SkIDChangeListener {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_SkIDChangeListener(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkIDChangeListenerD1Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener_destructor(this: *mut SkIDChangeListener);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkWBuffer {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathConvexity {
    kConvex = 0,
    kConcave = 1,
    kUnknown = 2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPathRef {
    pub _bindgen_opaque_blob: [u64; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathRef_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathRef_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkPathRef_Iter>(),
        32usize,
        concat!("Size of: ", stringify!(SkPathRef_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathRef_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathRef_Iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathRef_Iter>())).fPts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathRef_Iter>())).fVerbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathRef_Iter>())).fVerbStop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fVerbStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathRef_Iter>())).fConicWeights as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fConicWeights)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef4Iter10setPathRefERKS_"]
    pub fn SkPathRef_Iter_setPathRef(this: *mut SkPathRef_Iter, arg1: *const SkPathRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef4Iter4nextEP7SkPoint"]
    pub fn SkPathRef_Iter_next(this: *mut SkPathRef_Iter, pts: *mut SkPoint) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef4Iter4peekEv"]
    pub fn SkPathRef_Iter_peek(this: *const SkPathRef_Iter) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef4IterC1Ev"]
    pub fn SkPathRef_Iter_Iter(this: *mut SkPathRef_Iter);
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef4IterC1ERKS_"]
    pub fn SkPathRef_Iter_Iter1(this: *mut SkPathRef_Iter, arg1: *const SkPathRef);
}
impl SkPathRef_Iter {
    #[inline]
    pub unsafe fn setPathRef(&mut self, arg1: *const SkPathRef) {
        SkPathRef_Iter_setPathRef(self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> u8 {
        SkPathRef_Iter_next(self, pts)
    }
    #[inline]
    pub unsafe fn peek(&self) -> u8 {
        SkPathRef_Iter_peek(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathRef_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkPathRef) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathRef_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef_SerializationOffsets {
    kLegacyRRectOrOvalStartIdx_SerializationShift = 28,
    kLegacyRRectOrOvalIsCCW_SerializationShift = 27,
    kLegacyIsRRect_SerializationShift = 26,
    kIsFinite_SerializationShift = 25,
    kLegacyIsOval_SerializationShift = 24,
    kSegmentMask_SerializationShift = 0,
}
pub const SkPathRef_kMinSize: SkPathRef__bindgen_ty_1 = SkPathRef__bindgen_ty_1::kMinSize;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef__bindgen_ty_1 {
    kMinSize = 256,
}
pub const SkPathRef_kEmptyGenID: SkPathRef__bindgen_ty_2 = SkPathRef__bindgen_ty_2::kEmptyGenID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef__bindgen_ty_2 {
    kEmptyGenID = 1,
}
#[test]
fn bindgen_test_layout_SkPathRef() {
    assert_eq!(
        ::core::mem::size_of::<SkPathRef>(),
        120usize,
        concat!("Size of: ", stringify!(SkPathRef))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathRef>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathRef))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef11CreateEmptyEv"]
    pub fn SkPathRef_CreateEmpty() -> *mut SkPathRef;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef8getRRectEv"]
    pub fn SkPathRef_getRRect(this: *const SkPathRef) -> SkRRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef21CreateTransformedCopyEP5sk_spIS_ERKS_RK8SkMatrix"]
    pub fn SkPathRef_CreateTransformedCopy(
        dst: *mut sk_sp<SkPathRef>,
        src: *const SkPathRef,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef6RewindEP5sk_spIS_E"]
    pub fn SkPathRef_Rewind(pathRef: *mut sk_sp<SkPathRef>);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef20approximateBytesUsedEv"]
    pub fn SkPathRef_approximateBytesUsed(this: *const SkPathRef) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef13writeToBufferEP9SkWBuffer"]
    pub fn SkPathRef_writeToBuffer(this: *const SkPathRef, buffer: *mut SkWBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef9writeSizeEv"]
    pub fn SkPathRef_writeSize(this: *const SkPathRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef11interpolateERKS_fPS_"]
    pub fn SkPathRef_interpolate(
        this: *const SkPathRef,
        ending: *const SkPathRef,
        weight: SkScalar,
        out: *mut SkPathRef,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef5genIDEv"]
    pub fn SkPathRef_genID(this: *const SkPathRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef22addGenIDChangeListenerE5sk_spI18SkIDChangeListenerE"]
    pub fn SkPathRef_addGenIDChangeListener(this: *mut SkPathRef, arg1: sk_sp<SkIDChangeListener>);
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRef24genIDChangeListenerCountEv"]
    pub fn SkPathRef_genIDChangeListenerCount(this: *mut SkPathRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPathRef7isValidEv"]
    pub fn SkPathRef_isValid(this: *const SkPathRef) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPathRefD1Ev"]
    pub fn SkPathRef_SkPathRef_destructor(this: *mut SkPathRef);
}
impl SkPathRef {
    #[inline]
    pub unsafe fn CreateEmpty() -> *mut SkPathRef {
        SkPathRef_CreateEmpty()
    }
    #[inline]
    pub unsafe fn getRRect(&self) -> SkRRect {
        SkPathRef_getRRect(self)
    }
    #[inline]
    pub unsafe fn CreateTransformedCopy(
        dst: *mut sk_sp<SkPathRef>,
        src: *const SkPathRef,
        matrix: *const SkMatrix,
    ) {
        SkPathRef_CreateTransformedCopy(dst, src, matrix)
    }
    #[inline]
    pub unsafe fn Rewind(pathRef: *mut sk_sp<SkPathRef>) {
        SkPathRef_Rewind(pathRef)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&self) -> usize {
        SkPathRef_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn writeToBuffer(&self, buffer: *mut SkWBuffer) {
        SkPathRef_writeToBuffer(self, buffer)
    }
    #[inline]
    pub unsafe fn writeSize(&self) -> u32 {
        SkPathRef_writeSize(self)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        ending: *const SkPathRef,
        weight: SkScalar,
        out: *mut SkPathRef,
    ) {
        SkPathRef_interpolate(self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn genID(&self) -> u32 {
        SkPathRef_genID(self)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self, arg1: sk_sp<SkIDChangeListener>) {
        SkPathRef_addGenIDChangeListener(self, arg1)
    }
    #[inline]
    pub unsafe fn genIDChangeListenerCount(&mut self) -> ::std::os::raw::c_int {
        SkPathRef_genIDChangeListenerCount(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkPathRef_isValid(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathRef_SkPathRef_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPath {
    pub fPathRef: sk_sp<SkPathRef>,
    pub fLastMoveToIndex: ::std::os::raw::c_int,
    pub fConvexity: u8,
    pub fFirstDirection: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_AddPathMode {
    Append = 0,
    Extend = 1,
}
pub const SkPath_SegmentMask_kLine_SegmentMask: SkPath_SegmentMask = 1;
pub const SkPath_SegmentMask_kQuad_SegmentMask: SkPath_SegmentMask = 2;
pub const SkPath_SegmentMask_kConic_SegmentMask: SkPath_SegmentMask = 4;
pub const SkPath_SegmentMask_kCubic_SegmentMask: SkPath_SegmentMask = 8;
pub type SkPath_SegmentMask = ::std::os::raw::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_Verb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
    Done = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
    pub fMoveTo: SkPoint,
    pub fLastPt: SkPoint,
    pub fForceClose: bool,
    pub fNeedClose: bool,
    pub fCloseLine: bool,
    pub fSegmentState: SkPath_Iter_SegmentState,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_Iter_SegmentState {
    kEmptyContour_SegmentState = 0,
    kAfterMove_SegmentState = 1,
    kAfterPrimitive_SegmentState = 2,
}
#[test]
fn bindgen_test_layout_SkPath_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_Iter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_Iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fPts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fVerbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fVerbStop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fVerbStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fConicWeights as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fConicWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fMoveTo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fMoveTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fLastPt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fLastPt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fForceClose as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fForceClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fNeedClose as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fNeedClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fCloseLine as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fCloseLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_Iter>())).fSegmentState as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fSegmentState)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4Iter7setPathERKS_b"]
    pub fn SkPath_Iter_setPath(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4Iter4nextEP7SkPoint"]
    pub fn SkPath_Iter_next(this: *mut SkPath_Iter, pts: *mut SkPoint) -> SkPath_Verb;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath4Iter15isClosedContourEv"]
    pub fn SkPath_Iter_isClosedContour(this: *const SkPath_Iter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4IterC1Ev"]
    pub fn SkPath_Iter_Iter(this: *mut SkPath_Iter);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4IterC1ERKS_b"]
    pub fn SkPath_Iter_Iter1(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
impl SkPath_Iter {
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, forceClose: bool) {
        SkPath_Iter_setPath(self, path, forceClose)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> SkPath_Verb {
        SkPath_Iter_next(self, pts)
    }
    #[inline]
    pub unsafe fn isClosedContour(&self) -> bool {
        SkPath_Iter_isClosedContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClose: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), path, forceClose);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RangeIter {
    pub fVerb: *const u8,
    pub fPoints: *const SkPoint,
    pub fWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RangeIter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_RangeIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkPath_RangeIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RangeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RangeIter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RangeIter>())).fVerb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fVerb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RangeIter>())).fPoints as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fPoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RangeIter>())).fWeights as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fWeights)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RawIter {
    pub fIter: SkPath_RangeIter,
    pub fEnd: SkPath_RangeIter,
    pub fConicWeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RawIter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_RawIter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_RawIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RawIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RawIter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RawIter>())).fIter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RawIter>())).fEnd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath_RawIter>())).fConicWeight as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fConicWeight)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7RawIter7setPathERKS_"]
    pub fn SkPath_RawIter_setPath(this: *mut SkPath_RawIter, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7RawIter4nextEP7SkPoint"]
    pub fn SkPath_RawIter_next(this: *mut SkPath_RawIter, arg1: *mut SkPoint) -> SkPath_Verb;
}
impl SkPath_RawIter {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath) {
        SkPath_RawIter_setPath(self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkPoint) -> SkPath_Verb {
        SkPath_RawIter_next(self, arg1)
    }
}
#[test]
fn bindgen_test_layout_SkPath() {
    assert_eq!(
        ::core::mem::size_of::<SkPath>(),
        16usize,
        concat!("Size of: ", stringify!(SkPath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath>())).fPathRef as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fPathRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath>())).fLastMoveToIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fLastMoveToIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath>())).fConvexity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fConvexity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPath>())).fFirstDirection as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fFirstDirection)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4MakeEPK7SkPointiPKhiPKfi14SkPathFillTypeb"]
    pub fn SkPath_Make(
        arg1: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        arg2: *const u8,
        verbCount: ::std::os::raw::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::std::os::raw::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4RectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4OvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4OvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6CircleEfff15SkPathDirection"]
    pub fn SkPath_Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5RRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5RRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5RRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7PolygonEPK7SkPointib14SkPathFillTypeb"]
    pub fn SkPath_Polygon(
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath16isInterpolatableERKS_"]
    pub fn SkPath_isInterpolatable(this: *const SkPath, compare: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath11interpolateERKS_fPS_"]
    pub fn SkPath_interpolate(
        this: *const SkPath,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath6isOvalEP6SkRect"]
    pub fn SkPath_isOval(this: *const SkPath, bounds: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath7isRRectEP7SkRRect"]
    pub fn SkPath_isRRect(this: *const SkPath, rrect: *mut SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5resetEv"]
    pub fn SkPath_reset(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6rewindEv"]
    pub fn SkPath_rewind(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath19isLastContourClosedEv"]
    pub fn SkPath_isLastContourClosed(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath16IsLineDegenerateERK7SkPointS2_b"]
    pub fn SkPath_IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath16IsQuadDegenerateERK7SkPointS2_S2_b"]
    pub fn SkPath_IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath17IsCubicDegenerateERK7SkPointS2_S2_S2_b"]
    pub fn SkPath_IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath6isLineEP7SkPoint"]
    pub fn SkPath_isLine(this: *const SkPath, line: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath11countPointsEv"]
    pub fn SkPath_countPoints(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath8getPointEi"]
    pub fn SkPath_getPoint(this: *const SkPath, index: ::std::os::raw::c_int) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath9getPointsEP7SkPointi"]
    pub fn SkPath_getPoints(
        this: *const SkPath,
        points: *mut SkPoint,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath10countVerbsEv"]
    pub fn SkPath_countVerbs(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath8getVerbsEPhi"]
    pub fn SkPath_getVerbs(
        this: *const SkPath,
        verbs: *mut u8,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath20approximateBytesUsedEv"]
    pub fn SkPath_approximateBytesUsed(this: *const SkPath) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath4swapERS_"]
    pub fn SkPath_swap(this: *mut SkPath, other: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath18computeTightBoundsEv"]
    pub fn SkPath_computeTightBounds(this: *const SkPath) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath26conservativelyContainsRectERK6SkRect"]
    pub fn SkPath_conservativelyContainsRect(this: *const SkPath, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath10incReserveEi"]
    pub fn SkPath_incReserve(this: *mut SkPath, extraPtCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6moveToEff"]
    pub fn SkPath_moveTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7rMoveToEff"]
    pub fn SkPath_rMoveTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6lineToEff"]
    pub fn SkPath_lineTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7rLineToEff"]
    pub fn SkPath_rLineTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6quadToEffff"]
    pub fn SkPath_quadTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7rQuadToEffff"]
    pub fn SkPath_rQuadTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7conicToEfffff"]
    pub fn SkPath_conicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath8rConicToEfffff"]
    pub fn SkPath_rConicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7cubicToEffffff"]
    pub fn SkPath_cubicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath8rCubicToEffffff"]
    pub fn SkPath_rCubicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5arcToERK6SkRectffb"]
    pub fn SkPath_arcTo(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5arcToEfffff"]
    pub fn SkPath_arcTo1(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5arcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_arcTo2(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6rArcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_rArcTo(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath5closeEv"]
    pub fn SkPath_close(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath19ConvertConicToQuadsERK7SkPointS2_S2_fPS0_i"]
    pub fn SkPath_ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath6isRectEP6SkRectPbP15SkPathDirection"]
    pub fn SkPath_isRect(
        this: *const SkPath,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addRect(
        this: *mut SkPath,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addOvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_addOval(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addOval1(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath9addCircleEfff15SkPathDirection"]
    pub fn SkPath_addCircle(
        this: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath6addArcERK6SkRectff"]
    pub fn SkPath_addArc(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath12addRoundRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_addRoundRect(
        this: *mut SkPath,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath12addRoundRectERK6SkRectPKf15SkPathDirection"]
    pub fn SkPath_addRoundRect1(
        this: *mut SkPath,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath8addRRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_addRRect(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_addRRect1(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addPolyEPK7SkPointib"]
    pub fn SkPath_addPoly(
        this: *mut SkPath,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        close: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addPathERKS_ffNS_11AddPathModeE"]
    pub fn SkPath_addPath(
        this: *mut SkPath,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath7addPathERKS_RK8SkMatrixNS_11AddPathModeE"]
    pub fn SkPath_addPath1(
        this: *mut SkPath,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath14reverseAddPathERKS_"]
    pub fn SkPath_reverseAddPath(this: *mut SkPath, src: *const SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath6offsetEffPS_"]
    pub fn SkPath_offset(this: *const SkPath, dx: SkScalar, dy: SkScalar, dst: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath9transformERK8SkMatrixPS_22SkApplyPerspectiveClip"]
    pub fn SkPath_transform(
        this: *const SkPath,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath9getLastPtEP7SkPoint"]
    pub fn SkPath_getLastPt(this: *const SkPath, lastPt: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath9setLastPtEff"]
    pub fn SkPath_setLastPt(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath8containsEff"]
    pub fn SkPath_contains(this: *const SkPath, x: SkScalar, y: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath4dumpEP9SkWStreamb"]
    pub fn SkPath_dump(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath10dumpArraysEP9SkWStreamb"]
    pub fn SkPath_dumpArrays(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath13writeToMemoryEPv"]
    pub fn SkPath_writeToMemory(this: *const SkPath, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath9serializeEv"]
    pub fn SkPath_serialize(this: *const SkPath) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPath14readFromMemoryEPKvm"]
    pub fn SkPath_readFromMemory(
        this: *mut SkPath,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkPath15getGenerationIDEv"]
    pub fn SkPath_getGenerationID(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPathC1Ev"]
    pub fn SkPath_SkPath(this: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPathC1ERKS_"]
    pub fn SkPath_SkPath1(this: *mut SkPath, path: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkPathD1Ev"]
    pub fn SkPath_SkPath_destructor(this: *mut SkPath);
}
impl SkPath {
    #[inline]
    pub fn fFillType(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fFillType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsVolatile(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fIsVolatile(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fFillType: u8,
        fIsVolatile: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let fFillType: u8 = unsafe { ::core::mem::transmute(fFillType) };
            fFillType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fIsVolatile: u8 = unsafe { ::core::mem::transmute(fIsVolatile) };
            fIsVolatile as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn Make(
        arg1: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        arg2: *const u8,
        verbCount: ::std::os::raw::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::std::os::raw::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Make(
            arg1,
            pointCount,
            arg2,
            verbCount,
            arg3,
            conicWeightCount,
            arg4,
            isVolatile,
        )
    }
    #[inline]
    pub unsafe fn Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_Rect(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath {
        SkPath_Oval(arg1, arg2)
    }
    #[inline]
    pub unsafe fn Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_Oval1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_Circle(center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath {
        SkPath_RRect(arg1, dir)
    }
    #[inline]
    pub unsafe fn RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_RRect1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_RRect2(bounds, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn Polygon(
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Polygon(pts, count, isClosed, arg1, isVolatile)
    }
    #[inline]
    pub unsafe fn isInterpolatable(&self, compare: *const SkPath) -> bool {
        SkPath_isInterpolatable(self, compare)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool {
        SkPath_interpolate(self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn isOval(&self, bounds: *mut SkRect) -> bool {
        SkPath_isOval(self, bounds)
    }
    #[inline]
    pub unsafe fn isRRect(&self, rrect: *mut SkRRect) -> bool {
        SkPath_isRRect(self, rrect)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPath {
        SkPath_reset(self)
    }
    #[inline]
    pub unsafe fn rewind(&mut self) -> *mut SkPath {
        SkPath_rewind(self)
    }
    #[inline]
    pub unsafe fn isLastContourClosed(&self) -> bool {
        SkPath_isLastContourClosed(self)
    }
    #[inline]
    pub unsafe fn IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool {
        SkPath_IsLineDegenerate(p1, p2, exact)
    }
    #[inline]
    pub unsafe fn IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsQuadDegenerate(p1, p2, p3, exact)
    }
    #[inline]
    pub unsafe fn IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsCubicDegenerate(p1, p2, p3, p4, exact)
    }
    #[inline]
    pub unsafe fn isLine(&self, line: *mut SkPoint) -> bool {
        SkPath_isLine(self, line)
    }
    #[inline]
    pub unsafe fn countPoints(&self) -> ::std::os::raw::c_int {
        SkPath_countPoints(self)
    }
    #[inline]
    pub unsafe fn getPoint(&self, index: ::std::os::raw::c_int) -> SkPoint {
        SkPath_getPoint(self, index)
    }
    #[inline]
    pub unsafe fn getPoints(
        &self,
        points: *mut SkPoint,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_getPoints(self, points, max)
    }
    #[inline]
    pub unsafe fn countVerbs(&self) -> ::std::os::raw::c_int {
        SkPath_countVerbs(self)
    }
    #[inline]
    pub unsafe fn getVerbs(
        &self,
        verbs: *mut u8,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_getVerbs(self, verbs, max)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&self) -> usize {
        SkPath_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkPath) {
        SkPath_swap(self, other)
    }
    #[inline]
    pub unsafe fn computeTightBounds(&self) -> SkRect {
        SkPath_computeTightBounds(self)
    }
    #[inline]
    pub unsafe fn conservativelyContainsRect(&self, rect: *const SkRect) -> bool {
        SkPath_conservativelyContainsRect(self, rect)
    }
    #[inline]
    pub unsafe fn incReserve(&mut self, extraPtCount: ::std::os::raw::c_int) {
        SkPath_incReserve(self, extraPtCount)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_moveTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rMoveTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rMoveTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_lineTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rLineTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn quadTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath {
        SkPath_quadTo(self, x1, y1, x2, y2)
    }
    #[inline]
    pub unsafe fn rQuadTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath {
        SkPath_rQuadTo(self, dx1, dy1, dx2, dy2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_conicTo(self, x1, y1, x2, y2, w)
    }
    #[inline]
    pub unsafe fn rConicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_rConicTo(self, dx1, dy1, dx2, dy2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath {
        SkPath_cubicTo(self, x1, y1, x2, y2, x3, y3)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath {
        SkPath_rCubicTo(self, dx1, dy1, dx2, dy2, dx3, dy3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath {
        SkPath_arcTo(self, oval, startAngle, sweepAngle, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo1(self, x1, y1, x2, y2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo2(self, rx, ry, xAxisRotate, largeArc, sweep, x, y)
    }
    #[inline]
    pub unsafe fn rArcTo(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath {
        SkPath_rArcTo(self, rx, ry, xAxisRotate, largeArc, sweep, dx, dy)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPath {
        SkPath_close(self)
    }
    #[inline]
    pub unsafe fn ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_ConvertConicToQuads(p0, p1, p2, w, pts, pow2)
    }
    #[inline]
    pub unsafe fn isRect(
        &self,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool {
        SkPath_isRect(self, rect, isClosed, direction)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addRect(self, rect, dir, start)
    }
    #[inline]
    pub unsafe fn addOval(&mut self, oval: *const SkRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addOval(self, oval, dir)
    }
    #[inline]
    pub unsafe fn addOval1(
        &mut self,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addOval1(self, oval, dir, start)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addCircle(self, x, y, radius, dir)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath {
        SkPath_addArc(self, oval, startAngle, sweepAngle)
    }
    #[inline]
    pub unsafe fn addRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect(self, rect, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn addRoundRect1(
        &mut self,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect1(self, rect, radii, dir)
    }
    #[inline]
    pub unsafe fn addRRect(&mut self, rrect: *const SkRRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addRRect(self, rrect, dir)
    }
    #[inline]
    pub unsafe fn addRRect1(
        &mut self,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addRRect1(self, rrect, dir, start)
    }
    #[inline]
    pub unsafe fn addPoly(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        close: bool,
    ) -> *mut SkPath {
        SkPath_addPoly(self, pts, count, close)
    }
    #[inline]
    pub unsafe fn addPath(
        &mut self,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath(self, src, dx, dy, mode)
    }
    #[inline]
    pub unsafe fn addPath1(
        &mut self,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath1(self, src, matrix, mode)
    }
    #[inline]
    pub unsafe fn reverseAddPath(&mut self, src: *const SkPath) -> *mut SkPath {
        SkPath_reverseAddPath(self, src)
    }
    #[inline]
    pub unsafe fn offset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkPath) {
        SkPath_offset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn transform(
        &self,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    ) {
        SkPath_transform(self, matrix, dst, pc)
    }
    #[inline]
    pub unsafe fn getLastPt(&self, lastPt: *mut SkPoint) -> bool {
        SkPath_getLastPt(self, lastPt)
    }
    #[inline]
    pub unsafe fn setLastPt(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_setLastPt(self, x, y)
    }
    #[inline]
    pub unsafe fn contains(&self, x: SkScalar, y: SkScalar) -> bool {
        SkPath_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn dump(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dump(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn dumpArrays(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dumpArrays(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkPath_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkPath_serialize(self)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkPath_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPath_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath1(__bindgen_tmp.as_mut_ptr(), path);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPath_SkPath_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
pub const SkContourMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkContourMeasure_MatrixFlags = 1;
pub const SkContourMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkContourMeasure_MatrixFlags = 2;
pub const SkContourMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkContourMeasure_MatrixFlags = 3;
pub type SkContourMeasure_MatrixFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure_Segment {
    pub fDistance: SkScalar,
    pub fPtIndex: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_SkContourMeasure_Segment() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure_Segment>(),
        12usize,
        concat!("Size of: ", stringify!(SkContourMeasure_Segment))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure_Segment>(),
        4usize,
        concat!("Alignment of ", stringify!(SkContourMeasure_Segment))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkContourMeasure_Segment>())).fDistance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasure_Segment),
            "::",
            stringify!(fDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkContourMeasure_Segment>())).fPtIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasure_Segment),
            "::",
            stringify!(fPtIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkContourMeasure7Segment10getScalarTEv"]
    pub fn SkContourMeasure_Segment_getScalarT(this: *const SkContourMeasure_Segment) -> SkScalar;
}
impl SkContourMeasure_Segment {
    #[inline]
    pub fn fTValue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_fTValue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn fType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fTValue: ::std::os::raw::c_uint,
        fType: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let fTValue: u32 = unsafe { ::core::mem::transmute(fTValue) };
            fTValue as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let fType: u32 = unsafe { ::core::mem::transmute(fType) };
            fType as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getScalarT(&self) -> SkScalar {
        SkContourMeasure_Segment_getScalarT(self)
    }
}
#[test]
fn bindgen_test_layout_SkContourMeasure() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure>(),
        56usize,
        concat!("Size of: ", stringify!(SkContourMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasure))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkContourMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkContourMeasure_getPosTan(
        this: *const SkContourMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkContourMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkContourMeasure_getMatrix(
        this: *const SkContourMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkContourMeasure10getSegmentEffP6SkPathb"]
    pub fn SkContourMeasure_getSegment(
        this: *const SkContourMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
impl SkContourMeasure {
    #[inline]
    pub unsafe fn getPosTan(
        &self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkContourMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool {
        SkContourMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkContourMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkContourMeasureIter {
    pub fImpl: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasureIter_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_SkContourMeasureIter() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Size of: ", stringify!(SkContourMeasureIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasureIter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkContourMeasureIter>())).fImpl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasureIter),
            "::",
            stringify!(fImpl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20SkContourMeasureIter5resetERK6SkPathbf"]
    pub fn SkContourMeasureIter_reset(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20SkContourMeasureIter4nextEv"]
    pub fn SkContourMeasureIter_next(this: *mut SkContourMeasureIter) -> sk_sp<SkContourMeasure>;
}
extern "C" {
    #[link_name = "\u{1}_ZN20SkContourMeasureIterC1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter(this: *mut SkContourMeasureIter);
}
extern "C" {
    #[link_name = "\u{1}_ZN20SkContourMeasureIterC1ERK6SkPathbf"]
    pub fn SkContourMeasureIter_SkContourMeasureIter1(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20SkContourMeasureIterD1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter_destructor(this: *mut SkContourMeasureIter);
}
impl SkContourMeasureIter {
    #[inline]
    pub unsafe fn reset(&mut self, path: *const SkPath, forceClosed: bool, resScale: SkScalar) {
        SkContourMeasureIter_reset(self, path, forceClosed, resScale)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> sk_sp<SkContourMeasure> {
        SkContourMeasureIter_next(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter1(
            __bindgen_tmp.as_mut_ptr(),
            path,
            forceClosed,
            resScale,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkContourMeasureIter_SkContourMeasureIter_destructor(self)
    }
}
impl SkCoverageMode {
    pub const Last: SkCoverageMode = SkCoverageMode::Xor;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCoverageMode {
    Union = 0,
    Intersect = 1,
    Difference = 2,
    ReverseDifference = 3,
    Xor = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicMap {
    pub fCoeff: [SkPoint; 3usize],
    pub fType: SkCubicMap_Type,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCubicMap_Type {
    Line = 0,
    CubeRoot = 1,
    Solver = 2,
}
#[test]
fn bindgen_test_layout_SkCubicMap() {
    assert_eq!(
        ::core::mem::size_of::<SkCubicMap>(),
        28usize,
        concat!("Size of: ", stringify!(SkCubicMap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicMap>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicMap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCubicMap>())).fCoeff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicMap),
            "::",
            stringify!(fCoeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCubicMap>())).fType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicMap),
            "::",
            stringify!(fType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkCubicMap13computeYFromXEf"]
    pub fn SkCubicMap_computeYFromX(this: *const SkCubicMap, x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkCubicMap12computeFromTEf"]
    pub fn SkCubicMap_computeFromT(this: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkCubicMapC1E7SkPointS0_"]
    pub fn SkCubicMap_SkCubicMap(this: *mut SkCubicMap, p1: SkPoint, p2: SkPoint);
}
impl SkCubicMap {
    #[inline]
    pub unsafe fn computeYFromX(&self, x: f32) -> f32 {
        SkCubicMap_computeYFromX(self, x)
    }
    #[inline]
    pub unsafe fn computeFromT(&self, t: f32) -> SkPoint {
        SkCubicMap_computeFromT(self, t)
    }
    #[inline]
    pub unsafe fn new(p1: SkPoint, p2: SkPoint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCubicMap_SkCubicMap(__bindgen_tmp.as_mut_ptr(), p1, p2);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
pub type SkDataTable_FreeProc =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable_Dir {
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
#[test]
fn bindgen_test_layout_SkDataTable_Dir() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable_Dir>(),
        16usize,
        concat!("Size of: ", stringify!(SkDataTable_Dir))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable_Dir>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable_Dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkDataTable_Dir>())).fPtr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable_Dir),
            "::",
            stringify!(fPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkDataTable_Dir>())).fSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable_Dir),
            "::",
            stringify!(fSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkDataTable__bindgen_ty_1 {
    pub fDir: *const SkDataTable_Dir,
    pub fElems: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_SkDataTable__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SkDataTable__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkDataTable__bindgen_ty_1>())).fDir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable__bindgen_ty_1),
            "::",
            stringify!(fDir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDataTable__bindgen_ty_1>())).fElems as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable__bindgen_ty_1),
            "::",
            stringify!(fElems)
        )
    );
}
pub type SkDataTable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDataTable() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable>(),
        48usize,
        concat!("Size of: ", stringify!(SkDataTable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkDataTable6atSizeEi"]
    pub fn SkDataTable_atSize(this: *const SkDataTable, index: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkDataTable2atEiPm"]
    pub fn SkDataTable_at(
        this: *const SkDataTable,
        index: ::std::os::raw::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkDataTable9MakeEmptyEv"]
    pub fn SkDataTable_MakeEmpty() -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkDataTable14MakeCopyArraysEPKPKvPKmi"]
    pub fn SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkDataTable13MakeCopyArrayEPKvmi"]
    pub fn SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkDataTable13MakeArrayProcEPKvmiPFvPvES2_"]
    pub fn SkDataTable_MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable>;
}
impl SkDataTable {
    #[inline]
    pub unsafe fn atSize(&self, index: ::std::os::raw::c_int) -> usize {
        SkDataTable_atSize(self, index)
    }
    #[inline]
    pub unsafe fn at(
        &self,
        index: ::std::os::raw::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void {
        SkDataTable_at(self, index, size)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkDataTable> {
        SkDataTable_MakeEmpty()
    }
    #[inline]
    pub unsafe fn MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArrays(ptrs, sizes, count)
    }
    #[inline]
    pub unsafe fn MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArray(array, elemSize, count)
    }
    #[inline]
    pub unsafe fn MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeArrayProc(array, elemSize, count, proc_, context)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendSemaphore {
    _unused: [u8; 0],
}
impl GrBackendApi {
    pub const OpenGL_GrBackend: GrBackendApi = GrBackendApi::OpenGL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrBackendApi {
    OpenGL = 0,
    Vulkan = 1,
    Metal = 2,
    Direct3D = 3,
    Dawn = 4,
    Mock = 5,
}
pub use self::GrBackendApi as GrBackend;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrMipmapped {
    No = 0,
    Yes = 1,
}
pub use self::GrMipmapped as GrMipMapped;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrProtected {
    No = 0,
    Yes = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSurfaceOrigin {
    TopLeft = 0,
    BottomLeft = 1,
}
pub const kAll_GrBackendState: u32 = 4294967295;
pub type GrGpuFinishedContext = *mut ::core::ffi::c_void;
pub type GrGpuFinishedProc =
    ::core::option::Option<unsafe extern "C" fn(finishedContext: GrGpuFinishedContext)>;
pub type GrGpuSubmittedContext = *mut ::core::ffi::c_void;
pub type GrGpuSubmittedProc = ::core::option::Option<
    unsafe extern "C" fn(submittedContext: GrGpuSubmittedContext, success: bool),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrFlushInfo {
    pub fNumSemaphores: ::std::os::raw::c_int,
    pub fSignalSemaphores: *mut GrBackendSemaphore,
    pub fFinishedProc: GrGpuFinishedProc,
    pub fFinishedContext: GrGpuFinishedContext,
    pub fSubmittedProc: GrGpuSubmittedProc,
    pub fSubmittedContext: GrGpuSubmittedContext,
}
#[test]
fn bindgen_test_layout_GrFlushInfo() {
    assert_eq!(
        ::core::mem::size_of::<GrFlushInfo>(),
        48usize,
        concat!("Size of: ", stringify!(GrFlushInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrFlushInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GrFlushInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fNumSemaphores as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fNumSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fSignalSemaphores as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSignalSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fFinishedProc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fFinishedProc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fFinishedContext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fFinishedContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fSubmittedProc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSubmittedProc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GrFlushInfo>())).fSubmittedContext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSubmittedContext)
        )
    );
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSemaphoresSubmitted {
    No = 0,
    Yes = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GrBackendSurfaceMutableState {
    pub __bindgen_anon_1: GrBackendSurfaceMutableState__bindgen_ty_1,
    pub fBackend: GrBackend,
    pub fIsValid: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GrBackendSurfaceMutableState__bindgen_ty_1 {
    pub fDummy: ::std::os::raw::c_char,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_GrBackendSurfaceMutableState__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendSurfaceMutableState__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(GrBackendSurfaceMutableState__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendSurfaceMutableState__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GrBackendSurfaceMutableState__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GrBackendSurfaceMutableState__bindgen_ty_1>())).fDummy
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendSurfaceMutableState__bindgen_ty_1),
            "::",
            stringify!(fDummy)
        )
    );
}
#[test]
fn bindgen_test_layout_GrBackendSurfaceMutableState() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendSurfaceMutableState>(),
        12usize,
        concat!("Size of: ", stringify!(GrBackendSurfaceMutableState))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendSurfaceMutableState>(),
        4usize,
        concat!("Alignment of ", stringify!(GrBackendSurfaceMutableState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GrBackendSurfaceMutableState>())).fBackend as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendSurfaceMutableState),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GrBackendSurfaceMutableState>())).fIsValid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendSurfaceMutableState),
            "::",
            stringify!(fIsValid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28GrBackendSurfaceMutableStateC1ERKS_"]
    pub fn GrBackendSurfaceMutableState_GrBackendSurfaceMutableState(
        this: *mut GrBackendSurfaceMutableState,
        that: *const GrBackendSurfaceMutableState,
    );
}
impl GrBackendSurfaceMutableState {
    #[inline]
    pub unsafe fn new(that: *const GrBackendSurfaceMutableState) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendSurfaceMutableState_GrBackendSurfaceMutableState(__bindgen_tmp.as_mut_ptr(), that);
        __bindgen_tmp.assume_init()
    }
}
impl SkTileMode {
    pub const LastTileMode: SkTileMode = SkTileMode::Decal;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTileMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2,
    Decal = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMipmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap {
    pub fPixelRef: sk_sp<SkPixelRef>,
    pub fPixmap: SkPixmap,
    pub fMips: sk_sp<SkMipmap>,
}
pub const SkBitmap_AllocFlags_kZeroPixels_AllocFlag: SkBitmap_AllocFlags = 1;
pub type SkBitmap_AllocFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_Allocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkBitmap_Allocator_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkBitmap_Allocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_Allocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_Allocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_Allocator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_HeapAllocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkBitmap_HeapAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_HeapAllocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_HeapAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_HeapAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_HeapAllocator))
    );
}
#[test]
fn bindgen_test_layout_SkBitmap() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap>(),
        56usize,
        concat!("Size of: ", stringify!(SkBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkBitmap>())).fPixelRef as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fPixelRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkBitmap>())).fPixmap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fPixmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkBitmap>())).fMips as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fMips)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap4swapERS_"]
    pub fn SkBitmap_swap(this: *mut SkBitmap, other: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap12setAlphaTypeE11SkAlphaType"]
    pub fn SkBitmap_setAlphaType(this: *mut SkBitmap, alphaType: SkAlphaType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap11isImmutableEv"]
    pub fn SkBitmap_isImmutable(this: *const SkBitmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap12setImmutableEv"]
    pub fn SkBitmap_setImmutable(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap5resetEv"]
    pub fn SkBitmap_reset(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap9getBoundsEP6SkRect"]
    pub fn SkBitmap_getBounds(this: *const SkBitmap, bounds: *mut SkRect);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap9getBoundsEP7SkIRect"]
    pub fn SkBitmap_getBounds1(this: *const SkBitmap, bounds: *mut SkIRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap7setInfoERK11SkImageInfom"]
    pub fn SkBitmap_setInfo(
        this: *mut SkBitmap,
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap19tryAllocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_tryAllocPixelsFlags(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        flags: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap16allocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_allocPixelsFlags(this: *mut SkBitmap, info: *const SkImageInfo, flags: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap14tryAllocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_tryAllocPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11allocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_allocPixels(this: *mut SkBitmap, info: *const SkImageInfo, rowBytes: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11allocPixelsERK11SkImageInfo"]
    pub fn SkBitmap_allocPixels1(this: *mut SkBitmap, info: *const SkImageInfo);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap17tryAllocN32PixelsEiib"]
    pub fn SkBitmap_tryAllocN32Pixels(
        this: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap14allocN32PixelsEiib"]
    pub fn SkBitmap_allocN32Pixels(
        this: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap13installPixelsERK11SkImageInfoPvmPFvS3_S3_ES3_"]
    pub fn SkBitmap_installPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap13installPixelsERK8SkPixmap"]
    pub fn SkBitmap_installPixels1(this: *mut SkBitmap, pixmap: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap17installMaskPixelsERK6SkMask"]
    pub fn SkBitmap_installMaskPixels(this: *mut SkBitmap, mask: *const SkMask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap9setPixelsEPv"]
    pub fn SkBitmap_setPixels(this: *mut SkBitmap, pixels: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11allocPixelsEv"]
    pub fn SkBitmap_allocPixels2(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap14tryAllocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_tryAllocPixels1(
        this: *mut SkBitmap,
        allocator: *mut SkBitmap_Allocator,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11allocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_allocPixels3(this: *mut SkBitmap, allocator: *mut SkBitmap_Allocator);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap14pixelRefOriginEv"]
    pub fn SkBitmap_pixelRefOrigin(this: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11setPixelRefE5sk_spI10SkPixelRefEii"]
    pub fn SkBitmap_setPixelRef(
        this: *mut SkBitmap,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap15getGenerationIDEv"]
    pub fn SkBitmap_getGenerationID(this: *const SkBitmap) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap19notifyPixelsChangedEv"]
    pub fn SkBitmap_notifyPixelsChanged(this: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10eraseColorEj"]
    pub fn SkBitmap_eraseColor(this: *const SkBitmap, c: SkColor);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap5eraseEjRK7SkIRect"]
    pub fn SkBitmap_erase(this: *const SkBitmap, c: SkColor, area: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap7getAddrEii"]
    pub fn SkBitmap_getAddr(
        this: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkBitmap_extractSubset(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        subset: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkBitmap_readPixels(
        this: *const SkBitmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10readPixelsERK8SkPixmapii"]
    pub fn SkBitmap_readPixels1(
        this: *const SkBitmap,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap11writePixelsERK8SkPixmapii"]
    pub fn SkBitmap_writePixels(
        this: *mut SkBitmap,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap12extractAlphaEPS_PK7SkPaintPNS_9AllocatorEP8SkIPoint"]
    pub fn SkBitmap_extractAlpha(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10peekPixelsEP8SkPixmap"]
    pub fn SkBitmap_peekPixels(this: *const SkBitmap, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10makeShaderE10SkTileModeS0_PK8SkMatrix"]
    pub fn SkBitmap_makeShader(
        this: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkBitmap10makeShaderEPK8SkMatrix"]
    pub fn SkBitmap_makeShader1(
        this: *const SkBitmap,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmapC1Ev"]
    pub fn SkBitmap_SkBitmap(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmapC1ERKS_"]
    pub fn SkBitmap_SkBitmap1(this: *mut SkBitmap, src: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmapC1EOS_"]
    pub fn SkBitmap_SkBitmap2(this: *mut SkBitmap, src: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmapD1Ev"]
    pub fn SkBitmap_SkBitmap_destructor(this: *mut SkBitmap);
}
impl SkBitmap {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkBitmap) {
        SkBitmap_swap(self, other)
    }
    #[inline]
    pub unsafe fn setAlphaType(&mut self, alphaType: SkAlphaType) -> bool {
        SkBitmap_setAlphaType(self, alphaType)
    }
    #[inline]
    pub unsafe fn isImmutable(&self) -> bool {
        SkBitmap_isImmutable(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkBitmap_setImmutable(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkBitmap_reset(self)
    }
    #[inline]
    pub unsafe fn getBounds(&self, bounds: *mut SkRect) {
        SkBitmap_getBounds(self, bounds)
    }
    #[inline]
    pub unsafe fn getBounds1(&self, bounds: *mut SkIRect) {
        SkBitmap_getBounds1(self, bounds)
    }
    #[inline]
    pub unsafe fn setInfo(&mut self, imageInfo: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_setInfo(self, imageInfo, rowBytes)
    }
    #[inline]
    pub unsafe fn tryAllocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) -> bool {
        SkBitmap_tryAllocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn allocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) {
        SkBitmap_allocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn tryAllocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_tryAllocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) {
        SkBitmap_allocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels1(&mut self, info: *const SkImageInfo) {
        SkBitmap_allocPixels1(self, info)
    }
    #[inline]
    pub unsafe fn tryAllocN32Pixels(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool {
        SkBitmap_tryAllocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn allocN32Pixels(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) {
        SkBitmap_allocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn installPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool {
        SkBitmap_installPixels(self, info, pixels, rowBytes, releaseProc, context)
    }
    #[inline]
    pub unsafe fn installPixels1(&mut self, pixmap: *const SkPixmap) -> bool {
        SkBitmap_installPixels1(self, pixmap)
    }
    #[inline]
    pub unsafe fn installMaskPixels(&mut self, mask: *const SkMask) -> bool {
        SkBitmap_installMaskPixels(self, mask)
    }
    #[inline]
    pub unsafe fn setPixels(&mut self, pixels: *mut ::core::ffi::c_void) {
        SkBitmap_setPixels(self, pixels)
    }
    #[inline]
    pub unsafe fn allocPixels2(&mut self) {
        SkBitmap_allocPixels2(self)
    }
    #[inline]
    pub unsafe fn tryAllocPixels1(&mut self, allocator: *mut SkBitmap_Allocator) -> bool {
        SkBitmap_tryAllocPixels1(self, allocator)
    }
    #[inline]
    pub unsafe fn allocPixels3(&mut self, allocator: *mut SkBitmap_Allocator) {
        SkBitmap_allocPixels3(self, allocator)
    }
    #[inline]
    pub unsafe fn pixelRefOrigin(&self) -> SkIPoint {
        SkBitmap_pixelRefOrigin(self)
    }
    #[inline]
    pub unsafe fn setPixelRef(
        &mut self,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    ) {
        SkBitmap_setPixelRef(self, pixelRef, dx, dy)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkBitmap_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&self) {
        SkBitmap_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn eraseColor(&self, c: SkColor) {
        SkBitmap_eraseColor(self, c)
    }
    #[inline]
    pub unsafe fn erase(&self, c: SkColor, area: *const SkIRect) {
        SkBitmap_erase(self, c, area)
    }
    #[inline]
    pub unsafe fn getAddr(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void {
        SkBitmap_getAddr(self, x, y)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, dst: *mut SkBitmap, subset: *const SkIRect) -> bool {
        SkBitmap_extractSubset(self, dst, subset)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_readPixels1(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn extractAlpha(
        &self,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool {
        SkBitmap_extractAlpha(self, dst, paint, allocator, offset)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkBitmap_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader(self, tmx, tmy, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(&self, localMatrix: *const SkMatrix) -> sk_sp<SkShader> {
        SkBitmap_makeShader1(self, localMatrix)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(src: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap1(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(src: *mut SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap2(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkBitmap_SkBitmap_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkBitmap13HeapAllocator13allocPixelRefEPS_"]
    pub fn SkBitmap_HeapAllocator_allocPixelRef(
        this: *mut ::core::ffi::c_void,
        bitmap: *mut SkBitmap,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkArenaAlloc {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShader {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
impl SkShader_GradientType {
    pub const Last: SkShader_GradientType = SkShader_GradientType::Conical;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkShader_GradientType {
    None = 0,
    Color = 1,
    Linear = 2,
    Radial = 3,
    Sweep = 4,
    Conical = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShader_GradientInfo {
    pub fColorCount: ::std::os::raw::c_int,
    pub fColors: *mut SkColor,
    pub fColorOffsets: *mut SkScalar,
    pub fPoint: [SkPoint; 2usize],
    pub fRadius: [SkScalar; 2usize],
    pub fTileMode: SkTileMode,
    pub fGradientFlags: u32,
}
#[test]
fn bindgen_test_layout_SkShader_GradientInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkShader_GradientInfo>(),
        56usize,
        concat!("Size of: ", stringify!(SkShader_GradientInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShader_GradientInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShader_GradientInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkShader_GradientInfo>())).fColorCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fColorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkShader_GradientInfo>())).fColors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fColors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkShader_GradientInfo>())).fColorOffsets as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fColorOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkShader_GradientInfo>())).fPoint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkShader_GradientInfo>())).fRadius as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkShader_GradientInfo>())).fTileMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fTileMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkShader_GradientInfo>())).fGradientFlags as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShader_GradientInfo),
            "::",
            stringify!(fGradientFlags)
        )
    );
}
pub type SkShader_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkShader() {
    assert_eq!(
        ::core::mem::size_of::<SkShader>(),
        16usize,
        concat!("Size of: ", stringify!(SkShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShader>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShader))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkShader8isAImageEP8SkMatrixP10SkTileMode"]
    pub fn SkShader_isAImage(
        this: *const SkShader,
        localMatrix: *mut SkMatrix,
        xy: *mut SkTileMode,
    ) -> *mut SkImage;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkShader19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkShader_makeWithLocalMatrix(
        this: *const SkShader,
        arg1: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkShader19makeWithColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkShader_makeWithColorFilter(
        this: *const SkShader,
        arg1: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkShader>;
}
impl SkShader {
    #[inline]
    pub unsafe fn isAImage(&self, localMatrix: *mut SkMatrix, xy: *mut SkTileMode) -> *mut SkImage {
        SkShader_isAImage(self, localMatrix, xy)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, arg1: *const SkMatrix) -> sk_sp<SkShader> {
        SkShader_makeWithLocalMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn makeWithColorFilter(&self, arg1: sk_sp<SkColorFilter>) -> sk_sp<SkShader> {
        SkShader_makeWithColorFilter(self, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkShader11asAGradientEPNS_12GradientInfoE"]
    pub fn SkShader_asAGradient(
        this: *mut ::core::ffi::c_void,
        info: *mut SkShader_GradientInfo,
    ) -> SkShader_GradientType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrDirectContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrYUVABackendTextures {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImage {
    pub _base: SkRefCnt,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
pub type SkImage_ReleaseContext = *mut ::core::ffi::c_void;
pub type SkImage_RasterReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(pixels: *const ::core::ffi::c_void, arg1: SkImage_ReleaseContext),
>;
impl SkImage_CompressionType {
    pub const Last: SkImage_CompressionType = SkImage_CompressionType::BC1_RGBA8_UNORM;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_CompressionType {
    None = 0,
    ETC2_RGB8_UNORM = 1,
    BC1_RGB8_UNORM = 2,
    BC1_RGBA8_UNORM = 3,
}
pub type SkImage_TextureReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(releaseContext: SkImage_ReleaseContext)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_BitDepth {
    U8 = 0,
    F16 = 1,
}
pub type SkImage_CubicResampler = SkCubicResampler;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_CachingHint {
    Allow = 0,
    Disallow = 1,
}
#[repr(C)]
pub struct SkImage_AsyncReadResult__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImage_AsyncReadResult {
    pub vtable_: *const SkImage_AsyncReadResult__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkImage_AsyncReadResult() {
    assert_eq!(
        ::core::mem::size_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Size of: ", stringify!(SkImage_AsyncReadResult))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage_AsyncReadResult))
    );
}
pub type SkImage_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkImage_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkImage_ReadPixelsContext, arg2: u8)>;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_RescaleGamma {
    kSrc = 0,
    kLinear = 1,
}
pub type SkImage_BackendTextureReleaseProc = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_LegacyBitmapMode {
    kRO_LegacyBitmapMode = 0,
}
pub type SkImage_INHERITED = SkRefCnt;
pub const SkImage_kCompressionTypeCount: ::std::os::raw::c_int = 4;
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage21kETC1_CompressionTypeE"]
    pub static SkImage_kETC1_CompressionType: SkImage_CompressionType;
}
#[test]
fn bindgen_test_layout_SkImage() {
    assert_eq!(
        ::core::mem::size_of::<SkImage>(),
        48usize,
        concat!("Size of: ", stringify!(SkImage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImage>())).fInfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImage),
            "::",
            stringify!(fInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImage>())).fUniqueID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImage),
            "::",
            stringify!(fUniqueID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage14MakeRasterCopyERK8SkPixmap"]
    pub fn SkImage_MakeRasterCopy(pixmap: *const SkPixmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage14MakeRasterDataERK11SkImageInfo5sk_spI6SkDataEm"]
    pub fn SkImage_MakeRasterData(
        info: *const SkImageInfo,
        pixels: sk_sp<SkData>,
        rowBytes: usize,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage14MakeFromRasterERK8SkPixmapPFvPKvPvES5_"]
    pub fn SkImage_MakeFromRaster(
        pixmap: *const SkPixmap,
        rasterReleaseProc: SkImage_RasterReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage14MakeFromBitmapERK8SkBitmap"]
    pub fn SkImage_MakeFromBitmap(bitmap: *const SkBitmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage17MakeFromGeneratorESt10unique_ptrI16SkImageGeneratorSt14default_deleteIS1_EE"]
    pub fn SkImage_MakeFromGenerator(imageGenerator: u64) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage15MakeFromEncodedE5sk_spI6SkDataE"]
    pub fn SkImage_MakeFromEncoded(encoded: sk_sp<SkData>) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage25MakeTextureFromCompressedEP15GrDirectContext5sk_spI6SkDataEiiNS_15CompressionTypeE11GrMipmapped11GrProtected"]
    pub fn SkImage_MakeTextureFromCompressed(
        direct: *mut GrDirectContext,
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
        mipMapped: GrMipmapped,
        isProtected: GrProtected,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage24MakeRasterFromCompressedE5sk_spI6SkDataEiiNS_15CompressionTypeE"]
    pub fn SkImage_MakeRasterFromCompressed(
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage15MakeFromTextureEP18GrRecordingContextRK16GrBackendTexture15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceEPFvPvESB_"]
    pub fn SkImage_MakeFromTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage25MakeFromCompressedTextureEP18GrRecordingContextRK16GrBackendTexture15GrSurfaceOrigin11SkAlphaType5sk_spI12SkColorSpaceEPFvPvESA_"]
    pub fn SkImage_MakeFromCompressedTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage26MakeCrossContextFromPixmapEP15GrDirectContextRK8SkPixmapbb"]
    pub fn SkImage_MakeCrossContextFromPixmap(
        context: *mut GrDirectContext,
        pixmap: *const SkPixmap,
        buildMips: bool,
        limitToMaxTextureSize: bool,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage22MakeFromAdoptedTextureEP18GrRecordingContextRK16GrBackendTexture15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImage_MakeFromAdoptedTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        textureOrigin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage20MakeFromYUVATexturesEP18GrRecordingContextRK21GrYUVABackendTextures5sk_spI12SkColorSpaceEPFvPvES8_"]
    pub fn SkImage_MakeFromYUVATextures(
        context: *mut GrRecordingContext,
        yuvaTextures: *const GrYUVABackendTextures,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage34MakeFromYUVATexturesCopyToExternalEP18GrRecordingContextRK21GrYUVABackendTexturesRK16GrBackendTexture11SkColorType5sk_spI12SkColorSpaceEPFvPvESC_SE_SC_"]
    pub fn SkImage_MakeFromYUVATexturesCopyToExternal(
        context: *mut GrRecordingContext,
        yuvaTextures: *const GrYUVABackendTextures,
        rgbaResultTexture: *const GrBackendTexture,
        colorType: SkColorType,
        imageColorSpace: sk_sp<SkColorSpace>,
        yuvaReleaseProc: SkImage_TextureReleaseProc,
        yuvaReleaseContext: SkImage_ReleaseContext,
        rgbaReleaseProc: SkImage_TextureReleaseProc,
        rgbaReleaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage20MakeFromYUVATexturesEP18GrRecordingContext15SkYUVColorSpacePK16GrBackendTexturePK11SkYUVAIndex7SkISize15GrSurfaceOrigin5sk_spI12SkColorSpaceEPFvPvESE_"]
    pub fn SkImage_MakeFromYUVATextures1(
        context: *mut GrRecordingContext,
        yuvColorSpace: SkYUVColorSpace,
        yuvaTextures: *const GrBackendTexture,
        yuvaIndices: *const SkYUVAIndex,
        imageSize: SkISize,
        textureOrigin: GrSurfaceOrigin,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage19MakeFromYUVAPixmapsEP18GrRecordingContextRK13SkYUVAPixmaps11GrMipmappedb5sk_spI12SkColorSpaceE"]
    pub fn SkImage_MakeFromYUVAPixmaps(
        context: *mut GrRecordingContext,
        pixmaps: *const SkYUVAPixmaps,
        buildMips: GrMipMapped,
        limitToMaxTextureSize: bool,
        imageColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage15MakeFromPictureE5sk_spI9SkPictureERK7SkISizePK8SkMatrixPK7SkPaintNS_8BitDepthES0_I12SkColorSpaceE"]
    pub fn SkImage_MakeFromPicture(
        picture: sk_sp<SkPicture>,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage9alphaTypeEv"]
    pub fn SkImage_alphaType(this: *const SkImage) -> SkAlphaType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage9colorTypeEv"]
    pub fn SkImage_colorType(this: *const SkImage) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10colorSpaceEv"]
    pub fn SkImage_colorSpace(this: *const SkImage) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage13refColorSpaceEv"]
    pub fn SkImage_refColorSpace(this: *const SkImage) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage11isAlphaOnlyEv"]
    pub fn SkImage_isAlphaOnly(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeShader(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10makeShaderE10SkTileModeS0_PK8SkMatrix"]
    pub fn SkImage_makeShader1(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10peekPixelsEP8SkPixmap"]
    pub fn SkImage_peekPixels(this: *const SkImage, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage15isTextureBackedEv"]
    pub fn SkImage_isTextureBacked(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage7isValidEP18GrRecordingContext"]
    pub fn SkImage_isValid(this: *const SkImage, context: *mut GrRecordingContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage5flushEP15GrDirectContextRK11GrFlushInfo"]
    pub fn SkImage_flush(
        this: *mut SkImage,
        context: *mut GrDirectContext,
        flushInfo: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage14flushAndSubmitEP15GrDirectContext"]
    pub fn SkImage_flushAndSubmit(this: *mut SkImage, arg1: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage17getBackendTextureEbP15GrSurfaceOrigin"]
    pub fn SkImage_getBackendTexture(
        this: *const SkImage,
        flushPendingGrContextIO: bool,
        origin: *mut GrSurfaceOrigin,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10readPixelsEP15GrDirectContextRK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10readPixelsEP15GrDirectContextRK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels1(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10readPixelsERK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels2(
        this: *const SkImage,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10readPixelsERK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels3(
        this: *const SkImage,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectNS_12RescaleGammaE15SkFilterQualityPFvPvSt10unique_ptrIKNS_15AsyncReadResultESt14default_deleteISB_EEES8_"]
    pub fn SkImage_asyncRescaleAndReadPixels(
        this: *mut SkImage,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeNS_12RescaleGammaE15SkFilterQualityPFvPvSt10unique_ptrIKNS_15AsyncReadResultESt14default_deleteISF_EEESC_"]
    pub fn SkImage_asyncRescaleAndReadPixelsYUV420(
        this: *mut SkImage,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage11scalePixelsERK8SkPixmapRK17SkSamplingOptionsNS_11CachingHintE"]
    pub fn SkImage_scalePixels(
        this: *const SkImage,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage12encodeToDataE20SkEncodedImageFormati"]
    pub fn SkImage_encodeToData(
        this: *const SkImage,
        encodedImageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage12encodeToDataEv"]
    pub fn SkImage_encodeToData1(this: *const SkImage) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage14refEncodedDataEv"]
    pub fn SkImage_refEncodedData(this: *const SkImage) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10makeSubsetERK7SkIRectP15GrDirectContext"]
    pub fn SkImage_makeSubset(
        this: *const SkImage,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage10hasMipmapsEv"]
    pub fn SkImage_hasMipmaps(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage18withDefaultMipmapsEv"]
    pub fn SkImage_withDefaultMipmaps(this: *const SkImage) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage16makeTextureImageEP15GrDirectContext11GrMipmapped10SkBudgeted"]
    pub fn SkImage_makeTextureImage(
        this: *const SkImage,
        arg1: *mut GrDirectContext,
        arg2: GrMipmapped,
        arg3: SkBudgeted,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage19makeNonTextureImageEv"]
    pub fn SkImage_makeNonTextureImage(this: *const SkImage) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage15makeRasterImageENS_11CachingHintE"]
    pub fn SkImage_makeRasterImage(
        this: *const SkImage,
        cachingHint: SkImage_CachingHint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage14makeWithFilterEP18GrRecordingContextPK13SkImageFilterRK7SkIRectS7_PS5_P8SkIPoint"]
    pub fn SkImage_makeWithFilter(
        this: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN7SkImage29MakeBackendTextureFromSkImageEP15GrDirectContext5sk_spIS_EP16GrBackendTexturePSt8functionIFvS4_EE"]
    pub fn SkImage_MakeBackendTextureFromSkImage(
        context: *mut GrDirectContext,
        image: sk_sp<SkImage>,
        backendTexture: *mut GrBackendTexture,
        backendTextureReleaseProc: *mut SkImage_BackendTextureReleaseProc,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage14asLegacyBitmapEP8SkBitmapNS_16LegacyBitmapModeE"]
    pub fn SkImage_asLegacyBitmap(
        this: *const SkImage,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage15isLazyGeneratedEv"]
    pub fn SkImage_isLazyGenerated(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage14makeColorSpaceE5sk_spI12SkColorSpaceEP15GrDirectContext"]
    pub fn SkImage_makeColorSpace(
        this: *const SkImage,
        target: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage26makeColorTypeAndColorSpaceE11SkColorType5sk_spI12SkColorSpaceEP15GrDirectContext"]
    pub fn SkImage_makeColorTypeAndColorSpace(
        this: *const SkImage,
        targetColorType: SkColorType,
        targetColorSpace: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7SkImage21reinterpretColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkImage_reinterpretColorSpace(
        this: *const SkImage,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
impl SkImage {
    #[inline]
    pub unsafe fn MakeRasterCopy(pixmap: *const SkPixmap) -> sk_sp<SkImage> {
        SkImage_MakeRasterCopy(pixmap)
    }
    #[inline]
    pub unsafe fn MakeRasterData(
        info: *const SkImageInfo,
        pixels: sk_sp<SkData>,
        rowBytes: usize,
    ) -> sk_sp<SkImage> {
        SkImage_MakeRasterData(info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn MakeFromRaster(
        pixmap: *const SkPixmap,
        rasterReleaseProc: SkImage_RasterReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromRaster(pixmap, rasterReleaseProc, releaseContext)
    }
    #[inline]
    pub unsafe fn MakeFromBitmap(bitmap: *const SkBitmap) -> sk_sp<SkImage> {
        SkImage_MakeFromBitmap(bitmap)
    }
    #[inline]
    pub unsafe fn MakeFromGenerator(imageGenerator: u64) -> sk_sp<SkImage> {
        SkImage_MakeFromGenerator(imageGenerator)
    }
    #[inline]
    pub unsafe fn MakeFromEncoded(encoded: sk_sp<SkData>) -> sk_sp<SkImage> {
        SkImage_MakeFromEncoded(encoded)
    }
    #[inline]
    pub unsafe fn MakeTextureFromCompressed(
        direct: *mut GrDirectContext,
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
        mipMapped: GrMipmapped,
        isProtected: GrProtected,
    ) -> sk_sp<SkImage> {
        SkImage_MakeTextureFromCompressed(
            direct,
            data,
            width,
            height,
            type_,
            mipMapped,
            isProtected,
        )
    }
    #[inline]
    pub unsafe fn MakeRasterFromCompressed(
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> sk_sp<SkImage> {
        SkImage_MakeRasterFromCompressed(data, width, height, type_)
    }
    #[inline]
    pub unsafe fn MakeFromTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromTexture(
            context,
            backendTexture,
            origin,
            colorType,
            alphaType,
            colorSpace,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeFromCompressedTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromCompressedTexture(
            context,
            backendTexture,
            origin,
            alphaType,
            colorSpace,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeCrossContextFromPixmap(
        context: *mut GrDirectContext,
        pixmap: *const SkPixmap,
        buildMips: bool,
        limitToMaxTextureSize: bool,
    ) -> sk_sp<SkImage> {
        SkImage_MakeCrossContextFromPixmap(context, pixmap, buildMips, limitToMaxTextureSize)
    }
    #[inline]
    pub unsafe fn MakeFromAdoptedTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        textureOrigin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromAdoptedTexture(
            context,
            backendTexture,
            textureOrigin,
            colorType,
            alphaType,
            colorSpace,
        )
    }
    #[inline]
    pub unsafe fn MakeFromYUVATextures(
        context: *mut GrRecordingContext,
        yuvaTextures: *const GrYUVABackendTextures,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromYUVATextures(
            context,
            yuvaTextures,
            imageColorSpace,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeFromYUVATexturesCopyToExternal(
        context: *mut GrRecordingContext,
        yuvaTextures: *const GrYUVABackendTextures,
        rgbaResultTexture: *const GrBackendTexture,
        colorType: SkColorType,
        imageColorSpace: sk_sp<SkColorSpace>,
        yuvaReleaseProc: SkImage_TextureReleaseProc,
        yuvaReleaseContext: SkImage_ReleaseContext,
        rgbaReleaseProc: SkImage_TextureReleaseProc,
        rgbaReleaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromYUVATexturesCopyToExternal(
            context,
            yuvaTextures,
            rgbaResultTexture,
            colorType,
            imageColorSpace,
            yuvaReleaseProc,
            yuvaReleaseContext,
            rgbaReleaseProc,
            rgbaReleaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeFromYUVATextures1(
        context: *mut GrRecordingContext,
        yuvColorSpace: SkYUVColorSpace,
        yuvaTextures: *const GrBackendTexture,
        yuvaIndices: *const SkYUVAIndex,
        imageSize: SkISize,
        textureOrigin: GrSurfaceOrigin,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureReleaseProc: SkImage_TextureReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromYUVATextures1(
            context,
            yuvColorSpace,
            yuvaTextures,
            yuvaIndices,
            imageSize,
            textureOrigin,
            imageColorSpace,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeFromYUVAPixmaps(
        context: *mut GrRecordingContext,
        pixmaps: *const SkYUVAPixmaps,
        buildMips: GrMipMapped,
        limitToMaxTextureSize: bool,
        imageColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromYUVAPixmaps(
            context,
            pixmaps,
            buildMips,
            limitToMaxTextureSize,
            imageColorSpace,
        )
    }
    #[inline]
    pub unsafe fn MakeFromPicture(
        picture: sk_sp<SkPicture>,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromPicture(picture, dimensions, matrix, paint, bitDepth, colorSpace)
    }
    #[inline]
    pub unsafe fn alphaType(&self) -> SkAlphaType {
        SkImage_alphaType(self)
    }
    #[inline]
    pub unsafe fn colorType(&self) -> SkColorType {
        SkImage_colorType(self)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkImage_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkImage_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn isAlphaOnly(&self) -> bool {
        SkImage_isAlphaOnly(self)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader1(self, tmx, tmy, localMatrix)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkImage_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn isTextureBacked(&self) -> bool {
        SkImage_isTextureBacked(self)
    }
    #[inline]
    pub unsafe fn isValid(&self, context: *mut GrRecordingContext) -> bool {
        SkImage_isValid(self, context)
    }
    #[inline]
    pub unsafe fn flush(
        &mut self,
        context: *mut GrDirectContext,
        flushInfo: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted {
        SkImage_flush(self, context, flushInfo)
    }
    #[inline]
    pub unsafe fn flushAndSubmit(&mut self, arg1: *mut GrDirectContext) {
        SkImage_flushAndSubmit(self, arg1)
    }
    #[inline]
    pub unsafe fn getBackendTexture(
        &self,
        flushPendingGrContextIO: bool,
        origin: *mut GrSurfaceOrigin,
    ) -> GrBackendTexture {
        SkImage_getBackendTexture(self, flushPendingGrContextIO, origin)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels(
            self,
            context,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels1(self, context, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels2(
            self,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels3(
        &self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels3(self, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &mut self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleQuality,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &mut self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleQuality,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn scalePixels(
        &self,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_scalePixels(self, dst, arg1, cachingHint)
    }
    #[inline]
    pub unsafe fn encodeToData(
        &self,
        encodedImageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> sk_sp<SkData> {
        SkImage_encodeToData(self, encodedImageFormat, quality)
    }
    #[inline]
    pub unsafe fn encodeToData1(&self) -> sk_sp<SkData> {
        SkImage_encodeToData1(self)
    }
    #[inline]
    pub unsafe fn refEncodedData(&self) -> sk_sp<SkData> {
        SkImage_refEncodedData(self)
    }
    #[inline]
    pub unsafe fn makeSubset(
        &self,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeSubset(self, subset, direct)
    }
    #[inline]
    pub unsafe fn hasMipmaps(&self) -> bool {
        SkImage_hasMipmaps(self)
    }
    #[inline]
    pub unsafe fn withDefaultMipmaps(&self) -> sk_sp<SkImage> {
        SkImage_withDefaultMipmaps(self)
    }
    #[inline]
    pub unsafe fn makeTextureImage(
        &self,
        arg1: *mut GrDirectContext,
        arg2: GrMipmapped,
        arg3: SkBudgeted,
    ) -> sk_sp<SkImage> {
        SkImage_makeTextureImage(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn makeNonTextureImage(&self) -> sk_sp<SkImage> {
        SkImage_makeNonTextureImage(self)
    }
    #[inline]
    pub unsafe fn makeRasterImage(&self, cachingHint: SkImage_CachingHint) -> sk_sp<SkImage> {
        SkImage_makeRasterImage(self, cachingHint)
    }
    #[inline]
    pub unsafe fn makeWithFilter(
        &self,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage> {
        SkImage_makeWithFilter(self, context, filter, subset, clipBounds, outSubset, offset)
    }
    #[inline]
    pub unsafe fn MakeBackendTextureFromSkImage(
        context: *mut GrDirectContext,
        image: sk_sp<SkImage>,
        backendTexture: *mut GrBackendTexture,
        backendTextureReleaseProc: *mut SkImage_BackendTextureReleaseProc,
    ) -> bool {
        SkImage_MakeBackendTextureFromSkImage(
            context,
            image,
            backendTexture,
            backendTextureReleaseProc,
        )
    }
    #[inline]
    pub unsafe fn asLegacyBitmap(
        &self,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool {
        SkImage_asLegacyBitmap(self, bitmap, legacyBitmapMode)
    }
    #[inline]
    pub unsafe fn isLazyGenerated(&self) -> bool {
        SkImage_isLazyGenerated(self)
    }
    #[inline]
    pub unsafe fn makeColorSpace(
        &self,
        target: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeColorSpace(self, target, direct)
    }
    #[inline]
    pub unsafe fn makeColorTypeAndColorSpace(
        &self,
        targetColorType: SkColorType,
        targetColorSpace: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeColorTypeAndColorSpace(self, targetColorType, targetColorSpace, direct)
    }
    #[inline]
    pub unsafe fn reinterpretColorSpace(
        &self,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_reinterpretColorSpace(self, newColorSpace)
    }
}
impl GrSLType {
    pub const Last: GrSLType = GrSLType::Input;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSLType {
    Void = 0,
    Bool = 1,
    Byte = 2,
    Byte2 = 3,
    Byte3 = 4,
    Byte4 = 5,
    UByte = 6,
    UByte2 = 7,
    UByte3 = 8,
    UByte4 = 9,
    Short = 10,
    Short2 = 11,
    Short3 = 12,
    Short4 = 13,
    UShort = 14,
    UShort2 = 15,
    UShort3 = 16,
    UShort4 = 17,
    Float = 18,
    Float2 = 19,
    Float3 = 20,
    Float4 = 21,
    Float2x2 = 22,
    Float3x3 = 23,
    Float4x4 = 24,
    Half = 25,
    Half2 = 26,
    Half3 = 27,
    Half4 = 28,
    Half2x2 = 29,
    Half3x3 = 30,
    Half4x4 = 31,
    Int = 32,
    Int2 = 33,
    Int3 = 34,
    Int4 = 35,
    Uint = 36,
    Uint2 = 37,
    Texture2DSampler = 38,
    TextureExternalSampler = 39,
    Texture2DRectSampler = 40,
    Texture2D = 41,
    Sampler = 42,
    Input = 43,
}
#[repr(C)]
#[repr(align(4))]
pub struct VkPhysicalDeviceFeatures {
    pub _bindgen_opaque_blob: [u32; 55usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures() {
    assert_eq!(
        ::core::mem::size_of::<VkPhysicalDeviceFeatures>(),
        220usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures))
    );
    assert_eq!(
        ::core::mem::align_of::<VkPhysicalDeviceFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2 {
    pub _bindgen_opaque_blob: [u64; 30usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures2() {
    assert_eq!(
        ::core::mem::size_of::<VkPhysicalDeviceFeatures2>(),
        240usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures2))
    );
    assert_eq!(
        ::core::mem::align_of::<VkPhysicalDeviceFeatures2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures2))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendFormat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GrBackendFormat() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendFormat>(),
        1usize,
        concat!("Size of: ", stringify!(GrBackendFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendFormat>(),
        1usize,
        concat!("Alignment of ", stringify!(GrBackendFormat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendTexture {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GrBackendTexture() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendTexture>(),
        1usize,
        concat!("Size of: ", stringify!(GrBackendTexture))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendTexture>(),
        1usize,
        concat!("Alignment of ", stringify!(GrBackendTexture))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendRenderTarget {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GrBackendRenderTarget() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendRenderTarget>(),
        1usize,
        concat!("Size of: ", stringify!(GrBackendRenderTarget))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendRenderTarget>(),
        1usize,
        concat!("Alignment of ", stringify!(GrBackendRenderTarget))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurfaceCharacterization {
    pub fSurfaceProps: SkSurfaceProps,
}
#[test]
fn bindgen_test_layout_SkSurfaceCharacterization() {
    assert_eq!(
        ::core::mem::size_of::<SkSurfaceCharacterization>(),
        8usize,
        concat!("Size of: ", stringify!(SkSurfaceCharacterization))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurfaceCharacterization>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSurfaceCharacterization))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkSurfaceCharacterization>())).fSurfaceProps as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSurfaceCharacterization),
            "::",
            stringify!(fSurfaceProps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayListPriv {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayList {
    pub _bindgen_opaque_blob: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayList_LazyProxyData {
    pub _base: SkRefCnt,
}
#[test]
fn bindgen_test_layout_SkDeferredDisplayList_LazyProxyData() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayList_LazyProxyData>(),
        16usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayList_LazyProxyData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayList_LazyProxyData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkDeferredDisplayList_LazyProxyData)
        )
    );
}
#[test]
fn bindgen_test_layout_SkDeferredDisplayList() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayList>(),
        12usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayList))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayList>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDeferredDisplayList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21SkDeferredDisplayListD1Ev"]
    pub fn SkDeferredDisplayList_SkDeferredDisplayList_destructor(this: *mut SkDeferredDisplayList);
}
impl SkDeferredDisplayList {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeferredDisplayList_SkDeferredDisplayList_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrYUVABackendTextureInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPromiseImageTexture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDeferredDisplayListRecorder {
    pub fCharacterization: SkSurfaceCharacterization,
}
pub type SkDeferredDisplayListRecorder_PromiseImageTextureContext = *mut ::core::ffi::c_void;
pub type SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: SkDeferredDisplayListRecorder_PromiseImageTextureContext,
    ) -> sk_sp<SkPromiseImageTexture>,
>;
pub type SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(arg1: SkDeferredDisplayListRecorder_PromiseImageTextureContext),
>;
#[test]
fn bindgen_test_layout_SkDeferredDisplayListRecorder() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayListRecorder>(),
        8usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayListRecorder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayListRecorder>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDeferredDisplayListRecorder))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDeferredDisplayListRecorder>())).fCharacterization as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDeferredDisplayListRecorder),
            "::",
            stringify!(fCharacterization)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorder9getCanvasEv"]
    pub fn SkDeferredDisplayListRecorder_getCanvas(
        this: *mut SkDeferredDisplayListRecorder,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorder6detachEv"]
    pub fn SkDeferredDisplayListRecorder_detach(
        this: *mut SkDeferredDisplayListRecorder,
    ) -> sk_sp<SkDeferredDisplayList>;
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorder18makePromiseTextureERK15GrBackendFormatii11GrMipmapped15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceEPFS7_I21SkPromiseImageTextureEPvEPFvSC_ESC_"]
    pub fn SkDeferredDisplayListRecorder_makePromiseTexture(
        this: *mut SkDeferredDisplayListRecorder,
        backendFormat: *const GrBackendFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        mipMapped: GrMipmapped,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureFulfillProc: SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc,
        textureReleaseProc: SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc,
        textureContext: SkDeferredDisplayListRecorder_PromiseImageTextureContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorder22makeYUVAPromiseTextureERK24GrYUVABackendTextureInfo5sk_spI12SkColorSpaceEPFS3_I21SkPromiseImageTextureEPvEPFvS8_EPS8_"]
    pub fn SkDeferredDisplayListRecorder_makeYUVAPromiseTexture(
        this: *mut SkDeferredDisplayListRecorder,
        yuvaBackendTextureInfo: *const GrYUVABackendTextureInfo,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureFulfillProc: SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc,
        textureReleaseProc: SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc,
        textureContexts: *mut SkDeferredDisplayListRecorder_PromiseImageTextureContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorderC1ERK25SkSurfaceCharacterization"]
    pub fn SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder(
        this: *mut SkDeferredDisplayListRecorder,
        arg1: *const SkSurfaceCharacterization,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29SkDeferredDisplayListRecorderD1Ev"]
    pub fn SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder_destructor(
        this: *mut SkDeferredDisplayListRecorder,
    );
}
impl SkDeferredDisplayListRecorder {
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkDeferredDisplayListRecorder_getCanvas(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkDeferredDisplayList> {
        SkDeferredDisplayListRecorder_detach(self)
    }
    #[inline]
    pub unsafe fn makePromiseTexture(
        &mut self,
        backendFormat: *const GrBackendFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        mipMapped: GrMipmapped,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: sk_sp<SkColorSpace>,
        textureFulfillProc: SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc,
        textureReleaseProc: SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc,
        textureContext: SkDeferredDisplayListRecorder_PromiseImageTextureContext,
    ) -> sk_sp<SkImage> {
        SkDeferredDisplayListRecorder_makePromiseTexture(
            self,
            backendFormat,
            width,
            height,
            mipMapped,
            origin,
            colorType,
            alphaType,
            colorSpace,
            textureFulfillProc,
            textureReleaseProc,
            textureContext,
        )
    }
    #[inline]
    pub unsafe fn makeYUVAPromiseTexture(
        &mut self,
        yuvaBackendTextureInfo: *const GrYUVABackendTextureInfo,
        imageColorSpace: sk_sp<SkColorSpace>,
        textureFulfillProc: SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc,
        textureReleaseProc: SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc,
        textureContexts: *mut SkDeferredDisplayListRecorder_PromiseImageTextureContext,
    ) -> sk_sp<SkImage> {
        SkDeferredDisplayListRecorder_makeYUVAPromiseTexture(
            self,
            yuvaBackendTextureInfo,
            imageColorSpace,
            textureFulfillProc,
            textureReleaseProc,
            textureContexts,
        )
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkSurfaceCharacterization) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder(
            __bindgen_tmp.as_mut_ptr(),
            arg1,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder_destructor(self)
    }
}
impl SkBlurStyle {
    pub const LastEnum: SkBlurStyle = SkBlurStyle::Inner;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlurStyle {
    Normal = 0,
    Solid = 1,
    Outer = 2,
    Inner = 3,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawLooper {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawLooper_Context {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawLooper_Context_Info {
    pub fTranslate: SkVector,
    pub fApplyPostCTM: bool,
}
#[test]
fn bindgen_test_layout_SkDrawLooper_Context_Info() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawLooper_Context_Info>(),
        12usize,
        concat!("Size of: ", stringify!(SkDrawLooper_Context_Info))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawLooper_Context_Info>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDrawLooper_Context_Info))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_Context_Info>())).fTranslate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_Context_Info),
            "::",
            stringify!(fTranslate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_Context_Info>())).fApplyPostCTM as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_Context_Info),
            "::",
            stringify!(fApplyPostCTM)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkDrawLooper7Context4Info10applyToCTMEP8SkMatrix"]
    pub fn SkDrawLooper_Context_Info_applyToCTM(
        this: *const SkDrawLooper_Context_Info,
        ctm: *mut SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkDrawLooper7Context4Info13applyToCanvasEP8SkCanvas"]
    pub fn SkDrawLooper_Context_Info_applyToCanvas(
        this: *const SkDrawLooper_Context_Info,
        arg1: *mut SkCanvas,
    );
}
impl SkDrawLooper_Context_Info {
    #[inline]
    pub unsafe fn applyToCTM(&self, ctm: *mut SkMatrix) {
        SkDrawLooper_Context_Info_applyToCTM(self, ctm)
    }
    #[inline]
    pub unsafe fn applyToCanvas(&self, arg1: *mut SkCanvas) {
        SkDrawLooper_Context_Info_applyToCanvas(self, arg1)
    }
}
#[test]
fn bindgen_test_layout_SkDrawLooper_Context() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawLooper_Context>(),
        8usize,
        concat!("Size of: ", stringify!(SkDrawLooper_Context))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawLooper_Context>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawLooper_Context))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawLooper_BlurShadowRec {
    pub fSigma: SkScalar,
    pub fOffset: SkVector,
    pub fColor: SkColor,
    pub fStyle: SkBlurStyle,
}
#[test]
fn bindgen_test_layout_SkDrawLooper_BlurShadowRec() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawLooper_BlurShadowRec>(),
        20usize,
        concat!("Size of: ", stringify!(SkDrawLooper_BlurShadowRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawLooper_BlurShadowRec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDrawLooper_BlurShadowRec))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_BlurShadowRec>())).fSigma as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_BlurShadowRec),
            "::",
            stringify!(fSigma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_BlurShadowRec>())).fOffset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_BlurShadowRec),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_BlurShadowRec>())).fColor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_BlurShadowRec),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkDrawLooper_BlurShadowRec>())).fStyle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDrawLooper_BlurShadowRec),
            "::",
            stringify!(fStyle)
        )
    );
}
pub type SkDrawLooper_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkDrawLooper() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawLooper>(),
        16usize,
        concat!("Size of: ", stringify!(SkDrawLooper))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawLooper>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawLooper))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkDrawLooper20canComputeFastBoundsERK7SkPaint"]
    pub fn SkDrawLooper_canComputeFastBounds(
        this: *const SkDrawLooper,
        paint: *const SkPaint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkDrawLooper17computeFastBoundsERK7SkPaintRK6SkRectPS3_"]
    pub fn SkDrawLooper_computeFastBounds(
        this: *const SkDrawLooper,
        paint: *const SkPaint,
        src: *const SkRect,
        dst: *mut SkRect,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkDrawLooper5applyEP8SkCanvasRK7SkPaintSt8functionIFvS1_S4_EE"]
    pub fn SkDrawLooper_apply(
        this: *mut SkDrawLooper,
        canvas: *mut SkCanvas,
        paint: *const SkPaint,
        arg1: u8,
    );
}
impl SkDrawLooper {
    #[inline]
    pub unsafe fn canComputeFastBounds(&self, paint: *const SkPaint) -> bool {
        SkDrawLooper_canComputeFastBounds(self, paint)
    }
    #[inline]
    pub unsafe fn computeFastBounds(
        &self,
        paint: *const SkPaint,
        src: *const SkRect,
        dst: *mut SkRect,
    ) {
        SkDrawLooper_computeFastBounds(self, paint, src, dst)
    }
    #[inline]
    pub unsafe fn apply(&mut self, canvas: *mut SkCanvas, paint: *const SkPaint, arg1: u8) {
        SkDrawLooper_apply(self, canvas, paint, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkDrawLooper13asABlurShadowEPNS_13BlurShadowRecE"]
    pub fn SkDrawLooper_asABlurShadow(
        this: *mut ::core::ffi::c_void,
        arg1: *mut SkDrawLooper_BlurShadowRec,
    ) -> bool;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable_GpuDrawHandler {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkDrawable_GpuDrawHandler() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Size of: ", stringify!(SkDrawable_GpuDrawHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable_GpuDrawHandler))
    );
}
#[test]
fn bindgen_test_layout_SkDrawable() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable>(),
        16usize,
        concat!("Size of: ", stringify!(SkDrawable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable4drawEP8SkCanvasPK8SkMatrix"]
    pub fn SkDrawable_draw(this: *mut SkDrawable, arg1: *mut SkCanvas, arg2: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable4drawEP8SkCanvasff"]
    pub fn SkDrawable_draw1(this: *mut SkDrawable, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable18newPictureSnapshotEv"]
    pub fn SkDrawable_newPictureSnapshot(this: *mut SkDrawable) -> *mut SkPicture;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable15getGenerationIDEv"]
    pub fn SkDrawable_getGenerationID(this: *mut SkDrawable) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable9getBoundsEv"]
    pub fn SkDrawable_getBounds(this: *mut SkDrawable) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable20notifyDrawingChangedEv"]
    pub fn SkDrawable_notifyDrawingChanged(this: *mut SkDrawable);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawableC2Ev"]
    pub fn SkDrawable_SkDrawable(this: *mut SkDrawable);
}
impl SkDrawable {
    #[inline]
    pub unsafe fn draw(&mut self, arg1: *mut SkCanvas, arg2: *const SkMatrix) {
        SkDrawable_draw(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn draw1(&mut self, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar) {
        SkDrawable_draw1(self, arg1, x, y)
    }
    #[inline]
    pub unsafe fn newPictureSnapshot(&mut self) -> *mut SkPicture {
        SkDrawable_newPictureSnapshot(self)
    }
    #[inline]
    pub unsafe fn getGenerationID(&mut self) -> u32 {
        SkDrawable_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn getBounds(&mut self) -> SkRect {
        SkDrawable_getBounds(self)
    }
    #[inline]
    pub unsafe fn notifyDrawingChanged(&mut self) {
        SkDrawable_notifyDrawingChanged(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDrawable_SkDrawable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDrawable20onNewPictureSnapshotEv"]
    pub fn SkDrawable_onNewPictureSnapshot(this: *mut ::core::ffi::c_void) -> *mut SkPicture;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDocument {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDocument_State {
    kBetweenPages_State = 0,
    kInPage_State = 1,
    kClosed_State = 2,
}
pub type SkDocument_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDocument() {
    assert_eq!(
        ::core::mem::size_of::<SkDocument>(),
        32usize,
        concat!("Size of: ", stringify!(SkDocument))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDocument>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDocument))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocument9beginPageEffPK6SkRect"]
    pub fn SkDocument_beginPage(
        this: *mut SkDocument,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocument7endPageEv"]
    pub fn SkDocument_endPage(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocument5closeEv"]
    pub fn SkDocument_close(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocument5abortEv"]
    pub fn SkDocument_abort(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocumentC2EP9SkWStream"]
    pub fn SkDocument_SkDocument(this: *mut SkDocument, arg1: *mut SkWStream);
}
impl SkDocument {
    #[inline]
    pub unsafe fn beginPage(
        &mut self,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas {
        SkDocument_beginPage(self, width, height, content)
    }
    #[inline]
    pub unsafe fn endPage(&mut self) {
        SkDocument_endPage(self)
    }
    #[inline]
    pub unsafe fn close(&mut self) {
        SkDocument_close(self)
    }
    #[inline]
    pub unsafe fn abort(&mut self) {
        SkDocument_abort(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDocument_SkDocument(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkDocumentD1Ev"]
    pub fn SkDocument_SkDocument_destructor(this: *mut SkDocument);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments {
    pub fCollectionIndex: ::std::os::raw::c_int,
    pub fVariationDesignPosition: SkFontArguments_VariationPosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition {
    pub coordinates: *const SkFontArguments_VariationPosition_Coordinate,
    pub coordinateCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition_Coordinate {
    pub axis: SkFourByteTag,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition_Coordinate() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition_Coordinate>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition_Coordinate>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments_VariationPosition_Coordinate>())).axis
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments_VariationPosition_Coordinate>())).value
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontArguments_VariationPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments_VariationPosition>())).coordinates as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition),
            "::",
            stringify!(coordinates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments_VariationPosition>())).coordinateCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition),
            "::",
            stringify!(coordinateCount)
        )
    );
}
#[test]
fn bindgen_test_layout_SkFontArguments() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments>(),
        24usize,
        concat!("Size of: ", stringify!(SkFontArguments))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontArguments))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments>())).fCollectionIndex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments),
            "::",
            stringify!(fCollectionIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontArguments>())).fVariationDesignPosition as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments),
            "::",
            stringify!(fVariationDesignPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontParameters_Variation_Axis {
    pub tag: SkFourByteTag,
    pub min: f32,
    pub def: f32,
    pub max: f32,
    pub flags: u16,
}
pub const SkFontParameters_Variation_Axis_HIDDEN: u16 = 1;
#[test]
fn bindgen_test_layout_SkFontParameters_Variation_Axis() {
    assert_eq!(
        ::core::mem::size_of::<SkFontParameters_Variation_Axis>(),
        20usize,
        concat!("Size of: ", stringify!(SkFontParameters_Variation_Axis))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontParameters_Variation_Axis>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontParameters_Variation_Axis))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontParameters_Variation_Axis>())).tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontParameters_Variation_Axis>())).min as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontParameters_Variation_Axis>())).def as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontParameters_Variation_Axis>())).max as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontParameters_Variation_Axis>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyle {
    pub fValue: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Weight {
    kInvisible_Weight = 0,
    kThin_Weight = 100,
    kExtraLight_Weight = 200,
    kLight_Weight = 300,
    kNormal_Weight = 400,
    kMedium_Weight = 500,
    kSemiBold_Weight = 600,
    kBold_Weight = 700,
    kExtraBold_Weight = 800,
    kBlack_Weight = 900,
    kExtraBlack_Weight = 1000,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Width {
    kUltraCondensed_Width = 1,
    kExtraCondensed_Width = 2,
    kCondensed_Width = 3,
    kSemiCondensed_Width = 4,
    kNormal_Width = 5,
    kSemiExpanded_Width = 6,
    kExpanded_Width = 7,
    kExtraExpanded_Width = 8,
    kUltraExpanded_Width = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Slant {
    Upright = 0,
    Italic = 1,
    Oblique = 2,
}
#[test]
fn bindgen_test_layout_SkFontStyle() {
    assert_eq!(
        ::core::mem::size_of::<SkFontStyle>(),
        4usize,
        concat!("Size of: ", stringify!(SkFontStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyle>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontStyle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontStyle>())).fValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontStyle),
            "::",
            stringify!(fValue)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWeakRefCnt {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkWeakRefCnt_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkWeakRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkWeakRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkWeakRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWeakRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWeakRefCnt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkAdvancedTypefaceMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextEffects {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextRec {
    _unused: [u8; 0],
}
pub type SkFontID = u32;
pub type SkFontTableTag = u32;
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface {
    pub _base: SkWeakRefCnt,
    pub fUniqueID: SkFontID,
    pub fStyle: SkFontStyle,
    pub fBounds: SkRect,
    pub fBoundsOnce: SkOnce,
    pub fIsFixedPitch: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_SerializeBehavior {
    DoIncludeData = 0,
    DontIncludeData = 1,
    IncludeDataIfLocal = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface_LocalizedString {
    pub fString: SkString,
    pub fLanguage: SkString,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedString() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedString>(),
        16usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedString))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTypeface_LocalizedString>())).fString as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface_LocalizedString),
            "::",
            stringify!(fString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTypeface_LocalizedString>())).fLanguage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface_LocalizedString),
            "::",
            stringify!(fLanguage)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkTypeface_LocalizedStrings {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedStrings() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedStrings))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_Style {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldItalic = 3,
}
pub type SkTypeface_INHERITED = SkWeakRefCnt;
#[test]
fn bindgen_test_layout_SkTypeface() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface>(),
        48usize,
        concat!("Size of: ", stringify!(SkTypeface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTypeface>())).fUniqueID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTypeface>())).fStyle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTypeface>())).fBounds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTypeface>())).fBoundsOnce as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fBoundsOnce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTypeface>())).fIsFixedPitch as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fIsFixedPitch)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface26getVariationDesignPositionEPN15SkFontArguments17VariationPosition10CoordinateEi"]
    pub fn SkTypeface_getVariationDesignPosition(
        this: *const SkTypeface,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface28getVariationDesignParametersEPN16SkFontParameters9Variation4AxisEi"]
    pub fn SkTypeface_getVariationDesignParameters(
        this: *const SkTypeface,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface8UniqueIDEPKS_"]
    pub fn SkTypeface_UniqueID(face: *const SkTypeface) -> SkFontID;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface5EqualEPKS_S1_"]
    pub fn SkTypeface_Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface11MakeDefaultEv"]
    pub fn SkTypeface_MakeDefault() -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface12MakeFromNameEPKc11SkFontStyle"]
    pub fn SkTypeface_MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface12MakeFromFileEPKci"]
    pub fn SkTypeface_MakeFromFile(
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface14MakeFromStreamESt10unique_ptrI13SkStreamAssetSt14default_deleteIS1_EEi"]
    pub fn SkTypeface_MakeFromStream(
        stream: u64,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface12MakeFromDataE5sk_spI6SkDataEi"]
    pub fn SkTypeface_MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface9makeCloneERK15SkFontArguments"]
    pub fn SkTypeface_makeClone(
        this: *const SkTypeface,
        arg1: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface9serializeEP9SkWStreamNS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize(
        this: *const SkTypeface,
        arg1: *mut SkWStream,
        arg2: SkTypeface_SerializeBehavior,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface9serializeENS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize1(
        this: *const SkTypeface,
        arg1: SkTypeface_SerializeBehavior,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypeface15MakeDeserializeEP8SkStream"]
    pub fn SkTypeface_MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface16unicharsToGlyphsEPKiiPt"]
    pub fn SkTypeface_unicharsToGlyphs(
        this: *const SkTypeface,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface14unicharToGlyphEi"]
    pub fn SkTypeface_unicharToGlyph(this: *const SkTypeface, unichar: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface11countGlyphsEv"]
    pub fn SkTypeface_countGlyphs(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface11countTablesEv"]
    pub fn SkTypeface_countTables(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface12getTableTagsEPj"]
    pub fn SkTypeface_getTableTags(
        this: *const SkTypeface,
        tags: *mut SkFontTableTag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface12getTableSizeEj"]
    pub fn SkTypeface_getTableSize(this: *const SkTypeface, arg1: SkFontTableTag) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface12getTableDataEjmmPv"]
    pub fn SkTypeface_getTableData(
        this: *const SkTypeface,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface13copyTableDataEj"]
    pub fn SkTypeface_copyTableData(this: *const SkTypeface, tag: SkFontTableTag) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface13getUnitsPerEmEv"]
    pub fn SkTypeface_getUnitsPerEm(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface25getKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_getKerningPairAdjustments(
        this: *const SkTypeface,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface24createFamilyNameIteratorEv"]
    pub fn SkTypeface_createFamilyNameIterator(
        this: *const SkTypeface,
    ) -> *mut SkTypeface_LocalizedStrings;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface13getFamilyNameEP8SkString"]
    pub fn SkTypeface_getFamilyName(this: *const SkTypeface, name: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface17getPostScriptNameEP8SkString"]
    pub fn SkTypeface_getPostScriptName(this: *const SkTypeface, name: *mut SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface10openStreamEPi"]
    pub fn SkTypeface_openStream(
        this: *const SkTypeface,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface19createScalerContextERK22SkScalerContextEffectsPK12SkDescriptor"]
    pub fn SkTypeface_createScalerContext(
        this: *const SkTypeface,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface9getBoundsEv"]
    pub fn SkTypeface_getBounds(this: *const SkTypeface) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypefaceC2ERK11SkFontStyleb"]
    pub fn SkTypeface_SkTypeface(
        this: *mut SkTypeface,
        style: *const SkFontStyle,
        isFixedPitch: bool,
    );
}
impl SkTypeface {
    #[inline]
    pub unsafe fn getVariationDesignPosition(
        &self,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkTypeface_getVariationDesignPosition(self, coordinates, coordinateCount)
    }
    #[inline]
    pub unsafe fn getVariationDesignParameters(
        &self,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkTypeface_getVariationDesignParameters(self, parameters, parameterCount)
    }
    #[inline]
    pub unsafe fn UniqueID(face: *const SkTypeface) -> SkFontID {
        SkTypeface_UniqueID(face)
    }
    #[inline]
    pub unsafe fn Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool {
        SkTypeface_Equal(facea, faceb)
    }
    #[inline]
    pub unsafe fn MakeDefault() -> sk_sp<SkTypeface> {
        SkTypeface_MakeDefault()
    }
    #[inline]
    pub unsafe fn MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromName(familyName, fontStyle)
    }
    #[inline]
    pub unsafe fn MakeFromFile(
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromFile(path, index)
    }
    #[inline]
    pub unsafe fn MakeFromStream(stream: u64, index: ::std::os::raw::c_int) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromStream(stream, index)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromData(arg1, index)
    }
    #[inline]
    pub unsafe fn makeClone(&self, arg1: *const SkFontArguments) -> sk_sp<SkTypeface> {
        SkTypeface_makeClone(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkWStream, arg2: SkTypeface_SerializeBehavior) {
        SkTypeface_serialize(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn serialize1(&self, arg1: SkTypeface_SerializeBehavior) -> sk_sp<SkData> {
        SkTypeface_serialize1(self, arg1)
    }
    #[inline]
    pub unsafe fn MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface> {
        SkTypeface_MakeDeserialize(arg1)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkTypeface_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, unichar: SkUnichar) -> SkGlyphID {
        SkTypeface_unicharToGlyph(self, unichar)
    }
    #[inline]
    pub unsafe fn countGlyphs(&self) -> ::std::os::raw::c_int {
        SkTypeface_countGlyphs(self)
    }
    #[inline]
    pub unsafe fn countTables(&self) -> ::std::os::raw::c_int {
        SkTypeface_countTables(self)
    }
    #[inline]
    pub unsafe fn getTableTags(&self, tags: *mut SkFontTableTag) -> ::std::os::raw::c_int {
        SkTypeface_getTableTags(self, tags)
    }
    #[inline]
    pub unsafe fn getTableSize(&self, arg1: SkFontTableTag) -> usize {
        SkTypeface_getTableSize(self, arg1)
    }
    #[inline]
    pub unsafe fn getTableData(
        &self,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize {
        SkTypeface_getTableData(self, tag, offset, length, data)
    }
    #[inline]
    pub unsafe fn copyTableData(&self, tag: SkFontTableTag) -> sk_sp<SkData> {
        SkTypeface_copyTableData(self, tag)
    }
    #[inline]
    pub unsafe fn getUnitsPerEm(&self) -> ::std::os::raw::c_int {
        SkTypeface_getUnitsPerEm(self)
    }
    #[inline]
    pub unsafe fn getKerningPairAdjustments(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool {
        SkTypeface_getKerningPairAdjustments(self, glyphs, count, adjustments)
    }
    #[inline]
    pub unsafe fn createFamilyNameIterator(&self) -> *mut SkTypeface_LocalizedStrings {
        SkTypeface_createFamilyNameIterator(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, name: *mut SkString) {
        SkTypeface_getFamilyName(self, name)
    }
    #[inline]
    pub unsafe fn getPostScriptName(&self, name: *mut SkString) -> bool {
        SkTypeface_getPostScriptName(self, name)
    }
    #[inline]
    pub unsafe fn openStream(&self, ttcIndex: *mut ::std::os::raw::c_int) -> u64 {
        SkTypeface_openStream(self, ttcIndex)
    }
    #[inline]
    pub unsafe fn createScalerContext(
        &self,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8 {
        SkTypeface_createScalerContext(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> SkRect {
        SkTypeface_getBounds(self)
    }
    #[inline]
    pub unsafe fn new(style: *const SkFontStyle, isFixedPitch: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTypeface_SkTypeface(__bindgen_tmp.as_mut_ptr(), style, isFixedPitch);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTypefaceD1Ev"]
    pub fn SkTypeface_SkTypeface_destructor(this: *mut SkTypeface);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface27onGetKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_onGetKerningPairAdjustments(
        this: *mut ::core::ffi::c_void,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface15onCopyTableDataEj"]
    pub fn SkTypeface_onCopyTableData(
        this: *mut ::core::ffi::c_void,
        arg1: SkFontTableTag,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTypeface15onComputeBoundsEP6SkRect"]
    pub fn SkTypeface_onComputeBounds(this: *mut ::core::ffi::c_void, arg1: *mut SkRect) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkFont {
    pub fTypeface: sk_sp<SkTypeface>,
    pub fSize: SkScalar,
    pub fScaleX: SkScalar,
    pub fSkewX: SkScalar,
    pub fFlags: u8,
    pub fEdging: u8,
    pub fHinting: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFont_Edging {
    Alias = 0,
    AntiAlias = 1,
    SubpixelAntiAlias = 2,
}
pub const SkFont_PrivFlags_kForceAutoHinting_PrivFlag: SkFont_PrivFlags = 1;
pub const SkFont_PrivFlags_kEmbeddedBitmaps_PrivFlag: SkFont_PrivFlags = 2;
pub const SkFont_PrivFlags_kSubpixel_PrivFlag: SkFont_PrivFlags = 4;
pub const SkFont_PrivFlags_kLinearMetrics_PrivFlag: SkFont_PrivFlags = 8;
pub const SkFont_PrivFlags_kEmbolden_PrivFlag: SkFont_PrivFlags = 16;
pub const SkFont_PrivFlags_kBaselineSnap_PrivFlag: SkFont_PrivFlags = 32;
pub type SkFont_PrivFlags = ::std::os::raw::c_uint;
pub const SkFont_kAllFlags: ::std::os::raw::c_uint = 63;
#[test]
fn bindgen_test_layout_SkFont() {
    assert_eq!(
        ::core::mem::size_of::<SkFont>(),
        24usize,
        concat!("Size of: ", stringify!(SkFont))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFont>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFont))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fTypeface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fTypeface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fScaleX as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fScaleX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fSkewX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fSkewX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fFlags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fEdging as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fEdging)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFont>())).fHinting as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fHinting)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont19setForceAutoHintingEb"]
    pub fn SkFont_setForceAutoHinting(this: *mut SkFont, forceAutoHinting: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont18setEmbeddedBitmapsEb"]
    pub fn SkFont_setEmbeddedBitmaps(this: *mut SkFont, embeddedBitmaps: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont11setSubpixelEb"]
    pub fn SkFont_setSubpixel(this: *mut SkFont, subpixel: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont16setLinearMetricsEb"]
    pub fn SkFont_setLinearMetrics(this: *mut SkFont, linearMetrics: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont11setEmboldenEb"]
    pub fn SkFont_setEmbolden(this: *mut SkFont, embolden: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont15setBaselineSnapEb"]
    pub fn SkFont_setBaselineSnap(this: *mut SkFont, baselineSnap: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont9setEdgingENS_6EdgingE"]
    pub fn SkFont_setEdging(this: *mut SkFont, edging: SkFont_Edging);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont10setHintingE13SkFontHinting"]
    pub fn SkFont_setHinting(this: *mut SkFont, hintingLevel: SkFontHinting);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont12makeWithSizeEf"]
    pub fn SkFont_makeWithSize(this: *const SkFont, size: SkScalar) -> SkFont;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont20getTypefaceOrDefaultEv"]
    pub fn SkFont_getTypefaceOrDefault(this: *const SkFont) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont20refTypefaceOrDefaultEv"]
    pub fn SkFont_refTypefaceOrDefault(this: *const SkFont) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont7setSizeEf"]
    pub fn SkFont_setSize(this: *mut SkFont, textSize: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont9setScaleXEf"]
    pub fn SkFont_setScaleX(this: *mut SkFont, scaleX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFont8setSkewXEf"]
    pub fn SkFont_setSkewX(this: *mut SkFont, skewX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont12textToGlyphsEPKvm14SkTextEncodingPti"]
    pub fn SkFont_textToGlyphs(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont14unicharToGlyphEi"]
    pub fn SkFont_unicharToGlyph(this: *const SkFont, uni: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont16unicharsToGlyphsEPKiiPt"]
    pub fn SkFont_unicharsToGlyphs(
        this: *const SkFont,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont11measureTextEPKvm14SkTextEncodingP6SkRectPK7SkPaint"]
    pub fn SkFont_measureText(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont15getWidthsBoundsEPKtiPfP6SkRectPK7SkPaint"]
    pub fn SkFont_getWidthsBounds(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont6getPosEPKtiP7SkPointS2_"]
    pub fn SkFont_getPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont7getXPosEPKtiPff"]
    pub fn SkFont_getXPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont7getPathEtP6SkPath"]
    pub fn SkFont_getPath(this: *const SkFont, glyphID: SkGlyphID, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont8getPathsEPKtiPFvPK6SkPathRK8SkMatrixPvES8_"]
    pub fn SkFont_getPaths(
        this: *const SkFont,
        glyphIDs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont10getMetricsEP13SkFontMetrics"]
    pub fn SkFont_getMetrics(this: *const SkFont, metrics: *mut SkFontMetrics) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkFont4dumpEv"]
    pub fn SkFont_dump(this: *const SkFont);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFontC1Ev"]
    pub fn SkFont_SkFont(this: *mut SkFont);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFontC1E5sk_spI10SkTypefaceEf"]
    pub fn SkFont_SkFont1(this: *mut SkFont, typeface: sk_sp<SkTypeface>, size: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFontC1E5sk_spI10SkTypefaceE"]
    pub fn SkFont_SkFont2(this: *mut SkFont, typeface: sk_sp<SkTypeface>);
}
extern "C" {
    #[link_name = "\u{1}_ZN6SkFontC1E5sk_spI10SkTypefaceEfff"]
    pub fn SkFont_SkFont3(
        this: *mut SkFont,
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
impl SkFont {
    #[inline]
    pub unsafe fn setForceAutoHinting(&mut self, forceAutoHinting: bool) {
        SkFont_setForceAutoHinting(self, forceAutoHinting)
    }
    #[inline]
    pub unsafe fn setEmbeddedBitmaps(&mut self, embeddedBitmaps: bool) {
        SkFont_setEmbeddedBitmaps(self, embeddedBitmaps)
    }
    #[inline]
    pub unsafe fn setSubpixel(&mut self, subpixel: bool) {
        SkFont_setSubpixel(self, subpixel)
    }
    #[inline]
    pub unsafe fn setLinearMetrics(&mut self, linearMetrics: bool) {
        SkFont_setLinearMetrics(self, linearMetrics)
    }
    #[inline]
    pub unsafe fn setEmbolden(&mut self, embolden: bool) {
        SkFont_setEmbolden(self, embolden)
    }
    #[inline]
    pub unsafe fn setBaselineSnap(&mut self, baselineSnap: bool) {
        SkFont_setBaselineSnap(self, baselineSnap)
    }
    #[inline]
    pub unsafe fn setEdging(&mut self, edging: SkFont_Edging) {
        SkFont_setEdging(self, edging)
    }
    #[inline]
    pub unsafe fn setHinting(&mut self, hintingLevel: SkFontHinting) {
        SkFont_setHinting(self, hintingLevel)
    }
    #[inline]
    pub unsafe fn makeWithSize(&self, size: SkScalar) -> SkFont {
        SkFont_makeWithSize(self, size)
    }
    #[inline]
    pub unsafe fn getTypefaceOrDefault(&self) -> *mut SkTypeface {
        SkFont_getTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn refTypefaceOrDefault(&self) -> sk_sp<SkTypeface> {
        SkFont_refTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn setSize(&mut self, textSize: SkScalar) {
        SkFont_setSize(self, textSize)
    }
    #[inline]
    pub unsafe fn setScaleX(&mut self, scaleX: SkScalar) {
        SkFont_setScaleX(self, scaleX)
    }
    #[inline]
    pub unsafe fn setSkewX(&mut self, skewX: SkScalar) {
        SkFont_setSkewX(self, skewX)
    }
    #[inline]
    pub unsafe fn textToGlyphs(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkFont_textToGlyphs(self, text, byteLength, encoding, glyphs, maxGlyphCount)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, uni: SkUnichar) -> SkGlyphID {
        SkFont_unicharToGlyph(self, uni)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkFont_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn measureText(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar {
        SkFont_measureText(self, text, byteLength, encoding, bounds, paint)
    }
    #[inline]
    pub unsafe fn getWidthsBounds(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) {
        SkFont_getWidthsBounds(self, glyphs, count, widths, bounds, paint)
    }
    #[inline]
    pub unsafe fn getPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    ) {
        SkFont_getPos(self, glyphs, count, pos, origin)
    }
    #[inline]
    pub unsafe fn getXPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    ) {
        SkFont_getXPos(self, glyphs, count, xpos, origin)
    }
    #[inline]
    pub unsafe fn getPath(&self, glyphID: SkGlyphID, path: *mut SkPath) -> bool {
        SkFont_getPath(self, glyphID, path)
    }
    #[inline]
    pub unsafe fn getPaths(
        &self,
        glyphIDs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    ) {
        SkFont_getPaths(self, glyphIDs, count, glyphPathProc, ctx)
    }
    #[inline]
    pub unsafe fn getMetrics(&self, metrics: *mut SkFontMetrics) -> SkScalar {
        SkFont_getMetrics(self, metrics)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkFont_dump(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(typeface: sk_sp<SkTypeface>, size: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont1(__bindgen_tmp.as_mut_ptr(), typeface, size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(typeface: sk_sp<SkTypeface>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont2(__bindgen_tmp.as_mut_ptr(), typeface);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont3(__bindgen_tmp.as_mut_ptr(), typeface, size, scaleX, skewX);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMetrics {
    pub fFlags: u32,
    pub fTop: SkScalar,
    pub fAscent: SkScalar,
    pub fDescent: SkScalar,
    pub fBottom: SkScalar,
    pub fLeading: SkScalar,
    pub fAvgCharWidth: SkScalar,
    pub fMaxCharWidth: SkScalar,
    pub fXMin: SkScalar,
    pub fXMax: SkScalar,
    pub fXHeight: SkScalar,
    pub fCapHeight: SkScalar,
    pub fUnderlineThickness: SkScalar,
    pub fUnderlinePosition: SkScalar,
    pub fStrikeoutThickness: SkScalar,
    pub fStrikeoutPosition: SkScalar,
}
pub const SkFontMetrics_FontMetricsFlags_kUnderlineThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 1;
pub const SkFontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 2;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 4;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutPositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 8;
pub const SkFontMetrics_FontMetricsFlags_kBoundsInvalid_Flag: SkFontMetrics_FontMetricsFlags = 16;
pub type SkFontMetrics_FontMetricsFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkFontMetrics() {
    assert_eq!(
        ::core::mem::size_of::<SkFontMetrics>(),
        64usize,
        concat!("Size of: ", stringify!(SkFontMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMetrics>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontMetrics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fTop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fAscent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fAscent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fDescent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fDescent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fBottom as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fBottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fLeading as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fLeading)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fAvgCharWidth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fAvgCharWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fMaxCharWidth as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fMaxCharWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fXMin as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fXMax as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fXHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkFontMetrics>())).fCapHeight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fCapHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontMetrics>())).fUnderlineThickness as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fUnderlineThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontMetrics>())).fUnderlinePosition as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fUnderlinePosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontMetrics>())).fStrikeoutThickness as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fStrikeoutThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkFontMetrics>())).fStrikeoutPosition as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fStrikeoutPosition)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyleSet {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkFontStyleSet_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFontStyleSet() {
    assert_eq!(
        ::core::mem::size_of::<SkFontStyleSet>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontStyleSet))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyleSet>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontStyleSet))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkFontStyleSet11CreateEmptyEv"]
    pub fn SkFontStyleSet_CreateEmpty() -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkFontStyleSet14matchStyleCSS3ERK11SkFontStyle"]
    pub fn SkFontStyleSet_matchStyleCSS3(
        this: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
impl SkFontStyleSet {
    #[inline]
    pub unsafe fn CreateEmpty() -> *mut SkFontStyleSet {
        SkFontStyleSet_CreateEmpty()
    }
    #[inline]
    pub unsafe fn matchStyleCSS3(&mut self, pattern: *const SkFontStyle) -> *mut SkTypeface {
        SkFontStyleSet_matchStyleCSS3(self, pattern)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMgr {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkFontMgr_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFontMgr() {
    assert_eq!(
        ::core::mem::size_of::<SkFontMgr>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontMgr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontMgr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr13countFamiliesEv"]
    pub fn SkFontMgr_countFamilies(this: *const SkFontMgr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr13getFamilyNameEiP8SkString"]
    pub fn SkFontMgr_getFamilyName(
        this: *const SkFontMgr,
        index: ::std::os::raw::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr14createStyleSetEi"]
    pub fn SkFontMgr_createStyleSet(
        this: *const SkFontMgr,
        index: ::std::os::raw::c_int,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr11matchFamilyEPKc"]
    pub fn SkFontMgr_matchFamily(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr16matchFamilyStyleEPKcRK11SkFontStyle"]
    pub fn SkFontMgr_matchFamilyStyle(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr25matchFamilyStyleCharacterEPKcRK11SkFontStylePS1_ii"]
    pub fn SkFontMgr_matchFamilyStyleCharacter(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr12makeFromDataE5sk_spI6SkDataEi"]
    pub fn SkFontMgr_makeFromData(
        this: *const SkFontMgr,
        arg1: sk_sp<SkData>,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr14makeFromStreamESt10unique_ptrI13SkStreamAssetSt14default_deleteIS1_EEi"]
    pub fn SkFontMgr_makeFromStream(
        this: *const SkFontMgr,
        arg1: u64,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr14makeFromStreamESt10unique_ptrI13SkStreamAssetSt14default_deleteIS1_EERK15SkFontArguments"]
    pub fn SkFontMgr_makeFromStream1(
        this: *const SkFontMgr,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr16makeFromFontDataESt10unique_ptrI10SkFontDataSt14default_deleteIS1_EE"]
    pub fn SkFontMgr_makeFromFontData(this: *const SkFontMgr, arg1: u8) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr12makeFromFileEPKci"]
    pub fn SkFontMgr_makeFromFile(
        this: *const SkFontMgr,
        path: *const ::std::os::raw::c_char,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr18legacyMakeTypefaceEPKc11SkFontStyle"]
    pub fn SkFontMgr_legacyMakeTypeface(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkFontMgr10RefDefaultEv"]
    pub fn SkFontMgr_RefDefault() -> sk_sp<SkFontMgr>;
}
impl SkFontMgr {
    #[inline]
    pub unsafe fn countFamilies(&self) -> ::std::os::raw::c_int {
        SkFontMgr_countFamilies(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, index: ::std::os::raw::c_int, familyName: *mut SkString) {
        SkFontMgr_getFamilyName(self, index, familyName)
    }
    #[inline]
    pub unsafe fn createStyleSet(&self, index: ::std::os::raw::c_int) -> *mut SkFontStyleSet {
        SkFontMgr_createStyleSet(self, index)
    }
    #[inline]
    pub unsafe fn matchFamily(
        &self,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut SkFontStyleSet {
        SkFontMgr_matchFamily(self, familyName)
    }
    #[inline]
    pub unsafe fn matchFamilyStyle(
        &self,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
    ) -> *mut SkTypeface {
        SkFontMgr_matchFamilyStyle(self, familyName, arg1)
    }
    #[inline]
    pub unsafe fn matchFamilyStyleCharacter(
        &self,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface {
        SkFontMgr_matchFamilyStyleCharacter(self, familyName, arg1, bcp47, bcp47Count, character)
    }
    #[inline]
    pub unsafe fn makeFromData(
        &self,
        arg1: sk_sp<SkData>,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromData(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream(
        &self,
        arg1: u64,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream1(
        &self,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn makeFromFontData(&self, arg1: u8) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromFontData(self, arg1)
    }
    #[inline]
    pub unsafe fn makeFromFile(
        &self,
        path: *const ::std::os::raw::c_char,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromFile(self, path, ttcIndex)
    }
    #[inline]
    pub unsafe fn legacyMakeTypeface(
        &self,
        familyName: *const ::std::os::raw::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_legacyMakeTypeface(self, familyName, style)
    }
    #[inline]
    pub unsafe fn RefDefault() -> sk_sp<SkFontMgr> {
        SkFontMgr_RefDefault()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkFontMgr18onMakeFromFontDataESt10unique_ptrI10SkFontDataSt14default_deleteIS1_EE"]
    pub fn SkFontMgr_onMakeFromFontData(
        this: *mut ::core::ffi::c_void,
        arg1: u8,
    ) -> sk_sp<SkTypeface>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTraceMemoryDump {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGraphics {
    pub _address: u8,
}
pub type SkGraphics_ImageGeneratorFromEncodedDataFactory =
    ::core::option::Option<unsafe extern "C" fn(arg1: sk_sp<SkData>) -> u64>;
#[test]
fn bindgen_test_layout_SkGraphics() {
    assert_eq!(
        ::core::mem::size_of::<SkGraphics>(),
        1usize,
        concat!("Size of: ", stringify!(SkGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGraphics>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGraphics))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics4InitEv"]
    pub fn SkGraphics_Init();
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics17GetFontCacheLimitEv"]
    pub fn SkGraphics_GetFontCacheLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics17SetFontCacheLimitEm"]
    pub fn SkGraphics_SetFontCacheLimit(bytes: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics16GetFontCacheUsedEv"]
    pub fn SkGraphics_GetFontCacheUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics21GetFontCacheCountUsedEv"]
    pub fn SkGraphics_GetFontCacheCountUsed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics22GetFontCacheCountLimitEv"]
    pub fn SkGraphics_GetFontCacheCountLimit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics22SetFontCacheCountLimitEi"]
    pub fn SkGraphics_SetFontCacheCountLimit(count: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics26GetFontCachePointSizeLimitEv"]
    pub fn SkGraphics_GetFontCachePointSizeLimit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics26SetFontCachePointSizeLimitEi"]
    pub fn SkGraphics_SetFontCachePointSizeLimit(
        maxPointSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics14PurgeFontCacheEv"]
    pub fn SkGraphics_PurgeFontCache();
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics30GetResourceCacheTotalBytesUsedEv"]
    pub fn SkGraphics_GetResourceCacheTotalBytesUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics30GetResourceCacheTotalByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheTotalByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics30SetResourceCacheTotalByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheTotalByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics18PurgeResourceCacheEv"]
    pub fn SkGraphics_PurgeResourceCache();
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics41GetResourceCacheSingleAllocationByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheSingleAllocationByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics41SetResourceCacheSingleAllocationByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics20DumpMemoryStatisticsEP17SkTraceMemoryDump"]
    pub fn SkGraphics_DumpMemoryStatistics(dump: *mut SkTraceMemoryDump);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics14PurgeAllCachesEv"]
    pub fn SkGraphics_PurgeAllCaches();
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics8SetFlagsEPKc"]
    pub fn SkGraphics_SetFlags(flags: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics39SetImageGeneratorFromEncodedDataFactoryEPFSt10unique_ptrI16SkImageGeneratorSt14default_deleteIS1_EE5sk_spI6SkDataEE"]
    pub fn SkGraphics_SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkGraphics8AllowJITEv"]
    pub fn SkGraphics_AllowJIT();
}
impl SkGraphics {
    #[inline]
    pub unsafe fn Init() {
        SkGraphics_Init()
    }
    #[inline]
    pub unsafe fn GetFontCacheLimit() -> usize {
        SkGraphics_GetFontCacheLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheLimit(bytes: usize) -> usize {
        SkGraphics_SetFontCacheLimit(bytes)
    }
    #[inline]
    pub unsafe fn GetFontCacheUsed() -> usize {
        SkGraphics_GetFontCacheUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountUsed() -> ::std::os::raw::c_int {
        SkGraphics_GetFontCacheCountUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountLimit() -> ::std::os::raw::c_int {
        SkGraphics_GetFontCacheCountLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheCountLimit(count: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        SkGraphics_SetFontCacheCountLimit(count)
    }
    #[inline]
    pub unsafe fn GetFontCachePointSizeLimit() -> ::std::os::raw::c_int {
        SkGraphics_GetFontCachePointSizeLimit()
    }
    #[inline]
    pub unsafe fn SetFontCachePointSizeLimit(
        maxPointSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkGraphics_SetFontCachePointSizeLimit(maxPointSize)
    }
    #[inline]
    pub unsafe fn PurgeFontCache() {
        SkGraphics_PurgeFontCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalBytesUsed() -> usize {
        SkGraphics_GetResourceCacheTotalBytesUsed()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalByteLimit() -> usize {
        SkGraphics_GetResourceCacheTotalByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheTotalByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheTotalByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn PurgeResourceCache() {
        SkGraphics_PurgeResourceCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheSingleAllocationByteLimit() -> usize {
        SkGraphics_GetResourceCacheSingleAllocationByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn DumpMemoryStatistics(dump: *mut SkTraceMemoryDump) {
        SkGraphics_DumpMemoryStatistics(dump)
    }
    #[inline]
    pub unsafe fn PurgeAllCaches() {
        SkGraphics_PurgeAllCaches()
    }
    #[inline]
    pub unsafe fn SetFlags(flags: *const ::std::os::raw::c_char) {
        SkGraphics_SetFlags(flags)
    }
    #[inline]
    pub unsafe fn SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory {
        SkGraphics_SetImageGeneratorFromEncodedDataFactory(arg1)
    }
    #[inline]
    pub unsafe fn AllowJIT() {
        SkGraphics_AllowJIT()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilter {
    pub _base: SkFlattenable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilter_CropRect {
    pub fRect: SkRect,
    pub fFlags: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilter_CropRect_CropEdge {
    kHasLeft_CropEdge = 1,
    kHasTop_CropEdge = 2,
    kHasWidth_CropEdge = 4,
    kHasHeight_CropEdge = 8,
    kHasAll_CropEdge = 15,
}
#[test]
fn bindgen_test_layout_SkImageFilter_CropRect() {
    assert_eq!(
        ::core::mem::size_of::<SkImageFilter_CropRect>(),
        20usize,
        concat!("Size of: ", stringify!(SkImageFilter_CropRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilter_CropRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkImageFilter_CropRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageFilter_CropRect>())).fRect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageFilter_CropRect),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageFilter_CropRect>())).fFlags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageFilter_CropRect),
            "::",
            stringify!(fFlags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter8CropRect7applyToERK7SkIRectRK8SkMatrixbPS1_"]
    pub fn SkImageFilter_CropRect_applyTo(
        this: *const SkImageFilter_CropRect,
        imageBounds: *const SkIRect,
        matrix: *const SkMatrix,
        embiggen: bool,
        cropped: *mut SkIRect,
    );
}
impl SkImageFilter_CropRect {
    #[inline]
    pub unsafe fn applyTo(
        &self,
        imageBounds: *const SkIRect,
        matrix: *const SkMatrix,
        embiggen: bool,
        cropped: *mut SkIRect,
    ) {
        SkImageFilter_CropRect_applyTo(self, imageBounds, matrix, embiggen, cropped)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilter_MapDirection {
    Forward = 0,
    Reverse = 1,
}
pub type SkImageFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkImageFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkImageFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkImageFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter12filterBoundsERK7SkIRectRK8SkMatrixNS_12MapDirectionEPS1_"]
    pub fn SkImageFilter_filterBounds(
        this: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter17isColorFilterNodeEPP13SkColorFilter"]
    pub fn SkImageFilter_isColorFilterNode(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter14asAColorFilterEPP13SkColorFilter"]
    pub fn SkImageFilter_asAColorFilter(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter11countInputsEv"]
    pub fn SkImageFilter_countInputs(this: *const SkImageFilter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter8getInputEi"]
    pub fn SkImageFilter_getInput(
        this: *const SkImageFilter,
        i: ::std::os::raw::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter20canComputeFastBoundsEv"]
    pub fn SkImageFilter_canComputeFastBounds(this: *const SkImageFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkImageFilter_makeWithLocalMatrix(
        this: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> sk_sp<SkImageFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkImageFilter16MakeMatrixFilterERK8SkMatrix15SkFilterQuality5sk_spIS_E"]
    pub fn SkImageFilter_MakeMatrixFilter(
        matrix: *const SkMatrix,
        quality: SkFilterQuality,
        input: sk_sp<SkImageFilter>,
    ) -> sk_sp<SkImageFilter>;
}
impl SkImageFilter {
    #[inline]
    pub unsafe fn filterBounds(
        &self,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect {
        SkImageFilter_filterBounds(self, src, ctm, arg1, inputRect)
    }
    #[inline]
    pub unsafe fn isColorFilterNode(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_isColorFilterNode(self, filterPtr)
    }
    #[inline]
    pub unsafe fn asAColorFilter(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_asAColorFilter(self, filterPtr)
    }
    #[inline]
    pub unsafe fn countInputs(&self) -> ::std::os::raw::c_int {
        SkImageFilter_countInputs(self)
    }
    #[inline]
    pub unsafe fn getInput(&self, i: ::std::os::raw::c_int) -> *const SkImageFilter {
        SkImageFilter_getInput(self, i)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkImageFilter_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, matrix: *const SkMatrix) -> sk_sp<SkImageFilter> {
        SkImageFilter_makeWithLocalMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn MakeMatrixFilter(
        matrix: *const SkMatrix,
        quality: SkFilterQuality,
        input: sk_sp<SkImageFilter>,
    ) -> sk_sp<SkImageFilter> {
        SkImageFilter_MakeMatrixFilter(matrix, quality, input)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkImageFilter17computeFastBoundsERK6SkRect"]
    pub fn SkImageFilter_computeFastBounds(
        this: *mut ::core::ffi::c_void,
        bounds: *const SkRect,
    ) -> SkRect;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVASizeInfo {
    pub fSizes: [SkISize; 4usize],
    pub fWidthBytes: [usize; 4usize],
    pub fOrigin: SkEncodedOrigin,
}
pub const SkYUVASizeInfo_kMaxCount: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVASizeInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVASizeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(SkYUVASizeInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVASizeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVASizeInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVASizeInfo>())).fSizes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVASizeInfo),
            "::",
            stringify!(fSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVASizeInfo>())).fWidthBytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVASizeInfo),
            "::",
            stringify!(fWidthBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkYUVASizeInfo>())).fOrigin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVASizeInfo),
            "::",
            stringify!(fOrigin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkYUVASizeInfo17computeTotalBytesEv"]
    pub fn SkYUVASizeInfo_computeTotalBytes(this: *const SkYUVASizeInfo) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkYUVASizeInfo13computePlanesEPvPS0_"]
    pub fn SkYUVASizeInfo_computePlanes(
        this: *const SkYUVASizeInfo,
        base: *mut ::core::ffi::c_void,
        planes: *mut *mut ::core::ffi::c_void,
    );
}
impl SkYUVASizeInfo {
    #[inline]
    pub unsafe fn computeTotalBytes(&self) -> usize {
        SkYUVASizeInfo_computeTotalBytes(self)
    }
    #[inline]
    pub unsafe fn computePlanes(
        &self,
        base: *mut ::core::ffi::c_void,
        planes: *mut *mut ::core::ffi::c_void,
    ) {
        SkYUVASizeInfo_computePlanes(self, base, planes)
    }
}
#[repr(C)]
pub struct SkImageGenerator__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImageGenerator {
    pub vtable_: *const SkImageGenerator__bindgen_vtable,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageGenerator_Options {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkImageGenerator_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Size of: ", stringify!(SkImageGenerator_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Alignment of ", stringify!(SkImageGenerator_Options))
    );
}
pub const SkImageGenerator_kNeedNewImageUniqueID: ::std::os::raw::c_int = 0;
#[test]
fn bindgen_test_layout_SkImageGenerator() {
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator>(),
        40usize,
        concat!("Size of: ", stringify!(SkImageGenerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageGenerator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageGenerator>())).fInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageGenerator),
            "::",
            stringify!(fInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkImageGenerator>())).fUniqueID as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageGenerator),
            "::",
            stringify!(fUniqueID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkImageGenerator9getPixelsERK11SkImageInfoPvm"]
    pub fn SkImageGenerator_getPixels(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16SkImageGenerator13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkImageGenerator_queryYUVAInfo(
        this: *const SkImageGenerator,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkImageGenerator13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkImageGenerator_getYUVAPlanes(
        this: *mut SkImageGenerator,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkImageGenerator15MakeFromEncodedE5sk_spI6SkDataE"]
    pub fn SkImageGenerator_MakeFromEncoded(arg1: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkImageGenerator15MakeFromPictureERK7SkISize5sk_spI9SkPictureEPK8SkMatrixPK7SkPaintN7SkImage8BitDepthES3_I12SkColorSpaceE"]
    pub fn SkImageGenerator_MakeFromPicture(
        arg1: *const SkISize,
        arg2: sk_sp<SkPicture>,
        arg3: *const SkMatrix,
        arg4: *const SkPaint,
        arg5: SkImage_BitDepth,
        arg6: sk_sp<SkColorSpace>,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkImageGeneratorC1ERK11SkImageInfoj"]
    pub fn SkImageGenerator_SkImageGenerator(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        uniqueId: u32,
    );
}
impl SkImageGenerator {
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool {
        SkImageGenerator_getPixels(self, info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkImageGenerator_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> bool {
        SkImageGenerator_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn MakeFromEncoded(arg1: sk_sp<SkData>) -> u64 {
        SkImageGenerator_MakeFromEncoded(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromPicture(
        arg1: *const SkISize,
        arg2: sk_sp<SkPicture>,
        arg3: *const SkMatrix,
        arg4: *const SkPaint,
        arg5: SkImage_BitDepth,
        arg6: sk_sp<SkColorSpace>,
    ) -> u64 {
        SkImageGenerator_MakeFromPicture(arg1, arg2, arg3, arg4, arg5, arg6)
    }
    #[inline]
    pub unsafe fn new(info: *const SkImageInfo, uniqueId: u32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkImageGenerator_SkImageGenerator(__bindgen_tmp.as_mut_ptr(), info, uniqueId);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVector4 {
    pub fData: [SkScalar; 4usize],
}
#[test]
fn bindgen_test_layout_SkVector4() {
    assert_eq!(
        ::core::mem::size_of::<SkVector4>(),
        16usize,
        concat!("Size of: ", stringify!(SkVector4))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVector4>(),
        4usize,
        concat!("Alignment of ", stringify!(SkVector4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVector4>())).fData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVector4),
            "::",
            stringify!(fData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMatrix44 {
    pub fMat: [[SkScalar; 4usize]; 4usize],
    pub fTypeMask: SkMatrix44_TypeMask,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix44_Uninitialized_Constructor {
    kUninitialized_Constructor = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix44_Identity_Constructor {
    kIdentity_Constructor = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix44_NaN_Constructor {
    kNaN_Constructor = 0,
}
pub type SkMatrix44_TypeMask = u8;
pub const SkMatrix44_kIdentity_Mask: SkMatrix44_TypeMask = 0;
pub const SkMatrix44_kTranslate_Mask: SkMatrix44_TypeMask = 1;
pub const SkMatrix44_kScale_Mask: SkMatrix44_TypeMask = 2;
pub const SkMatrix44_kAffine_Mask: SkMatrix44_TypeMask = 4;
pub const SkMatrix44_kPerspective_Mask: SkMatrix44_TypeMask = 8;
pub type SkMatrix44__bindgen_ty_1 = SkMatrix44_TypeMask;
pub const SkMatrix44_kAllPublic_Masks: ::std::os::raw::c_int = 15;
#[test]
fn bindgen_test_layout_SkMatrix44() {
    assert_eq!(
        ::core::mem::size_of::<SkMatrix44>(),
        68usize,
        concat!("Size of: ", stringify!(SkMatrix44))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMatrix44>(),
        4usize,
        concat!("Alignment of ", stringify!(SkMatrix44))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMatrix44>())).fMat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix44),
            "::",
            stringify!(fMat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkMatrix44>())).fTypeMask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix44),
            "::",
            stringify!(fTypeMask)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix441IEv"]
    pub fn SkMatrix44_I() -> *const SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4411setIdentityEv"]
    pub fn SkMatrix44_setIdentity(this: *mut SkMatrix44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4411asColMajorfEPf"]
    pub fn SkMatrix44_asColMajorf(this: *const SkMatrix44, arg1: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4411asColMajordEPd"]
    pub fn SkMatrix44_asColMajord(this: *const SkMatrix44, arg1: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4411asRowMajorfEPf"]
    pub fn SkMatrix44_asRowMajorf(this: *const SkMatrix44, arg1: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4411asRowMajordEPd"]
    pub fn SkMatrix44_asRowMajord(this: *const SkMatrix44, arg1: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412setColMajorfEPKf"]
    pub fn SkMatrix44_setColMajorf(this: *mut SkMatrix44, arg1: *const f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412setColMajordEPKd"]
    pub fn SkMatrix44_setColMajord(this: *mut SkMatrix44, arg1: *const f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412setRowMajorfEPKf"]
    pub fn SkMatrix44_setRowMajorf(this: *mut SkMatrix44, arg1: *const f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412setRowMajordEPKd"]
    pub fn SkMatrix44_setRowMajord(this: *mut SkMatrix44, arg1: *const f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix446set3x3Efffffffff"]
    pub fn SkMatrix44_set3x3(
        this: *mut SkMatrix44,
        m_00: SkScalar,
        m_10: SkScalar,
        m_20: SkScalar,
        m_01: SkScalar,
        m_11: SkScalar,
        m_21: SkScalar,
        m_02: SkScalar,
        m_12: SkScalar,
        m_22: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4415set3x3RowMajorfEPKf"]
    pub fn SkMatrix44_set3x3RowMajorf(this: *mut SkMatrix44, arg1: *const f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix446set4x4Effffffffffffffff"]
    pub fn SkMatrix44_set4x4(
        this: *mut SkMatrix44,
        m_00: SkScalar,
        m_10: SkScalar,
        m_20: SkScalar,
        m_30: SkScalar,
        m_01: SkScalar,
        m_11: SkScalar,
        m_21: SkScalar,
        m_31: SkScalar,
        m_02: SkScalar,
        m_12: SkScalar,
        m_22: SkScalar,
        m_32: SkScalar,
        m_03: SkScalar,
        m_13: SkScalar,
        m_23: SkScalar,
        m_33: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412setTranslateEfff"]
    pub fn SkMatrix44_setTranslate(
        this: *mut SkMatrix44,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4412preTranslateEfff"]
    pub fn SkMatrix44_preTranslate(
        this: *mut SkMatrix44,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4413postTranslateEfff"]
    pub fn SkMatrix44_postTranslate(
        this: *mut SkMatrix44,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix448setScaleEfff"]
    pub fn SkMatrix44_setScale(
        this: *mut SkMatrix44,
        sx: SkScalar,
        sy: SkScalar,
        sz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix448preScaleEfff"]
    pub fn SkMatrix44_preScale(
        this: *mut SkMatrix44,
        sx: SkScalar,
        sy: SkScalar,
        sz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix449postScaleEfff"]
    pub fn SkMatrix44_postScale(
        this: *mut SkMatrix44,
        sx: SkScalar,
        sy: SkScalar,
        sz: SkScalar,
    ) -> *mut SkMatrix44;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4414setRotateAboutEffff"]
    pub fn SkMatrix44_setRotateAbout(
        this: *mut SkMatrix44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
        radians: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix4418setRotateAboutUnitEffff"]
    pub fn SkMatrix44_setRotateAboutUnit(
        this: *mut SkMatrix44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
        radians: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix449setConcatERKS_S1_"]
    pub fn SkMatrix44_setConcat(this: *mut SkMatrix44, a: *const SkMatrix44, b: *const SkMatrix44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix446invertEPS_"]
    pub fn SkMatrix44_invert(this: *const SkMatrix44, inverse: *mut SkMatrix44) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix449transposeEv"]
    pub fn SkMatrix44_transpose(this: *mut SkMatrix44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4410mapScalarsEPKfPf"]
    pub fn SkMatrix44_mapScalars(this: *const SkMatrix44, src: *const SkScalar, dst: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix444map2EPKfiPf"]
    pub fn SkMatrix44_map2(
        this: *const SkMatrix44,
        src2: *const f32,
        count: ::std::os::raw::c_int,
        dst4: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix444map2EPKdiPd"]
    pub fn SkMatrix44_map21(
        this: *const SkMatrix44,
        src2: *const f64,
        count: ::std::os::raw::c_int,
        dst4: *mut f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4424preserves2dAxisAlignmentEf"]
    pub fn SkMatrix44_preserves2dAxisAlignment(this: *const SkMatrix44, epsilon: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix444dumpEv"]
    pub fn SkMatrix44_dump(this: *const SkMatrix44);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkMatrix4411determinantEv"]
    pub fn SkMatrix44_determinant(this: *const SkMatrix44) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkMatrix44C1ERK8SkMatrix"]
    pub fn SkMatrix44_SkMatrix44(this: *mut SkMatrix44, arg1: *const SkMatrix);
}
impl SkMatrix44 {
    #[inline]
    pub unsafe fn I() -> *const SkMatrix44 {
        SkMatrix44_I()
    }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        SkMatrix44_setIdentity(self)
    }
    #[inline]
    pub unsafe fn asColMajorf(&self, arg1: *mut f32) {
        SkMatrix44_asColMajorf(self, arg1)
    }
    #[inline]
    pub unsafe fn asColMajord(&self, arg1: *mut f64) {
        SkMatrix44_asColMajord(self, arg1)
    }
    #[inline]
    pub unsafe fn asRowMajorf(&self, arg1: *mut f32) {
        SkMatrix44_asRowMajorf(self, arg1)
    }
    #[inline]
    pub unsafe fn asRowMajord(&self, arg1: *mut f64) {
        SkMatrix44_asRowMajord(self, arg1)
    }
    #[inline]
    pub unsafe fn setColMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_setColMajorf(self, arg1)
    }
    #[inline]
    pub unsafe fn setColMajord(&mut self, arg1: *const f64) {
        SkMatrix44_setColMajord(self, arg1)
    }
    #[inline]
    pub unsafe fn setRowMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_setRowMajorf(self, arg1)
    }
    #[inline]
    pub unsafe fn setRowMajord(&mut self, arg1: *const f64) {
        SkMatrix44_setRowMajord(self, arg1)
    }
    #[inline]
    pub unsafe fn set3x3(
        &mut self,
        m_00: SkScalar,
        m_10: SkScalar,
        m_20: SkScalar,
        m_01: SkScalar,
        m_11: SkScalar,
        m_21: SkScalar,
        m_02: SkScalar,
        m_12: SkScalar,
        m_22: SkScalar,
    ) {
        SkMatrix44_set3x3(self, m_00, m_10, m_20, m_01, m_11, m_21, m_02, m_12, m_22)
    }
    #[inline]
    pub unsafe fn set3x3RowMajorf(&mut self, arg1: *const f32) {
        SkMatrix44_set3x3RowMajorf(self, arg1)
    }
    #[inline]
    pub unsafe fn set4x4(
        &mut self,
        m_00: SkScalar,
        m_10: SkScalar,
        m_20: SkScalar,
        m_30: SkScalar,
        m_01: SkScalar,
        m_11: SkScalar,
        m_21: SkScalar,
        m_31: SkScalar,
        m_02: SkScalar,
        m_12: SkScalar,
        m_22: SkScalar,
        m_32: SkScalar,
        m_03: SkScalar,
        m_13: SkScalar,
        m_23: SkScalar,
        m_33: SkScalar,
    ) {
        SkMatrix44_set4x4(
            self, m_00, m_10, m_20, m_30, m_01, m_11, m_21, m_31, m_02, m_12, m_22, m_32, m_03,
            m_13, m_23, m_33,
        )
    }
    #[inline]
    pub unsafe fn setTranslate(
        &mut self,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44 {
        SkMatrix44_setTranslate(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn preTranslate(
        &mut self,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44 {
        SkMatrix44_preTranslate(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn postTranslate(
        &mut self,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> *mut SkMatrix44 {
        SkMatrix44_postTranslate(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, sx: SkScalar, sy: SkScalar, sz: SkScalar) -> *mut SkMatrix44 {
        SkMatrix44_setScale(self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, sx: SkScalar, sy: SkScalar, sz: SkScalar) -> *mut SkMatrix44 {
        SkMatrix44_preScale(self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn postScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        sz: SkScalar,
    ) -> *mut SkMatrix44 {
        SkMatrix44_postScale(self, sx, sy, sz)
    }
    #[inline]
    pub unsafe fn setRotateAbout(
        &mut self,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
        radians: SkScalar,
    ) {
        SkMatrix44_setRotateAbout(self, x, y, z, radians)
    }
    #[inline]
    pub unsafe fn setRotateAboutUnit(
        &mut self,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
        radians: SkScalar,
    ) {
        SkMatrix44_setRotateAboutUnit(self, x, y, z, radians)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix44, b: *const SkMatrix44) {
        SkMatrix44_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn invert(&self, inverse: *mut SkMatrix44) -> bool {
        SkMatrix44_invert(self, inverse)
    }
    #[inline]
    pub unsafe fn transpose(&mut self) {
        SkMatrix44_transpose(self)
    }
    #[inline]
    pub unsafe fn mapScalars(&self, src: *const SkScalar, dst: *mut SkScalar) {
        SkMatrix44_mapScalars(self, src, dst)
    }
    #[inline]
    pub unsafe fn map2(&self, src2: *const f32, count: ::std::os::raw::c_int, dst4: *mut f32) {
        SkMatrix44_map2(self, src2, count, dst4)
    }
    #[inline]
    pub unsafe fn map21(&self, src2: *const f64, count: ::std::os::raw::c_int, dst4: *mut f64) {
        SkMatrix44_map21(self, src2, count, dst4)
    }
    #[inline]
    pub unsafe fn preserves2dAxisAlignment(&self, epsilon: SkScalar) -> bool {
        SkMatrix44_preserves2dAxisAlignment(self, epsilon)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkMatrix44_dump(self)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> f64 {
        SkMatrix44_determinant(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkMatrix) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMatrix44_SkMatrix44(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMaskFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkMaskFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMaskFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkMaskFilter8MakeBlurE11SkBlurStylefb"]
    pub fn SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter>;
}
impl SkMaskFilter {
    #[inline]
    pub unsafe fn MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter> {
        SkMaskFilter_MakeBlur(style, sigma, respectCTM)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathBuilder {
    pub fPts: SkTDArray<SkPoint>,
    pub fVerbs: SkTDArray<u8>,
    pub fConicWeights: SkTDArray<SkScalar>,
    pub fFillType: SkPathFillType,
    pub fIsVolatile: bool,
    pub fSegmentMask: ::std::os::raw::c_uint,
    pub fLastMovePoint: SkPoint,
    pub fNeedsMoveVerb: bool,
    pub fIsA: SkPathBuilder_IsA,
    pub fIsAStart: ::std::os::raw::c_int,
    pub fIsACCW: bool,
    pub fOverrideConvexity: SkPathConvexity,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_IsA {
    kIsA_JustMoves = 0,
    kIsA_MoreThanMoves = 1,
    kIsA_Oval = 2,
    kIsA_RRect = 3,
}
#[test]
fn bindgen_test_layout_SkPathBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkPathBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(SkPathBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathBuilder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fPts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fVerbs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fConicWeights as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fConicWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fFillType as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fFillType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fIsVolatile as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsVolatile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fSegmentMask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fSegmentMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fLastMovePoint as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fLastMovePoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fNeedsMoveVerb as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fNeedsMoveVerb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fIsA as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fIsAStart as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsAStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathBuilder>())).fIsACCW as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsACCW)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPathBuilder>())).fOverrideConvexity as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fOverrideConvexity)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkPathBuilder13computeBoundsEv"]
    pub fn SkPathBuilder_computeBounds(this: *const SkPathBuilder) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13SkPathBuilder8snapshotEv"]
    pub fn SkPathBuilder_snapshot(this: *const SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6detachEv"]
    pub fn SkPathBuilder_detach(this: *mut SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder5resetEv"]
    pub fn SkPathBuilder_reset(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6moveToE7SkPoint"]
    pub fn SkPathBuilder_moveTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6lineToE7SkPoint"]
    pub fn SkPathBuilder_lineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6quadToE7SkPointS0_"]
    pub fn SkPathBuilder_quadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7conicToE7SkPointS0_f"]
    pub fn SkPathBuilder_conicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7cubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_cubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder5closeEv"]
    pub fn SkPathBuilder_close(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder10polylineToEPK7SkPointi"]
    pub fn SkPathBuilder_polylineTo(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7rLineToE7SkPoint"]
    pub fn SkPathBuilder_rLineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7rQuadToE7SkPointS0_"]
    pub fn SkPathBuilder_rQuadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder8rConicToE7SkPointS0_f"]
    pub fn SkPathBuilder_rConicTo(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder8rCubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_rCubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder5arcToERK6SkRectffb"]
    pub fn SkPathBuilder_arcTo(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder5arcToE7SkPointS0_f"]
    pub fn SkPathBuilder_arcTo1(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder5arcToE7SkPointfNS_7ArcSizeE15SkPathDirectionS0_"]
    pub fn SkPathBuilder_arcTo2(
        this: *mut SkPathBuilder,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6addArcERK6SkRectff"]
    pub fn SkPathBuilder_addArc(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addOval(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder9addCircleEfff15SkPathDirection"]
    pub fn SkPathBuilder_addCircle(
        this: *mut SkPathBuilder,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder10addPolygonEPK7SkPointib"]
    pub fn SkPathBuilder_addPolygon(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder10incReserveEii"]
    pub fn SkPathBuilder_incReserve(
        this: *mut SkPathBuilder,
        extraPtCount: ::std::os::raw::c_int,
        extraVerbCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilder6offsetEff"]
    pub fn SkPathBuilder_offset(
        this: *mut SkPathBuilder,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilderC1Ev"]
    pub fn SkPathBuilder_SkPathBuilder(this: *mut SkPathBuilder);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilderC1E14SkPathFillType"]
    pub fn SkPathBuilder_SkPathBuilder1(this: *mut SkPathBuilder, arg1: SkPathFillType);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilderC1ERK6SkPath"]
    pub fn SkPathBuilder_SkPathBuilder2(this: *mut SkPathBuilder, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathBuilderD1Ev"]
    pub fn SkPathBuilder_SkPathBuilder_destructor(this: *mut SkPathBuilder);
}
impl SkPathBuilder {
    #[inline]
    pub unsafe fn computeBounds(&self) -> SkRect {
        SkPathBuilder_computeBounds(self)
    }
    #[inline]
    pub unsafe fn snapshot(&self) -> SkPath {
        SkPathBuilder_snapshot(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> SkPath {
        SkPathBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_reset(self)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_moveTo(self, pt)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_lineTo(self, pt)
    }
    #[inline]
    pub unsafe fn quadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_quadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_conicTo(self, pt1, pt2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_cubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_close(self)
    }
    #[inline]
    pub unsafe fn polylineTo(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_polylineTo(self, pts, count)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rLineTo(self, pt)
    }
    #[inline]
    pub unsafe fn rQuadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rQuadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn rConicTo(&mut self, p1: SkPoint, p2: SkPoint, w: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_rConicTo(self, p1, p2, w)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_rCubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo(self, oval, startAngleDeg, sweepAngleDeg, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo1(self, p1, p2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo2(self, r, xAxisRotate, largeArc, sweep, xy)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addArc(self, oval, startAngleDeg, sweepAngleDeg)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addOval(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addOval(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addRRect(
        &mut self,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addCircle(self, center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn addPolygon(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addPolygon(self, pts, count, isClosed)
    }
    #[inline]
    pub unsafe fn incReserve(
        &mut self,
        extraPtCount: ::std::os::raw::c_int,
        extraVerbCount: ::std::os::raw::c_int,
    ) {
        SkPathBuilder_incReserve(self, extraPtCount, extraVerbCount)
    }
    #[inline]
    pub unsafe fn offset(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_offset(self, dx, dy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: SkPathFillType) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathBuilder_SkPathBuilder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathMeasure {
    pub fIter: SkContourMeasureIter,
    pub fContour: sk_sp<SkContourMeasure>,
}
pub const SkPathMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkPathMeasure_MatrixFlags = 1;
pub const SkPathMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkPathMeasure_MatrixFlags = 2;
pub const SkPathMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkPathMeasure_MatrixFlags = 3;
pub type SkPathMeasure_MatrixFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkPathMeasure() {
    assert_eq!(
        ::core::mem::size_of::<SkPathMeasure>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathMeasure))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathMeasure>())).fIter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathMeasure),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathMeasure>())).fContour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathMeasure),
            "::",
            stringify!(fContour)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure7setPathEPK6SkPathb"]
    pub fn SkPathMeasure_setPath(this: *mut SkPathMeasure, arg1: *const SkPath, forceClosed: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure9getLengthEv"]
    pub fn SkPathMeasure_getLength(this: *mut SkPathMeasure) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkPathMeasure_getPosTan(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkPathMeasure_getMatrix(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure10getSegmentEffP6SkPathb"]
    pub fn SkPathMeasure_getSegment(
        this: *mut SkPathMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure8isClosedEv"]
    pub fn SkPathMeasure_isClosed(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasure11nextContourEv"]
    pub fn SkPathMeasure_nextContour(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasureC1Ev"]
    pub fn SkPathMeasure_SkPathMeasure(this: *mut SkPathMeasure);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasureC1ERK6SkPathbf"]
    pub fn SkPathMeasure_SkPathMeasure1(
        this: *mut SkPathMeasure,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkPathMeasureD1Ev"]
    pub fn SkPathMeasure_SkPathMeasure_destructor(this: *mut SkPathMeasure);
}
impl SkPathMeasure {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath, forceClosed: bool) {
        SkPathMeasure_setPath(self, arg1, forceClosed)
    }
    #[inline]
    pub unsafe fn getLength(&mut self) -> SkScalar {
        SkPathMeasure_getLength(self)
    }
    #[inline]
    pub unsafe fn getPosTan(
        &mut self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkPathMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &mut self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool {
        SkPathMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &mut self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkPathMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
    #[inline]
    pub unsafe fn isClosed(&mut self) -> bool {
        SkPathMeasure_isClosed(self)
    }
    #[inline]
    pub unsafe fn nextContour(&mut self) -> bool {
        SkPathMeasure_nextContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure1(__bindgen_tmp.as_mut_ptr(), path, forceClosed, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathMeasure_SkPathMeasure_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture_AbortCallback {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkPicture_AbortCallback() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Size of: ", stringify!(SkPicture_AbortCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture_AbortCallback))
    );
}
#[test]
fn bindgen_test_layout_SkPicture() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture>(),
        16usize,
        concat!("Size of: ", stringify!(SkPicture))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPicture14MakeFromStreamEP8SkStreamPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPicture12MakeFromDataEPK6SkDataPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPicture12MakeFromDataEPKvmPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPicture9serializeEPK13SkSerialProcs"]
    pub fn SkPicture_serialize(
        this: *const SkPicture,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPicture9serializeEP9SkWStreamPK13SkSerialProcs"]
    pub fn SkPicture_serialize1(
        this: *const SkPicture,
        stream: *mut SkWStream,
        procs: *const SkSerialProcs,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPicture15MakePlaceholderE6SkRect"]
    pub fn SkPicture_MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPicture10makeShaderE10SkTileModeS0_PK8SkMatrixPK6SkRect"]
    pub fn SkPicture_makeShader(
        this: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPicture10makeShaderE10SkTileModeS0_PK8SkMatrix"]
    pub fn SkPicture_makeShader1(
        this: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
impl SkPicture {
    #[inline]
    pub unsafe fn MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromStream(stream, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData(data, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData1(data, size, procs)
    }
    #[inline]
    pub unsafe fn serialize(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkPicture_serialize(self, procs)
    }
    #[inline]
    pub unsafe fn serialize1(&self, stream: *mut SkWStream, procs: *const SkSerialProcs) {
        SkPicture_serialize1(self, stream, procs)
    }
    #[inline]
    pub unsafe fn MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture> {
        SkPicture_MakePlaceholder(cull)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader> {
        SkPicture_makeShader(self, tmx, tmy, localMatrix, tileRect)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkPicture_makeShader1(self, tmx, tmy, localMatrix)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBBoxHierarchy {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBBoxHierarchy_Metadata {
    pub isDraw: bool,
}
#[test]
fn bindgen_test_layout_SkBBoxHierarchy_Metadata() {
    assert_eq!(
        ::core::mem::size_of::<SkBBoxHierarchy_Metadata>(),
        1usize,
        concat!("Size of: ", stringify!(SkBBoxHierarchy_Metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBoxHierarchy_Metadata>(),
        1usize,
        concat!("Alignment of ", stringify!(SkBBoxHierarchy_Metadata))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkBBoxHierarchy_Metadata>())).isDraw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBBoxHierarchy_Metadata),
            "::",
            stringify!(isDraw)
        )
    );
}
#[test]
fn bindgen_test_layout_SkBBoxHierarchy() {
    assert_eq!(
        ::core::mem::size_of::<SkBBoxHierarchy>(),
        16usize,
        concat!("Size of: ", stringify!(SkBBoxHierarchy))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBoxHierarchy>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBBoxHierarchy))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkBBoxHierarchy6insertEPK6SkRectPKNS_8MetadataEi"]
    pub fn SkBBoxHierarchy_insert1(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkRect,
        arg2: *const SkBBoxHierarchy_Metadata,
        N: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBBHFactory {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkBBHFactory() {
    assert_eq!(
        ::core::mem::size_of::<SkBBHFactory>(),
        8usize,
        concat!("Size of: ", stringify!(SkBBHFactory))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBHFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBBHFactory))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMiniRecorder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecorder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPictureRecorder {
    pub fActivelyRecording: bool,
    pub fCullRect: SkRect,
    pub fBBH: sk_sp<SkBBoxHierarchy>,
    pub fRecorder: u64,
    pub fRecord: sk_sp<SkRecord>,
    pub fMiniRecorder: u64,
}
pub type SkPictureRecorder_FinishFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkPictureRecorder() {
    assert_eq!(
        ::core::mem::size_of::<SkPictureRecorder>(),
        56usize,
        concat!("Size of: ", stringify!(SkPictureRecorder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPictureRecorder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPictureRecorder))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPictureRecorder>())).fActivelyRecording as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fActivelyRecording)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPictureRecorder>())).fCullRect as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fCullRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPictureRecorder>())).fBBH as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fBBH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPictureRecorder>())).fRecorder as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fRecorder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPictureRecorder>())).fRecord as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPictureRecorder>())).fMiniRecorder as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fMiniRecorder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder14beginRecordingERK6SkRect5sk_spI15SkBBoxHierarchyE"]
    pub fn SkPictureRecorder_beginRecording(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder14beginRecordingERK6SkRectP12SkBBHFactory"]
    pub fn SkPictureRecorder_beginRecording1(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder18getRecordingCanvasEv"]
    pub fn SkPictureRecorder_getRecordingCanvas(this: *mut SkPictureRecorder) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder24finishRecordingAsPictureEv"]
    pub fn SkPictureRecorder_finishRecordingAsPicture(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder32finishRecordingAsPictureWithCullERK6SkRect"]
    pub fn SkPictureRecorder_finishRecordingAsPictureWithCull(
        this: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorder25finishRecordingAsDrawableEv"]
    pub fn SkPictureRecorder_finishRecordingAsDrawable(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkDrawable>;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorderC1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder(this: *mut SkPictureRecorder);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkPictureRecorderD1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder_destructor(this: *mut SkPictureRecorder);
}
impl SkPictureRecorder {
    #[inline]
    pub unsafe fn beginRecording(
        &mut self,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording(self, bounds, bbh)
    }
    #[inline]
    pub unsafe fn beginRecording1(
        &mut self,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording1(self, bounds, bbhFactory)
    }
    #[inline]
    pub unsafe fn getRecordingCanvas(&mut self) -> *mut SkCanvas {
        SkPictureRecorder_getRecordingCanvas(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPicture(&mut self) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPicture(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPictureWithCull(
        &mut self,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPictureWithCull(self, cullRect)
    }
    #[inline]
    pub unsafe fn finishRecordingAsDrawable(&mut self) -> sk_sp<SkDrawable> {
        SkPictureRecorder_finishRecordingAsDrawable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPictureRecorder_SkPictureRecorder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPictureRecorder_SkPictureRecorder_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPixelRef {
    pub _bindgen_opaque_blob: [u64; 11usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelRef_Mutability {
    kMutable = 0,
    kTemporarilyImmutable = 1,
    kImmutable = 2,
}
pub type SkPixelRef_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkPixelRef() {
    assert_eq!(
        ::core::mem::size_of::<SkPixelRef>(),
        88usize,
        concat!("Size of: ", stringify!(SkPixelRef))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixelRef>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixelRef))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkPixelRef15getGenerationIDEv"]
    pub fn SkPixelRef_getGenerationID(this: *const SkPixelRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRef19notifyPixelsChangedEv"]
    pub fn SkPixelRef_notifyPixelsChanged(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRef12setImmutableEv"]
    pub fn SkPixelRef_setImmutable(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRef22addGenIDChangeListenerE5sk_spI18SkIDChangeListenerE"]
    pub fn SkPixelRef_addGenIDChangeListener(
        this: *mut SkPixelRef,
        listener: sk_sp<SkIDChangeListener>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRef18android_only_resetEiim"]
    pub fn SkPixelRef_android_only_reset(
        this: *mut SkPixelRef,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRefC1EiiPvm"]
    pub fn SkPixelRef_SkPixelRef(
        this: *mut SkPixelRef,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    );
}
impl SkPixelRef {
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPixelRef_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&mut self) {
        SkPixelRef_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkPixelRef_setImmutable(self)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self, listener: sk_sp<SkIDChangeListener>) {
        SkPixelRef_addGenIDChangeListener(self, listener)
    }
    #[inline]
    pub unsafe fn android_only_reset(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        rowBytes: usize,
    ) {
        SkPixelRef_android_only_reset(self, width, height, rowBytes)
    }
    #[inline]
    pub unsafe fn new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPixelRef_SkPixelRef(__bindgen_tmp.as_mut_ptr(), width, height, addr, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkPixelRefD1Ev"]
    pub fn SkPixelRef_SkPixelRef_destructor(this: *mut SkPixelRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint3 {
    pub fX: SkScalar,
    pub fY: SkScalar,
    pub fZ: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint3() {
    assert_eq!(
        ::core::mem::size_of::<SkPoint3>(),
        12usize,
        concat!("Size of: ", stringify!(SkPoint3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPoint3>())).fX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPoint3>())).fY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPoint3>())).fZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fZ)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPoint36LengthEfff"]
    pub fn SkPoint3_Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkPoint39normalizeEv"]
    pub fn SkPoint3_normalize(this: *mut SkPoint3) -> bool;
}
impl SkPoint3 {
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar {
        SkPoint3_Length(x, y, z)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint3_normalize(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRegion {
    pub fBounds: SkIRect,
    pub fRunHead: *mut SkRegion_RunHead,
}
pub type SkRegion_RunType = i32;
impl SkRegion_Op {
    pub const LastOp: SkRegion_Op = SkRegion_Op::Replace;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRegion_Op {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
    Replace = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Iterator {
    pub fRgn: *const SkRegion,
    pub fRuns: *const SkRegion_RunType,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Iterator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Iterator>(),
        40usize,
        concat!("Size of: ", stringify!(SkRegion_Iterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Iterator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Iterator>())).fRgn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRgn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Iterator>())).fRuns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRuns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Iterator>())).fRect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Iterator>())).fDone as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8Iterator6rewindEv"]
    pub fn SkRegion_Iterator_rewind(this: *mut SkRegion_Iterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8Iterator5resetERKS_"]
    pub fn SkRegion_Iterator_reset(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8Iterator4nextEv"]
    pub fn SkRegion_Iterator_next(this: *mut SkRegion_Iterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8IteratorC1ERKS_"]
    pub fn SkRegion_Iterator_Iterator(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
impl SkRegion_Iterator {
    #[inline]
    pub unsafe fn rewind(&mut self) -> bool {
        SkRegion_Iterator_rewind(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, region: *const SkRegion) {
        SkRegion_Iterator_reset(self, region)
    }
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Iterator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Iterator_Iterator(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Cliperator {
    pub fIter: SkRegion_Iterator,
    pub fClip: SkIRect,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Cliperator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Cliperator>(),
        80usize,
        concat!("Size of: ", stringify!(SkRegion_Cliperator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Cliperator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Cliperator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Cliperator>())).fIter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Cliperator>())).fClip as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fClip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Cliperator>())).fRect as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Cliperator>())).fDone as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion10Cliperator4nextEv"]
    pub fn SkRegion_Cliperator_next(this: *mut SkRegion_Cliperator);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion10CliperatorC1ERKS_RK7SkIRect"]
    pub fn SkRegion_Cliperator_Cliperator(
        this: *mut SkRegion_Cliperator,
        region: *const SkRegion,
        clip: *const SkIRect,
    );
}
impl SkRegion_Cliperator {
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Cliperator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion, clip: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Cliperator_Cliperator(__bindgen_tmp.as_mut_ptr(), region, clip);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Spanerator {
    pub fRuns: *const SkRegion_RunType,
    pub fLeft: ::std::os::raw::c_int,
    pub fRight: ::std::os::raw::c_int,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Spanerator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Spanerator>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion_Spanerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Spanerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Spanerator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Spanerator>())).fRuns as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fRuns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Spanerator>())).fLeft as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Spanerator>())).fRight as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion_Spanerator>())).fDone as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion10Spanerator4nextEPiS1_"]
    pub fn SkRegion_Spanerator_next(
        this: *mut SkRegion_Spanerator,
        left: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion10SpaneratorC1ERKS_iii"]
    pub fn SkRegion_Spanerator_Spanerator(
        this: *mut SkRegion_Spanerator,
        region: *const SkRegion,
        y: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    );
}
impl SkRegion_Spanerator {
    #[inline]
    pub unsafe fn next(
        &mut self,
        left: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> bool {
        SkRegion_Spanerator_next(self, left, right)
    }
    #[inline]
    pub unsafe fn new(
        region: *const SkRegion,
        y: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Spanerator_Spanerator(__bindgen_tmp.as_mut_ptr(), region, y, left, right);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_RunHead {
    _unused: [u8; 0],
}
pub const SkRegion_kOpCnt: ::std::os::raw::c_int = 6;
pub const SkRegion_kOpCount: ::std::os::raw::c_int = 6;
pub const SkRegion_kRectRegionRuns: ::std::os::raw::c_int = 7;
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion15kRectRunHeadPtrE"]
    pub static SkRegion_kRectRunHeadPtr: *mut SkRegion_RunHead;
}
#[test]
fn bindgen_test_layout_SkRegion() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion>())).fBounds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRegion>())).fRunHead as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion),
            "::",
            stringify!(fRunHead)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion4swapERS_"]
    pub fn SkRegion_swap(this: *mut SkRegion, other: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion23computeRegionComplexityEv"]
    pub fn SkRegion_computeRegionComplexity(this: *const SkRegion) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion15getBoundaryPathEP6SkPath"]
    pub fn SkRegion_getBoundaryPath(this: *const SkRegion, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8setEmptyEv"]
    pub fn SkRegion_setEmpty(this: *mut SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion7setRectERK7SkIRect"]
    pub fn SkRegion_setRect(this: *mut SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion8setRectsEPK7SkIRecti"]
    pub fn SkRegion_setRects(
        this: *mut SkRegion,
        rects: *const SkIRect,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion9setRegionERKS_"]
    pub fn SkRegion_setRegion(this: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion7setPathERK6SkPathRKS_"]
    pub fn SkRegion_setPath(
        this: *mut SkRegion,
        path: *const SkPath,
        clip: *const SkRegion,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion10intersectsERK7SkIRect"]
    pub fn SkRegion_intersects(this: *const SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion10intersectsERKS_"]
    pub fn SkRegion_intersects1(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion8containsEii"]
    pub fn SkRegion_contains(this: *const SkRegion, x: i32, y: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion8containsERK7SkIRect"]
    pub fn SkRegion_contains1(this: *const SkRegion, other: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion8containsERKS_"]
    pub fn SkRegion_contains2(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion9translateEiiPS_"]
    pub fn SkRegion_translate(
        this: *const SkRegion,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        dst: *mut SkRegion,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion2opERK7SkIRectRKS_NS_2OpE"]
    pub fn SkRegion_op(
        this: *mut SkRegion,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion2opERKS_RK7SkIRectNS_2OpE"]
    pub fn SkRegion_op1(
        this: *mut SkRegion,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion2opERKS_S1_NS_2OpE"]
    pub fn SkRegion_op2(
        this: *mut SkRegion,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK8SkRegion13writeToMemoryEPv"]
    pub fn SkRegion_writeToMemory(this: *const SkRegion, buffer: *mut ::core::ffi::c_void)
        -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegion14readFromMemoryEPKvm"]
    pub fn SkRegion_readFromMemory(
        this: *mut SkRegion,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegionC1Ev"]
    pub fn SkRegion_SkRegion(this: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegionC1ERKS_"]
    pub fn SkRegion_SkRegion1(this: *mut SkRegion, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegionC1ERK7SkIRect"]
    pub fn SkRegion_SkRegion2(this: *mut SkRegion, rect: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN8SkRegionD1Ev"]
    pub fn SkRegion_SkRegion_destructor(this: *mut SkRegion);
}
impl SkRegion {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkRegion) {
        SkRegion_swap(self, other)
    }
    #[inline]
    pub unsafe fn computeRegionComplexity(&self) -> ::std::os::raw::c_int {
        SkRegion_computeRegionComplexity(self)
    }
    #[inline]
    pub unsafe fn getBoundaryPath(&self, path: *mut SkPath) -> bool {
        SkRegion_getBoundaryPath(self, path)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) -> bool {
        SkRegion_setEmpty(self)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, rect: *const SkIRect) -> bool {
        SkRegion_setRect(self, rect)
    }
    #[inline]
    pub unsafe fn setRects(&mut self, rects: *const SkIRect, count: ::std::os::raw::c_int) -> bool {
        SkRegion_setRects(self, rects, count)
    }
    #[inline]
    pub unsafe fn setRegion(&mut self, region: *const SkRegion) -> bool {
        SkRegion_setRegion(self, region)
    }
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, clip: *const SkRegion) -> bool {
        SkRegion_setPath(self, path, clip)
    }
    #[inline]
    pub unsafe fn intersects(&self, rect: *const SkIRect) -> bool {
        SkRegion_intersects(self, rect)
    }
    #[inline]
    pub unsafe fn intersects1(&self, other: *const SkRegion) -> bool {
        SkRegion_intersects1(self, other)
    }
    #[inline]
    pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
        SkRegion_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn contains1(&self, other: *const SkIRect) -> bool {
        SkRegion_contains1(self, other)
    }
    #[inline]
    pub unsafe fn contains2(&self, other: *const SkRegion) -> bool {
        SkRegion_contains2(self, other)
    }
    #[inline]
    pub unsafe fn translate(
        &self,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        dst: *mut SkRegion,
    ) {
        SkRegion_translate(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn op(
        &mut self,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op(self, rect, rgn, op)
    }
    #[inline]
    pub unsafe fn op1(
        &mut self,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op1(self, rgn, rect, op)
    }
    #[inline]
    pub unsafe fn op2(
        &mut self,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op2(self, rgna, rgnb, op)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRegion_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRegion_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion1(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rect: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion2(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkRegion_SkRegion_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRSXform {
    pub fSCos: SkScalar,
    pub fSSin: SkScalar,
    pub fTx: SkScalar,
    pub fTy: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRSXform() {
    assert_eq!(
        ::core::mem::size_of::<SkRSXform>(),
        16usize,
        concat!("Size of: ", stringify!(SkRSXform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRSXform>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRSXform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRSXform>())).fSCos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fSCos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRSXform>())).fSSin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fSSin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRSXform>())).fTx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fTx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRSXform>())).fTy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fTy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkRSXform6toQuadEffP7SkPoint"]
    pub fn SkRSXform_toQuad(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        quad: *mut SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkRSXform10toTriStripEffP7SkPoint"]
    pub fn SkRSXform_toTriStrip(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        strip: *mut SkPoint,
    );
}
impl SkRSXform {
    #[inline]
    pub unsafe fn toQuad(&self, width: SkScalar, height: SkScalar, quad: *mut SkPoint) {
        SkRSXform_toQuad(self, width, height, quad)
    }
    #[inline]
    pub unsafe fn toTriStrip(&self, width: SkScalar, height: SkScalar, strip: *mut SkPoint) {
        SkRSXform_toTriStrip(self, width, height, strip)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkStrokeRec {
    pub fResScale: SkScalar,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_InitStyle {
    Hairline = 0,
    Fill = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_Style {
    Hairline = 0,
    Fill = 1,
    Stroke = 2,
    StrokeAndFill = 3,
}
pub const SkStrokeRec_kStyleCount: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkStrokeRec() {
    assert_eq!(
        ::core::mem::size_of::<SkStrokeRec>(),
        16usize,
        concat!("Size of: ", stringify!(SkStrokeRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrokeRec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkStrokeRec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkStrokeRec>())).fResScale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fResScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkStrokeRec>())).fWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkStrokeRec>())).fMiterLimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fMiterLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkStrokeRec8getStyleEv"]
    pub fn SkStrokeRec_getStyle(this: *const SkStrokeRec) -> SkStrokeRec_Style;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRec12setFillStyleEv"]
    pub fn SkStrokeRec_setFillStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRec16setHairlineStyleEv"]
    pub fn SkStrokeRec_setHairlineStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRec14setStrokeStyleEfb"]
    pub fn SkStrokeRec_setStrokeStyle(this: *mut SkStrokeRec, width: SkScalar, strokeAndFill: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkStrokeRec11applyToPathEP6SkPathRKS0_"]
    pub fn SkStrokeRec_applyToPath(
        this: *const SkStrokeRec,
        dst: *mut SkPath,
        src: *const SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkStrokeRec12applyToPaintEP7SkPaint"]
    pub fn SkStrokeRec_applyToPaint(this: *const SkStrokeRec, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11SkStrokeRec18getInflationRadiusEv"]
    pub fn SkStrokeRec_getInflationRadius(this: *const SkStrokeRec) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRec18GetInflationRadiusERK7SkPaintNS0_5StyleE"]
    pub fn SkStrokeRec_GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRec18GetInflationRadiusEN7SkPaint4JoinEfNS0_3CapEf"]
    pub fn SkStrokeRec_GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRecC1ENS_9InitStyleE"]
    pub fn SkStrokeRec_SkStrokeRec(this: *mut SkStrokeRec, style: SkStrokeRec_InitStyle);
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRecC1ERK7SkPaintNS0_5StyleEf"]
    pub fn SkStrokeRec_SkStrokeRec1(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        arg2: SkPaint_Style,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkStrokeRecC1ERK7SkPaintf"]
    pub fn SkStrokeRec_SkStrokeRec2(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        resScale: SkScalar,
    );
}
impl SkStrokeRec {
    #[inline]
    pub fn fCap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_fCap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoin(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_fJoin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn fStrokeAndFill(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fStrokeAndFill(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fCap: u32,
        fJoin: u32,
        fStrokeAndFill: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let fCap: u32 = unsafe { ::core::mem::transmute(fCap) };
            fCap as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let fJoin: u32 = unsafe { ::core::mem::transmute(fJoin) };
            fJoin as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let fStrokeAndFill: u32 = unsafe { ::core::mem::transmute(fStrokeAndFill) };
            fStrokeAndFill as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getStyle(&self) -> SkStrokeRec_Style {
        SkStrokeRec_getStyle(self)
    }
    #[inline]
    pub unsafe fn setFillStyle(&mut self) {
        SkStrokeRec_setFillStyle(self)
    }
    #[inline]
    pub unsafe fn setHairlineStyle(&mut self) {
        SkStrokeRec_setHairlineStyle(self)
    }
    #[inline]
    pub unsafe fn setStrokeStyle(&mut self, width: SkScalar, strokeAndFill: bool) {
        SkStrokeRec_setStrokeStyle(self, width, strokeAndFill)
    }
    #[inline]
    pub unsafe fn applyToPath(&self, dst: *mut SkPath, src: *const SkPath) -> bool {
        SkStrokeRec_applyToPath(self, dst, src)
    }
    #[inline]
    pub unsafe fn applyToPaint(&self, paint: *mut SkPaint) {
        SkStrokeRec_applyToPaint(self, paint)
    }
    #[inline]
    pub unsafe fn getInflationRadius(&self) -> SkScalar {
        SkStrokeRec_getInflationRadius(self)
    }
    #[inline]
    pub unsafe fn GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar {
        SkStrokeRec_GetInflationRadius(arg1, arg2)
    }
    #[inline]
    pub unsafe fn GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar {
        SkStrokeRec_GetInflationRadius1(arg1, miterLimit, arg2, strokeWidth)
    }
    #[inline]
    pub unsafe fn new(style: SkStrokeRec_InitStyle) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec(__bindgen_tmp.as_mut_ptr(), style);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkPaint, arg2: SkPaint_Style, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPaint, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec2(__bindgen_tmp.as_mut_ptr(), arg1, resScale);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
pub type SkSurface_ReleaseContext = *mut ::core::ffi::c_void;
pub type SkSurface_RenderTargetReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(releaseContext: SkSurface_ReleaseContext)>;
pub type SkSurface_TextureReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(releaseContext: SkSurface_ReleaseContext)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_ContentChangeMode {
    Discard = 0,
    Retain = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_BackendHandleAccess {
    FlushRead = 0,
    FlushWrite = 1,
    DiscardWrite = 2,
}
pub type SkSurface_AsyncReadResult = SkImage_AsyncReadResult;
pub type SkSurface_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkSurface_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkSurface_ReadPixelsContext, arg2: u8)>;
pub use self::SkImage_RescaleGamma as SkSurface_RescaleGamma;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_BackendSurfaceAccess {
    NoAccess = 0,
    Present = 1,
}
pub type SkSurface_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkSurface() {
    assert_eq!(
        ::core::mem::size_of::<SkSurface>(),
        32usize,
        concat!("Size of: ", stringify!(SkSurface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkSurface))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface27MakeRasterDirectReleaseProcERK11SkImageInfoPvmPFvS3_S3_ES3_PK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterDirectReleaseProc(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(
                pixels: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface10MakeRasterERK11SkImageInfomPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface19MakeRasterN32PremulEiiPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface22MakeFromBackendTextureEP18GrRecordingContextRK16GrBackendTexture15GrSurfaceOrigini11SkColorType5sk_spI12SkColorSpaceEPK14SkSurfacePropsPFvPvESD_"]
    pub fn SkSurface_MakeFromBackendTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        sampleCnt: ::std::os::raw::c_int,
        colorType: SkColorType,
        colorSpace: sk_sp<SkColorSpace>,
        surfaceProps: *const SkSurfaceProps,
        textureReleaseProc: SkSurface_TextureReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface27MakeFromBackendRenderTargetEP18GrRecordingContextRK21GrBackendRenderTarget15GrSurfaceOrigin11SkColorType5sk_spI12SkColorSpaceEPK14SkSurfacePropsPFvPvESD_"]
    pub fn SkSurface_MakeFromBackendRenderTarget(
        context: *mut GrRecordingContext,
        backendRenderTarget: *const GrBackendRenderTarget,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        colorSpace: sk_sp<SkColorSpace>,
        surfaceProps: *const SkSurfaceProps,
        releaseProc: SkSurface_RenderTargetReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface16MakeRenderTargetEP18GrRecordingContext10SkBudgetedRK11SkImageInfoi15GrSurfaceOriginPK14SkSurfacePropsb"]
    pub fn SkSurface_MakeRenderTarget(
        context: *mut GrRecordingContext,
        budgeted: SkBudgeted,
        imageInfo: *const SkImageInfo,
        sampleCount: ::std::os::raw::c_int,
        surfaceOrigin: GrSurfaceOrigin,
        surfaceProps: *const SkSurfaceProps,
        shouldCreateWithMips: bool,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface16MakeRenderTargetEP18GrRecordingContextRK25SkSurfaceCharacterization10SkBudgeted"]
    pub fn SkSurface_MakeRenderTarget1(
        context: *mut GrRecordingContext,
        characterization: *const SkSurfaceCharacterization,
        budgeted: SkBudgeted,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkSurface12isCompatibleERK25SkSurfaceCharacterization"]
    pub fn SkSurface_isCompatible(
        this: *const SkSurface,
        characterization: *const SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface8MakeNullEii"]
    pub fn SkSurface_MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface9imageInfoEv"]
    pub fn SkSurface_imageInfo(this: *mut SkSurface) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface12generationIDEv"]
    pub fn SkSurface_generationID(this: *mut SkSurface) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface23notifyContentWillChangeENS_17ContentChangeModeE"]
    pub fn SkSurface_notifyContentWillChange(
        this: *mut SkSurface,
        mode: SkSurface_ContentChangeMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface16recordingContextEv"]
    pub fn SkSurface_recordingContext(this: *mut SkSurface) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface17getBackendTextureENS_19BackendHandleAccessE"]
    pub fn SkSurface_getBackendTexture(
        this: *mut SkSurface,
        backendHandleAccess: SkSurface_BackendHandleAccess,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface22getBackendRenderTargetENS_19BackendHandleAccessE"]
    pub fn SkSurface_getBackendRenderTarget(
        this: *mut SkSurface,
        backendHandleAccess: SkSurface_BackendHandleAccess,
    ) -> GrBackendRenderTarget;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface21replaceBackendTextureERK16GrBackendTexture15GrSurfaceOriginNS_17ContentChangeModeEPFvPvES5_"]
    pub fn SkSurface_replaceBackendTexture(
        this: *mut SkSurface,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        mode: SkSurface_ContentChangeMode,
        textureReleaseProc: SkSurface_TextureReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface9getCanvasEv"]
    pub fn SkSurface_getCanvas(this: *mut SkSurface) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface11makeSurfaceERK11SkImageInfo"]
    pub fn SkSurface_makeSurface(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface11makeSurfaceEii"]
    pub fn SkSurface_makeSurface1(
        this: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface17makeImageSnapshotEv"]
    pub fn SkSurface_makeImageSnapshot(this: *mut SkSurface) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface17makeImageSnapshotERK7SkIRect"]
    pub fn SkSurface_makeImageSnapshot1(
        this: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface4drawEP8SkCanvasffPK7SkPaint"]
    pub fn SkSurface_draw(
        this: *mut SkSurface,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface10peekPixelsEP8SkPixmap"]
    pub fn SkSurface_peekPixels(this: *mut SkSurface, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface10readPixelsERK8SkPixmapii"]
    pub fn SkSurface_readPixels(
        this: *mut SkSurface,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkSurface_readPixels1(
        this: *mut SkSurface,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface10readPixelsERK8SkBitmapii"]
    pub fn SkSurface_readPixels2(
        this: *mut SkSurface,
        dst: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectN7SkImage12RescaleGammaE15SkFilterQualityPFvPvSt10unique_ptrIKNS6_15AsyncReadResultESt14default_deleteISC_EEES9_"]
    pub fn SkSurface_asyncRescaleAndReadPixels(
        this: *mut SkSurface,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeN7SkImage12RescaleGammaE15SkFilterQualityPFvPvSt10unique_ptrIKNSA_15AsyncReadResultESt14default_deleteISG_EEESD_"]
    pub fn SkSurface_asyncRescaleAndReadPixelsYUV420(
        this: *mut SkSurface,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface11writePixelsERK8SkPixmapii"]
    pub fn SkSurface_writePixels(
        this: *mut SkSurface,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface11writePixelsERK8SkBitmapii"]
    pub fn SkSurface_writePixels1(
        this: *mut SkSurface,
        src: *const SkBitmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface14flushAndSubmitEb"]
    pub fn SkSurface_flushAndSubmit(this: *mut SkSurface, syncCpu: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface5flushENS_20BackendSurfaceAccessERK11GrFlushInfo"]
    pub fn SkSurface_flush(
        this: *mut SkSurface,
        access: SkSurface_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface5flushERK11GrFlushInfoPK28GrBackendSurfaceMutableState"]
    pub fn SkSurface_flush1(
        this: *mut SkSurface,
        info: *const GrFlushInfo,
        newState: *const GrBackendSurfaceMutableState,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface4waitEiPK18GrBackendSemaphoreb"]
    pub fn SkSurface_wait(
        this: *mut SkSurface,
        numSemaphores: ::std::os::raw::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkSurface12characterizeEP25SkSurfaceCharacterization"]
    pub fn SkSurface_characterize(
        this: *const SkSurface,
        characterization: *mut SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface4drawE5sk_spIK21SkDeferredDisplayListEii"]
    pub fn SkSurface_draw1(
        this: *mut SkSurface,
        deferredDisplayList: sk_sp<SkDeferredDisplayList>,
        xOffset: ::std::os::raw::c_int,
        yOffset: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurfaceC1EiiPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface(
        this: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurfaceC1ERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface1(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
        surfaceProps: *const SkSurfaceProps,
    );
}
impl SkSurface {
    #[inline]
    pub unsafe fn MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirect(imageInfo, pixels, rowBytes, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeRasterDirectReleaseProc(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(
                pixels: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirectReleaseProc(
            imageInfo,
            pixels,
            rowBytes,
            releaseProc,
            context,
            surfaceProps,
        )
    }
    #[inline]
    pub unsafe fn MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRaster(imageInfo, rowBytes, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterN32Premul(width, height, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeFromBackendTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        sampleCnt: ::std::os::raw::c_int,
        colorType: SkColorType,
        colorSpace: sk_sp<SkColorSpace>,
        surfaceProps: *const SkSurfaceProps,
        textureReleaseProc: SkSurface_TextureReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeFromBackendTexture(
            context,
            backendTexture,
            origin,
            sampleCnt,
            colorType,
            colorSpace,
            surfaceProps,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeFromBackendRenderTarget(
        context: *mut GrRecordingContext,
        backendRenderTarget: *const GrBackendRenderTarget,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        colorSpace: sk_sp<SkColorSpace>,
        surfaceProps: *const SkSurfaceProps,
        releaseProc: SkSurface_RenderTargetReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeFromBackendRenderTarget(
            context,
            backendRenderTarget,
            origin,
            colorType,
            colorSpace,
            surfaceProps,
            releaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn MakeRenderTarget(
        context: *mut GrRecordingContext,
        budgeted: SkBudgeted,
        imageInfo: *const SkImageInfo,
        sampleCount: ::std::os::raw::c_int,
        surfaceOrigin: GrSurfaceOrigin,
        surfaceProps: *const SkSurfaceProps,
        shouldCreateWithMips: bool,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRenderTarget(
            context,
            budgeted,
            imageInfo,
            sampleCount,
            surfaceOrigin,
            surfaceProps,
            shouldCreateWithMips,
        )
    }
    #[inline]
    pub unsafe fn MakeRenderTarget1(
        context: *mut GrRecordingContext,
        characterization: *const SkSurfaceCharacterization,
        budgeted: SkBudgeted,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRenderTarget1(context, characterization, budgeted)
    }
    #[inline]
    pub unsafe fn isCompatible(&self, characterization: *const SkSurfaceCharacterization) -> bool {
        SkSurface_isCompatible(self, characterization)
    }
    #[inline]
    pub unsafe fn MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeNull(width, height)
    }
    #[inline]
    pub unsafe fn imageInfo(&mut self) -> SkImageInfo {
        SkSurface_imageInfo(self)
    }
    #[inline]
    pub unsafe fn generationID(&mut self) -> u32 {
        SkSurface_generationID(self)
    }
    #[inline]
    pub unsafe fn notifyContentWillChange(&mut self, mode: SkSurface_ContentChangeMode) {
        SkSurface_notifyContentWillChange(self, mode)
    }
    #[inline]
    pub unsafe fn recordingContext(&mut self) -> *mut GrRecordingContext {
        SkSurface_recordingContext(self)
    }
    #[inline]
    pub unsafe fn getBackendTexture(
        &mut self,
        backendHandleAccess: SkSurface_BackendHandleAccess,
    ) -> GrBackendTexture {
        SkSurface_getBackendTexture(self, backendHandleAccess)
    }
    #[inline]
    pub unsafe fn getBackendRenderTarget(
        &mut self,
        backendHandleAccess: SkSurface_BackendHandleAccess,
    ) -> GrBackendRenderTarget {
        SkSurface_getBackendRenderTarget(self, backendHandleAccess)
    }
    #[inline]
    pub unsafe fn replaceBackendTexture(
        &mut self,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        mode: SkSurface_ContentChangeMode,
        textureReleaseProc: SkSurface_TextureReleaseProc,
        releaseContext: SkSurface_ReleaseContext,
    ) -> bool {
        SkSurface_replaceBackendTexture(
            self,
            backendTexture,
            origin,
            mode,
            textureReleaseProc,
            releaseContext,
        )
    }
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkSurface_getCanvas(self)
    }
    #[inline]
    pub unsafe fn makeSurface(&mut self, imageInfo: *const SkImageInfo) -> sk_sp<SkSurface> {
        SkSurface_makeSurface(self, imageInfo)
    }
    #[inline]
    pub unsafe fn makeSurface1(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface> {
        SkSurface_makeSurface1(self, width, height)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot(&mut self) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot(self)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot1(&mut self, bounds: *const SkIRect) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot1(self, bounds)
    }
    #[inline]
    pub unsafe fn draw(
        &mut self,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    ) {
        SkSurface_draw(self, canvas, x, y, paint)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkSurface_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels1(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        dst: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels2(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &mut self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleQuality,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &mut self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleQuality: SkFilterQuality,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleQuality,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) {
        SkSurface_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        src: *const SkBitmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) {
        SkSurface_writePixels1(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn flushAndSubmit(&mut self, syncCpu: bool) {
        SkSurface_flushAndSubmit(self, syncCpu)
    }
    #[inline]
    pub unsafe fn flush(
        &mut self,
        access: SkSurface_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted {
        SkSurface_flush(self, access, info)
    }
    #[inline]
    pub unsafe fn flush1(
        &mut self,
        info: *const GrFlushInfo,
        newState: *const GrBackendSurfaceMutableState,
    ) -> GrSemaphoresSubmitted {
        SkSurface_flush1(self, info, newState)
    }
    #[inline]
    pub unsafe fn wait(
        &mut self,
        numSemaphores: ::std::os::raw::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool {
        SkSurface_wait(
            self,
            numSemaphores,
            waitSemaphores,
            deleteSemaphoresAfterWait,
        )
    }
    #[inline]
    pub unsafe fn characterize(&self, characterization: *mut SkSurfaceCharacterization) -> bool {
        SkSurface_characterize(self, characterization)
    }
    #[inline]
    pub unsafe fn draw1(
        &mut self,
        deferredDisplayList: sk_sp<SkDeferredDisplayList>,
        xOffset: ::std::os::raw::c_int,
        yOffset: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_draw1(self, deferredDisplayList, xOffset, yOffset)
    }
    #[inline]
    pub unsafe fn new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface(__bindgen_tmp.as_mut_ptr(), width, height, surfaceProps);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(imageInfo: *const SkImageInfo, surfaceProps: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface1(__bindgen_tmp.as_mut_ptr(), imageInfo, surfaceProps);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface30kFlushRead_TextureHandleAccessE"]
    pub static SkSurface_kFlushRead_TextureHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface31kFlushWrite_TextureHandleAccessE"]
    pub static SkSurface_kFlushWrite_TextureHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkSurface33kDiscardWrite_TextureHandleAccessE"]
    pub static SkSurface_kDiscardWrite_TextureHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}_Z8SkSwapRBPjPKji"]
    pub fn SkSwapRB(dest: *mut u32, src: *const u32, count: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob {
    pub _base: SkNVRefCnt,
    pub fBounds: SkRect,
    pub fUniqueID: u32,
    pub fCacheID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_RunRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter {
    pub fRunRecord: *const SkTextBlob_RunRecord,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter_Run {
    pub fTypeface: *mut SkTypeface,
    pub fGlyphCount: ::std::os::raw::c_int,
    pub fGlyphIndices: *const u16,
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter_Run() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter_Run>(),
        24usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter_Run))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter_Run>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter_Run))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlob_Iter_Run>())).fTypeface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fTypeface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlob_Iter_Run>())).fGlyphCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fGlyphCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlob_Iter_Run>())).fGlyphIndices as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fGlyphIndices)
        )
    );
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlob_Iter>())).fRunRecord as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter),
            "::",
            stringify!(fRunRecord)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob4Iter4nextEPNS0_3RunE"]
    pub fn SkTextBlob_Iter_next(this: *mut SkTextBlob_Iter, arg1: *mut SkTextBlob_Iter_Run)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob4IterC1ERKS_"]
    pub fn SkTextBlob_Iter_Iter(this: *mut SkTextBlob_Iter, arg1: *const SkTextBlob);
}
impl SkTextBlob_Iter {
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkTextBlob_Iter_Run) -> bool {
        SkTextBlob_Iter_next(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkTextBlob) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlob_Iter_Iter(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextBlob_GlyphPositioning {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub type SkTextBlob_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkTextBlob() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob>(),
        28usize,
        concat!("Size of: ", stringify!(SkTextBlob))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob>(),
        4usize,
        concat!("Alignment of ", stringify!(SkTextBlob))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlob>())).fBounds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlob>())).fUniqueID as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlob>())).fCacheID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fCacheID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTextBlob13getInterceptsEPKfPfPK7SkPaint"]
    pub fn SkTextBlob_getIntercepts(
        this: *const SkTextBlob,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob12MakeFromTextEPKvmRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob16MakeFromPosTextHEPKvmPKffRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob15MakeFromPosTextEPKvmPK7SkPointRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob15MakeFromRSXformEPKvmPK9SkRSXformRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTextBlob9serializeERK13SkSerialProcsPvm"]
    pub fn SkTextBlob_serialize(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkTextBlob9serializeERK13SkSerialProcs"]
    pub fn SkTextBlob_serialize1(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkTextBlob11DeserializeEPKvmRK15SkDeserialProcs"]
    pub fn SkTextBlob_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob>;
}
impl SkTextBlob {
    #[inline]
    pub unsafe fn getIntercepts(
        &self,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int {
        SkTextBlob_getIntercepts(self, bounds, intervals, paint)
    }
    #[inline]
    pub unsafe fn MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromText(text, byteLength, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosTextH(text, byteLength, xpos, constY, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosText(text, byteLength, pos, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromRSXform(text, byteLength, xform, font, encoding)
    }
    #[inline]
    pub unsafe fn serialize(
        &self,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize {
        SkTextBlob_serialize(self, procs, memory, memory_size)
    }
    #[inline]
    pub unsafe fn serialize1(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkTextBlob_serialize1(self, procs)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlobBuilder {
    pub fStorage: u64,
    pub fStorageSize: usize,
    pub fStorageUsed: usize,
    pub fBounds: SkRect,
    pub fRunCount: ::std::os::raw::c_int,
    pub fDeferredBounds: bool,
    pub fLastRun: usize,
    pub fCurrentRunBuffer: SkTextBlobBuilder_RunBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlobBuilder_RunBuffer {
    pub glyphs: *mut SkGlyphID,
    pub pos: *mut SkScalar,
    pub utf8text: *mut ::std::os::raw::c_char,
    pub clusters: *mut u32,
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder_RunBuffer() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder_RunBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder_RunBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder_RunBuffer>())).glyphs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder_RunBuffer>())).pos as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder_RunBuffer>())).utf8text as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(utf8text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder_RunBuffer>())).clusters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(clusters)
        )
    );
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fStorage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fStorageSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fStorageUsed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorageUsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fBounds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fRunCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fRunCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder>())).fDeferredBounds as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fDeferredBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTextBlobBuilder>())).fLastRun as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fLastRun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTextBlobBuilder>())).fCurrentRunBuffer as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fCurrentRunBuffer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilder4makeEv"]
    pub fn SkTextBlobBuilder_make(this: *mut SkTextBlobBuilder) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilder8allocRunERK6SkFontiffPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRun(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilder12allocRunPosHERK6SkFontifPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPosH(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilder11allocRunPosERK6SkFontiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPos(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilder15allocRunRSXformERK6SkFonti"]
    pub fn SkTextBlobBuilder_allocRunRSXform(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilderC1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder(this: *mut SkTextBlobBuilder);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTextBlobBuilderD1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder_destructor(this: *mut SkTextBlobBuilder);
}
impl SkTextBlobBuilder {
    #[inline]
    pub unsafe fn make(&mut self) -> sk_sp<SkTextBlob> {
        SkTextBlobBuilder_make(self)
    }
    #[inline]
    pub unsafe fn allocRun(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRun(self, font, count, x, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPosH(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPosH(self, font, count, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPos(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPos(self, font, count, bounds)
    }
    #[inline]
    pub unsafe fn allocRunRSXform(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunRSXform(self, font, count)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlobBuilder_SkTextBlobBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkTextBlobBuilder_SkTextBlobBuilder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices {
    pub _base: SkNVRefCnt,
    pub fUniqueID: u32,
    pub fAttributes: *mut SkVertices_Attribute,
    pub fPositions: *mut SkPoint,
    pub fIndices: *mut u16,
    pub fCustomData: *mut ::core::ffi::c_void,
    pub fTexs: *mut SkPoint,
    pub fColors: *mut SkColor,
    pub fBounds: SkRect,
    pub fVertexCount: ::std::os::raw::c_int,
    pub fIndexCount: ::std::os::raw::c_int,
    pub fAttributeCount: ::std::os::raw::c_int,
    pub fMode: SkVertices_VertexMode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Sizes {
    _unused: [u8; 0],
}
impl SkVertices_VertexMode {
    pub const Last: SkVertices_VertexMode = SkVertices_VertexMode::TriangleFan;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkVertices_VertexMode {
    Triangles = 0,
    TriangleStrip = 1,
    TriangleFan = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Attribute {
    pub fType: SkVertices_Attribute_Type,
    pub fUsage: SkVertices_Attribute_Usage,
    pub fMarkerID: u32,
    pub fMarkerName: *const ::std::os::raw::c_char,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkVertices_Attribute_Type {
    Float = 0,
    Float2 = 1,
    Float3 = 2,
    Float4 = 3,
    Byte4_unorm = 4,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkVertices_Attribute_Usage {
    Raw = 0,
    Color = 1,
    Vector = 2,
    NormalVector = 3,
    Position = 4,
}
#[test]
fn bindgen_test_layout_SkVertices_Attribute() {
    assert_eq!(
        ::core::mem::size_of::<SkVertices_Attribute>(),
        16usize,
        concat!("Size of: ", stringify!(SkVertices_Attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices_Attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices_Attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices_Attribute>())).fType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Attribute),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices_Attribute>())).fUsage as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Attribute),
            "::",
            stringify!(fUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices_Attribute>())).fMarkerID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Attribute),
            "::",
            stringify!(fMarkerID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkVertices_Attribute>())).fMarkerName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Attribute),
            "::",
            stringify!(fMarkerName)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkVertices9Attribute12channelCountEv"]
    pub fn SkVertices_Attribute_channelCount(
        this: *const SkVertices_Attribute,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkVertices9Attribute14bytesPerVertexEv"]
    pub fn SkVertices_Attribute_bytesPerVertex(this: *const SkVertices_Attribute) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkVertices9Attribute7isValidEv"]
    pub fn SkVertices_Attribute_isValid(this: *const SkVertices_Attribute) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices9AttributeC1ENS0_4TypeENS0_5UsageEPKc"]
    pub fn SkVertices_Attribute_Attribute(
        this: *mut SkVertices_Attribute,
        t: SkVertices_Attribute_Type,
        u: SkVertices_Attribute_Usage,
        markerName: *const ::std::os::raw::c_char,
    );
}
impl SkVertices_Attribute {
    #[inline]
    pub unsafe fn channelCount(&self) -> ::std::os::raw::c_int {
        SkVertices_Attribute_channelCount(self)
    }
    #[inline]
    pub unsafe fn bytesPerVertex(&self) -> usize {
        SkVertices_Attribute_bytesPerVertex(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkVertices_Attribute_isValid(self)
    }
    #[inline]
    pub unsafe fn new(
        t: SkVertices_Attribute_Type,
        u: SkVertices_Attribute_Usage,
        markerName: *const ::std::os::raw::c_char,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkVertices_Attribute_Attribute(__bindgen_tmp.as_mut_ptr(), t, u, markerName);
        __bindgen_tmp.assume_init()
    }
}
pub const SkVertices_BuilderFlags_kHasTexCoords_BuilderFlag: SkVertices_BuilderFlags = 1;
pub const SkVertices_BuilderFlags_kHasColors_BuilderFlag: SkVertices_BuilderFlags = 2;
pub type SkVertices_BuilderFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices_Builder {
    pub fVertices: sk_sp<SkVertices>,
    pub fIntermediateFanIndices: u64,
}
#[test]
fn bindgen_test_layout_SkVertices_Builder() {
    assert_eq!(
        ::core::mem::size_of::<SkVertices_Builder>(),
        16usize,
        concat!("Size of: ", stringify!(SkVertices_Builder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices_Builder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices_Builder>())).fVertices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Builder),
            "::",
            stringify!(fVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkVertices_Builder>())).fIntermediateFanIndices as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Builder),
            "::",
            stringify!(fIntermediateFanIndices)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder9positionsEv"]
    pub fn SkVertices_Builder_positions(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder7indicesEv"]
    pub fn SkVertices_Builder_indices(this: *mut SkVertices_Builder) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder10customDataEv"]
    pub fn SkVertices_Builder_customData(this: *mut SkVertices_Builder)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder9texCoordsEv"]
    pub fn SkVertices_Builder_texCoords(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder6colorsEv"]
    pub fn SkVertices_Builder_colors(this: *mut SkVertices_Builder) -> *mut SkColor;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7Builder6detachEv"]
    pub fn SkVertices_Builder_detach(this: *mut SkVertices_Builder) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7BuilderC1ENS_10VertexModeEiij"]
    pub fn SkVertices_Builder_Builder(
        this: *mut SkVertices_Builder,
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        flags: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices7BuilderC1ENS_10VertexModeEiiPKNS_9AttributeEi"]
    pub fn SkVertices_Builder_Builder1(
        this: *mut SkVertices_Builder,
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        attrs: *const SkVertices_Attribute,
        attrCount: ::std::os::raw::c_int,
    );
}
impl SkVertices_Builder {
    #[inline]
    pub unsafe fn positions(&mut self) -> *mut SkPoint {
        SkVertices_Builder_positions(self)
    }
    #[inline]
    pub unsafe fn indices(&mut self) -> *mut u16 {
        SkVertices_Builder_indices(self)
    }
    #[inline]
    pub unsafe fn customData(&mut self) -> *mut ::core::ffi::c_void {
        SkVertices_Builder_customData(self)
    }
    #[inline]
    pub unsafe fn texCoords(&mut self) -> *mut SkPoint {
        SkVertices_Builder_texCoords(self)
    }
    #[inline]
    pub unsafe fn colors(&mut self) -> *mut SkColor {
        SkVertices_Builder_colors(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkVertices> {
        SkVertices_Builder_detach(self)
    }
    #[inline]
    pub unsafe fn new(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        flags: u32,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkVertices_Builder_Builder(
            __bindgen_tmp.as_mut_ptr(),
            mode,
            vertexCount,
            indexCount,
            flags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        attrs: *const SkVertices_Attribute,
        attrCount: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkVertices_Builder_Builder1(
            __bindgen_tmp.as_mut_ptr(),
            mode,
            vertexCount,
            indexCount,
            attrs,
            attrCount,
        );
        __bindgen_tmp.assume_init()
    }
}
pub const SkVertices_kMaxCustomAttributes: ::std::os::raw::c_int = 8;
#[test]
fn bindgen_test_layout_SkVertices() {
    assert_eq!(
        ::core::mem::size_of::<SkVertices>(),
        88usize,
        concat!("Size of: ", stringify!(SkVertices))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fUniqueID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fAttributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fPositions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fPositions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fIndices as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fCustomData as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fCustomData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fTexs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fTexs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fColors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fBounds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fVertexCount as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fVertexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fIndexCount as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fIndexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fAttributeCount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fAttributeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkVertices>())).fMode as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fMode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjiPKt"]
    pub fn SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkVertices15approximateSizeEv"]
    pub fn SkVertices_approximateSize(this: *const SkVertices) -> usize;
}
impl SkVertices {
    #[inline]
    pub unsafe fn MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices> {
        SkVertices_MakeCopy(
            mode,
            vertexCount,
            positions,
            texs,
            colors,
            indexCount,
            indices,
        )
    }
    #[inline]
    pub unsafe fn approximateSize(&self) -> usize {
        SkVertices_approximateSize(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTime_DateTime {
    pub fTimeZoneMinutes: i16,
    pub fYear: u16,
    pub fMonth: u8,
    pub fDayOfWeek: u8,
    pub fDay: u8,
    pub fHour: u8,
    pub fMinute: u8,
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_SkTime_DateTime() {
    assert_eq!(
        ::core::mem::size_of::<SkTime_DateTime>(),
        10usize,
        concat!("Size of: ", stringify!(SkTime_DateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTime_DateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(SkTime_DateTime))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkTime_DateTime>())).fTimeZoneMinutes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fTimeZoneMinutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fYear as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fMonth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fDayOfWeek as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fDay as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fHour as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fMinute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkTime_DateTime>())).fSecond as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fSecond)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6SkTime8DateTime9toISO8601EP8SkString"]
    pub fn SkTime_DateTime_toISO8601(this: *const SkTime_DateTime, dst: *mut SkString);
}
impl SkTime_DateTime {
    #[inline]
    pub unsafe fn toISO8601(&self, dst: *mut SkString) {
        SkTime_DateTime_toISO8601(self, dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkExecutor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPDFArray {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPDF_DocumentStructureType {
    Document = 0,
    Part = 1,
    Art = 2,
    Sect = 3,
    Div = 4,
    BlockQuote = 5,
    Caption = 6,
    TOC = 7,
    TOCI = 8,
    Index = 9,
    NonStruct = 10,
    Private = 11,
    H = 12,
    H1 = 13,
    H2 = 14,
    H3 = 15,
    H4 = 16,
    H5 = 17,
    H6 = 18,
    P = 19,
    L = 20,
    LI = 21,
    Lbl = 22,
    LBody = 23,
    Table = 24,
    TR = 25,
    TH = 26,
    TD = 27,
    THead = 28,
    TBody = 29,
    TFoot = 30,
    Span = 31,
    Quote = 32,
    Note = 33,
    Reference = 34,
    BibEntry = 35,
    Code = 36,
    Link = 37,
    Annot = 38,
    Ruby = 39,
    RB = 40,
    RT = 41,
    RP = 42,
    Warichu = 43,
    WT = 44,
    WP = 45,
    Figure = 46,
    Formula = 47,
    Form = 48,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_AttributeList {
    pub fAttrs: u64,
}
#[test]
fn bindgen_test_layout_SkPDF_AttributeList() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Size of: ", stringify!(SkPDF_AttributeList))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_AttributeList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_AttributeList>())).fAttrs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_AttributeList),
            "::",
            stringify!(fAttrs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList9appendIntEPKcS2_i"]
    pub fn SkPDF_AttributeList_appendInt(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList11appendFloatEPKcS2_f"]
    pub fn SkPDF_AttributeList_appendFloat(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList10appendNameEPKcS2_S2_"]
    pub fn SkPDF_AttributeList_appendName(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList12appendStringEPKcS2_S2_"]
    pub fn SkPDF_AttributeList_appendString(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList16appendFloatArrayEPKcS2_RKSt6vectorIfSaIfEE"]
    pub fn SkPDF_AttributeList_appendFloatArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList17appendStringArrayEPKcS2_RKSt6vectorI8SkStringSaIS4_EE"]
    pub fn SkPDF_AttributeList_appendStringArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        values: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeList17appendNodeIdArrayEPKcS2_RKSt6vectorIiSaIiEE"]
    pub fn SkPDF_AttributeList_appendNodeIdArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        nodeIds: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeListC1Ev"]
    pub fn SkPDF_AttributeList_AttributeList(this: *mut SkPDF_AttributeList);
}
extern "C" {
    #[link_name = "\u{1}_ZN5SkPDF13AttributeListD1Ev"]
    pub fn SkPDF_AttributeList_AttributeList_destructor(this: *mut SkPDF_AttributeList);
}
impl SkPDF_AttributeList {
    #[inline]
    pub unsafe fn appendInt(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) {
        SkPDF_AttributeList_appendInt(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendFloat(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: f32,
    ) {
        SkPDF_AttributeList_appendFloat(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendName(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) {
        SkPDF_AttributeList_appendName(self, owner, attrName, value)
    }
    #[inline]
    pub unsafe fn appendString(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) {
        SkPDF_AttributeList_appendString(self, owner, attrName, value)
    }
    #[inline]
    pub unsafe fn appendFloatArray(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendFloatArray(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendStringArray(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        values: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendStringArray(self, owner, attrName, values)
    }
    #[inline]
    pub unsafe fn appendNodeIdArray(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        nodeIds: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendNodeIdArray(self, owner, attrName, nodeIds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPDF_AttributeList_AttributeList(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPDF_AttributeList_AttributeList_destructor(self)
    }
}
#[repr(C)]
pub struct SkPDF_StructureElementNode {
    pub fTypeString: SkString,
    pub fChildVector: [u64; 3usize],
    pub fNodeId: ::std::os::raw::c_int,
    pub fAdditionalNodeIds: [u64; 3usize],
    pub fAttributes: SkPDF_AttributeList,
    pub fAlt: SkString,
    pub fLang: SkString,
    pub fType: SkPDF_DocumentStructureType,
}
#[test]
fn bindgen_test_layout_SkPDF_StructureElementNode() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_StructureElementNode>(),
        96usize,
        concat!("Size of: ", stringify!(SkPDF_StructureElementNode))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_StructureElementNode>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_StructureElementNode))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fTypeString as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fTypeString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fChildVector as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fChildVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fNodeId as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fNodeId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fAdditionalNodeIds as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAdditionalNodeIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fAttributes as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fAlt as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAlt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fLang as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fLang)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_StructureElementNode>())).fType as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fType)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_Metadata {
    pub fTitle: SkString,
    pub fAuthor: SkString,
    pub fSubject: SkString,
    pub fKeywords: SkString,
    pub fCreator: SkString,
    pub fProducer: SkString,
    pub fCreation: SkTime_DateTime,
    pub fModified: SkTime_DateTime,
    pub fRasterDPI: SkScalar,
    pub fPDFA: bool,
    pub fEncodingQuality: ::std::os::raw::c_int,
    pub fStructureElementTreeRoot: *mut SkPDF_StructureElementNode,
    pub fExecutor: *mut SkExecutor,
    pub fSubsetter: SkPDF_Metadata_Subsetter,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPDF_Metadata_Subsetter {
    kHarfbuzz_Subsetter = 0,
    kSfntly_Subsetter = 1,
}
#[test]
fn bindgen_test_layout_SkPDF_Metadata() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_Metadata>(),
        104usize,
        concat!("Size of: ", stringify!(SkPDF_Metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_Metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_Metadata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fTitle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fTitle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fAuthor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fAuthor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fSubject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fSubject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fKeywords as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fKeywords)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fCreator as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fCreator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fProducer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fProducer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fCreation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fCreation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fModified as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fModified)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fRasterDPI as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fRasterDPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fPDFA as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fPDFA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_Metadata>())).fEncodingQuality as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fEncodingQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPDF_Metadata>())).fStructureElementTreeRoot as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fStructureElementTreeRoot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fExecutor as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fExecutor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPDF_Metadata>())).fSubsetter as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fSubsetter)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathEffect_PointData {
    pub fFlags: u32,
    pub fPoints: *mut SkPoint,
    pub fNumPoints: ::std::os::raw::c_int,
    pub fSize: SkVector,
    pub fClipRect: SkRect,
    pub fPath: SkPath,
    pub fFirst: SkPath,
    pub fLast: SkPath,
}
pub const SkPathEffect_PointData_PointFlags_kCircles_PointFlag: SkPathEffect_PointData_PointFlags =
    1;
pub const SkPathEffect_PointData_PointFlags_kUsePath_PointFlag: SkPathEffect_PointData_PointFlags =
    2;
pub const SkPathEffect_PointData_PointFlags_kUseClip_PointFlag: SkPathEffect_PointData_PointFlags =
    4;
pub type SkPathEffect_PointData_PointFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkPathEffect_PointData() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect_PointData>(),
        96usize,
        concat!("Size of: ", stringify!(SkPathEffect_PointData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect_PointData>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect_PointData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fPoints as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPathEffect_PointData>())).fNumPoints as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fNumPoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPathEffect_PointData>())).fClipRect as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fClipRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fPath as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fPath)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fFirst as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fFirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_PointData>())).fLast as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_PointData),
            "::",
            stringify!(fLast)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathEffect_DashType {
    kNone_DashType = 0,
    kDash_DashType = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect_DashInfo {
    pub fIntervals: *mut SkScalar,
    pub fCount: i32,
    pub fPhase: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathEffect_DashInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect_DashInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect_DashInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect_DashInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect_DashInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkPathEffect_DashInfo>())).fIntervals as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fIntervals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_DashInfo>())).fCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPathEffect_DashInfo>())).fPhase as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fPhase)
        )
    );
}
pub type SkPathEffect_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkPathEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkPathEffect7MakeSumE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkPathEffect11MakeComposeE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRect"]
    pub fn SkPathEffect_filterPath(
        this: *const SkPathEffect,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkPathEffect17computeFastBoundsEP6SkRectRKS0_"]
    pub fn SkPathEffect_computeFastBounds(
        this: *const SkPathEffect,
        dst: *mut SkRect,
        src: *const SkRect,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkPathEffect8asPointsEPNS_9PointDataERK6SkPathRK11SkStrokeRecRK8SkMatrixPK6SkRect"]
    pub fn SkPathEffect_asPoints(
        this: *const SkPathEffect,
        results: *mut SkPathEffect_PointData,
        src: *const SkPath,
        arg1: *const SkStrokeRec,
        arg2: *const SkMatrix,
        cullR: *const SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12SkPathEffect7asADashEPNS_8DashInfoE"]
    pub fn SkPathEffect_asADash(
        this: *const SkPathEffect,
        info: *mut SkPathEffect_DashInfo,
    ) -> SkPathEffect_DashType;
}
extern "C" {
    #[link_name = "\u{1}_ZN12SkPathEffect20RegisterFlattenablesEv"]
    pub fn SkPathEffect_RegisterFlattenables();
}
impl SkPathEffect {
    #[inline]
    pub unsafe fn MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeSum(first, second)
    }
    #[inline]
    pub unsafe fn MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeCompose(outer, inner)
    }
    #[inline]
    pub unsafe fn filterPath(
        &self,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool {
        SkPathEffect_filterPath(self, dst, src, arg1, cullR)
    }
    #[inline]
    pub unsafe fn computeFastBounds(&self, dst: *mut SkRect, src: *const SkRect) {
        SkPathEffect_computeFastBounds(self, dst, src)
    }
    #[inline]
    pub unsafe fn asPoints(
        &self,
        results: *mut SkPathEffect_PointData,
        src: *const SkPath,
        arg1: *const SkStrokeRec,
        arg2: *const SkMatrix,
        cullR: *const SkRect,
    ) -> bool {
        SkPathEffect_asPoints(self, results, src, arg1, arg2, cullR)
    }
    #[inline]
    pub unsafe fn asADash(&self, info: *mut SkPathEffect_DashInfo) -> SkPathEffect_DashType {
        SkPathEffect_asADash(self, info)
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkPathEffect_RegisterFlattenables()
    }
}
impl SkPath1DPathEffect_Style {
    pub const LastEnum: SkPath1DPathEffect_Style = SkPath1DPathEffect_Style::Morph;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath1DPathEffect_Style {
    Translate = 0,
    Rotate = 1,
    Morph = 2,
}
impl SkBlurImageFilter_TileMode {
    pub const Last: SkBlurImageFilter_TileMode = SkBlurImageFilter_TileMode::ClampToBlack;
}
impl SkBlurImageFilter_TileMode {
    pub const Max: SkBlurImageFilter_TileMode = SkBlurImageFilter_TileMode::ClampToBlack;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlurImageFilter_TileMode {
    Clamp = 0,
    Repeat = 1,
    ClampToBlack = 2,
}
#[repr(C)]
pub struct SkColorMatrix {
    pub fMat: [u32; 20usize],
}
#[test]
fn bindgen_test_layout_SkColorMatrix() {
    assert_eq!(
        ::core::mem::size_of::<SkColorMatrix>(),
        80usize,
        concat!("Size of: ", stringify!(SkColorMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorMatrix))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkColorMatrix>())).fMat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorMatrix),
            "::",
            stringify!(fMat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkColorMatrix11setIdentityEv"]
    pub fn SkColorMatrix_setIdentity(this: *mut SkColorMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkColorMatrix8setScaleEffff"]
    pub fn SkColorMatrix_setScale(
        this: *mut SkColorMatrix,
        rScale: f32,
        gScale: f32,
        bScale: f32,
        aScale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkColorMatrix13postTranslateEffff"]
    pub fn SkColorMatrix_postTranslate(
        this: *mut SkColorMatrix,
        dr: f32,
        dg: f32,
        db: f32,
        da: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkColorMatrix9setConcatERKS_S1_"]
    pub fn SkColorMatrix_setConcat(
        this: *mut SkColorMatrix,
        a: *const SkColorMatrix,
        b: *const SkColorMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkColorMatrix13setSaturationEf"]
    pub fn SkColorMatrix_setSaturation(this: *mut SkColorMatrix, sat: f32);
}
impl SkColorMatrix {
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        SkColorMatrix_setIdentity(self)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, rScale: f32, gScale: f32, bScale: f32, aScale: f32) {
        SkColorMatrix_setScale(self, rScale, gScale, bScale, aScale)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dr: f32, dg: f32, db: f32, da: f32) {
        SkColorMatrix_postTranslate(self, dr, dg, db, da)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkColorMatrix, b: *const SkColorMatrix) {
        SkColorMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn setSaturation(&mut self, sat: f32) {
        SkColorMatrix_setSaturation(self, sat)
    }
}
impl SkDisplacementMapEffect_ChannelSelectorType {
    pub const Last: SkDisplacementMapEffect_ChannelSelectorType =
        SkDisplacementMapEffect_ChannelSelectorType::A;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDisplacementMapEffect_ChannelSelectorType {
    Unknown = 0,
    R = 1,
    G = 2,
    B = 3,
    A = 4,
}
impl SkDropShadowImageFilter_ShadowMode {
    pub const Last: SkDropShadowImageFilter_ShadowMode =
        SkDropShadowImageFilter_ShadowMode::DrawShadowOnly;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDropShadowImageFilter_ShadowMode {
    DrawShadowAndForeground = 0,
    DrawShadowOnly = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGradientShader {
    pub _address: u8,
}
pub const SkGradientShader_Flags_kInterpolateColorsInPremul_Flag: SkGradientShader_Flags = 1;
pub type SkGradientShader_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkGradientShader() {
    assert_eq!(
        ::core::mem::size_of::<SkGradientShader>(),
        1usize,
        concat!("Size of: ", stringify!(SkGradientShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGradientShader>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGradientShader))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader10MakeLinearEPK7SkPointPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader10MakeLinearEPK7SkPointPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader10MakeRadialERK7SkPointfPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader10MakeRadialERK7SkPointfPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader9MakeSweepEffPKjPKfi10SkTileModeffjPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader9MakeSweepEffPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeffjPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN16SkGradientShader20RegisterFlattenablesEv"]
    pub fn SkGradientShader_RegisterFlattenables();
}
impl SkGradientShader {
    #[inline]
    pub unsafe fn MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear(pts, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear1(
            pts,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial(center, radius, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial1(
            center,
            radius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical1(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep(
            cx,
            cy,
            colors,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep1(
            cx,
            cy,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkGradientShader_RegisterFlattenables()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkHighContrastConfig {
    pub fGrayscale: bool,
    pub fInvertStyle: SkHighContrastConfig_InvertStyle,
    pub fContrast: SkScalar,
}
impl SkHighContrastConfig_InvertStyle {
    pub const Last: SkHighContrastConfig_InvertStyle =
        SkHighContrastConfig_InvertStyle::InvertLightness;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkHighContrastConfig_InvertStyle {
    NoInvert = 0,
    InvertBrightness = 1,
    InvertLightness = 2,
}
#[test]
fn bindgen_test_layout_SkHighContrastConfig() {
    assert_eq!(
        ::core::mem::size_of::<SkHighContrastConfig>(),
        12usize,
        concat!("Size of: ", stringify!(SkHighContrastConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SkHighContrastConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(SkHighContrastConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkHighContrastConfig>())).fGrayscale as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fGrayscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkHighContrastConfig>())).fInvertStyle as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fInvertStyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkHighContrastConfig>())).fContrast as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fContrast)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkLayerDrawLooper {
    pub _base: SkDrawLooper,
    pub fRecs: *mut SkLayerDrawLooper_Rec,
    pub fCount: ::std::os::raw::c_int,
}
pub const SkLayerDrawLooper_Bits_kStyle_Bit: SkLayerDrawLooper_Bits = 1;
pub const SkLayerDrawLooper_Bits_kPathEffect_Bit: SkLayerDrawLooper_Bits = 4;
pub const SkLayerDrawLooper_Bits_kMaskFilter_Bit: SkLayerDrawLooper_Bits = 8;
pub const SkLayerDrawLooper_Bits_kShader_Bit: SkLayerDrawLooper_Bits = 16;
pub const SkLayerDrawLooper_Bits_kColorFilter_Bit: SkLayerDrawLooper_Bits = 32;
pub const SkLayerDrawLooper_Bits_kXfermode_Bit: SkLayerDrawLooper_Bits = 64;
pub const SkLayerDrawLooper_Bits_kEntirePaint_Bits: SkLayerDrawLooper_Bits = -1;
pub type SkLayerDrawLooper_Bits = ::std::os::raw::c_int;
pub type SkLayerDrawLooper_BitFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkLayerDrawLooper_LayerInfo {
    pub fPaintBits: SkLayerDrawLooper_BitFlags,
    pub fColorMode: SkBlendMode,
    pub fOffset: SkVector,
    pub fPostTranslate: bool,
}
#[test]
fn bindgen_test_layout_SkLayerDrawLooper_LayerInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkLayerDrawLooper_LayerInfo>(),
        20usize,
        concat!("Size of: ", stringify!(SkLayerDrawLooper_LayerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkLayerDrawLooper_LayerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkLayerDrawLooper_LayerInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_LayerInfo>())).fPaintBits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_LayerInfo),
            "::",
            stringify!(fPaintBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_LayerInfo>())).fColorMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_LayerInfo),
            "::",
            stringify!(fColorMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_LayerInfo>())).fOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_LayerInfo),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_LayerInfo>())).fPostTranslate as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_LayerInfo),
            "::",
            stringify!(fPostTranslate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper9LayerInfoC1Ev"]
    pub fn SkLayerDrawLooper_LayerInfo_LayerInfo(this: *mut SkLayerDrawLooper_LayerInfo);
}
impl SkLayerDrawLooper_LayerInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkLayerDrawLooper_LayerInfo_LayerInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkLayerDrawLooper_Rec {
    pub fNext: *mut SkLayerDrawLooper_Rec,
    pub fPaint: SkPaint,
    pub fInfo: SkLayerDrawLooper_LayerInfo,
}
#[test]
fn bindgen_test_layout_SkLayerDrawLooper_Rec() {
    assert_eq!(
        ::core::mem::size_of::<SkLayerDrawLooper_Rec>(),
        104usize,
        concat!("Size of: ", stringify!(SkLayerDrawLooper_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkLayerDrawLooper_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkLayerDrawLooper_Rec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkLayerDrawLooper_Rec>())).fNext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Rec),
            "::",
            stringify!(fNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkLayerDrawLooper_Rec>())).fPaint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Rec),
            "::",
            stringify!(fPaint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkLayerDrawLooper_Rec>())).fInfo as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Rec),
            "::",
            stringify!(fInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkLayerDrawLooper_LayerDrawLooperContext {
    pub _base: SkDrawLooper_Context,
    pub fCurrRec: *mut SkLayerDrawLooper_Rec,
}
#[test]
fn bindgen_test_layout_SkLayerDrawLooper_LayerDrawLooperContext() {
    assert_eq!(
        ::core::mem::size_of::<SkLayerDrawLooper_LayerDrawLooperContext>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SkLayerDrawLooper_LayerDrawLooperContext)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkLayerDrawLooper_LayerDrawLooperContext>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkLayerDrawLooper_LayerDrawLooperContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_LayerDrawLooperContext>())).fCurrRec
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_LayerDrawLooperContext),
            "::",
            stringify!(fCurrRec)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper22LayerDrawLooperContextC1EPKS_"]
    pub fn SkLayerDrawLooper_LayerDrawLooperContext_LayerDrawLooperContext(
        this: *mut SkLayerDrawLooper_LayerDrawLooperContext,
        looper: *const SkLayerDrawLooper,
    );
}
impl SkLayerDrawLooper_LayerDrawLooperContext {
    #[inline]
    pub unsafe fn new(looper: *const SkLayerDrawLooper) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkLayerDrawLooper_LayerDrawLooperContext_LayerDrawLooperContext(
            __bindgen_tmp.as_mut_ptr(),
            looper,
        );
        __bindgen_tmp.assume_init()
    }
}
pub type SkLayerDrawLooper_INHERITED = SkDrawLooper;
#[repr(C)]
#[derive(Debug)]
pub struct SkLayerDrawLooper_Builder {
    pub fRecs: *mut SkLayerDrawLooper_Rec,
    pub fTopRec: *mut SkLayerDrawLooper_Rec,
    pub fCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkLayerDrawLooper_Builder() {
    assert_eq!(
        ::core::mem::size_of::<SkLayerDrawLooper_Builder>(),
        24usize,
        concat!("Size of: ", stringify!(SkLayerDrawLooper_Builder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkLayerDrawLooper_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkLayerDrawLooper_Builder))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_Builder>())).fRecs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Builder),
            "::",
            stringify!(fRecs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_Builder>())).fTopRec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Builder),
            "::",
            stringify!(fTopRec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkLayerDrawLooper_Builder>())).fCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper_Builder),
            "::",
            stringify!(fCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7Builder8addLayerERKNS_9LayerInfoE"]
    pub fn SkLayerDrawLooper_Builder_addLayer(
        this: *mut SkLayerDrawLooper_Builder,
        arg1: *const SkLayerDrawLooper_LayerInfo,
    ) -> *mut SkPaint;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7Builder8addLayerEff"]
    pub fn SkLayerDrawLooper_Builder_addLayer1(
        this: *mut SkLayerDrawLooper_Builder,
        dx: SkScalar,
        dy: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7Builder13addLayerOnTopERKNS_9LayerInfoE"]
    pub fn SkLayerDrawLooper_Builder_addLayerOnTop(
        this: *mut SkLayerDrawLooper_Builder,
        arg1: *const SkLayerDrawLooper_LayerInfo,
    ) -> *mut SkPaint;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7Builder6detachEv"]
    pub fn SkLayerDrawLooper_Builder_detach(
        this: *mut SkLayerDrawLooper_Builder,
    ) -> sk_sp<SkDrawLooper>;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7BuilderC1Ev"]
    pub fn SkLayerDrawLooper_Builder_Builder(this: *mut SkLayerDrawLooper_Builder);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper7BuilderD1Ev"]
    pub fn SkLayerDrawLooper_Builder_Builder_destructor(this: *mut SkLayerDrawLooper_Builder);
}
impl SkLayerDrawLooper_Builder {
    #[inline]
    pub unsafe fn addLayer(&mut self, arg1: *const SkLayerDrawLooper_LayerInfo) -> *mut SkPaint {
        SkLayerDrawLooper_Builder_addLayer(self, arg1)
    }
    #[inline]
    pub unsafe fn addLayer1(&mut self, dx: SkScalar, dy: SkScalar) {
        SkLayerDrawLooper_Builder_addLayer1(self, dx, dy)
    }
    #[inline]
    pub unsafe fn addLayerOnTop(
        &mut self,
        arg1: *const SkLayerDrawLooper_LayerInfo,
    ) -> *mut SkPaint {
        SkLayerDrawLooper_Builder_addLayerOnTop(self, arg1)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkDrawLooper> {
        SkLayerDrawLooper_Builder_detach(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkLayerDrawLooper_Builder_Builder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkLayerDrawLooper_Builder_Builder_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_SkLayerDrawLooper() {
    assert_eq!(
        ::core::mem::size_of::<SkLayerDrawLooper>(),
        32usize,
        concat!("Size of: ", stringify!(SkLayerDrawLooper))
    );
    assert_eq!(
        ::core::mem::align_of::<SkLayerDrawLooper>(),
        8usize,
        concat!("Alignment of ", stringify!(SkLayerDrawLooper))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkLayerDrawLooper>())).fRecs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper),
            "::",
            stringify!(fRecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkLayerDrawLooper>())).fCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkLayerDrawLooper),
            "::",
            stringify!(fCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooperC1Ev"]
    pub fn SkLayerDrawLooper_SkLayerDrawLooper(this: *mut SkLayerDrawLooper);
}
impl SkLayerDrawLooper {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkLayerDrawLooper_SkLayerDrawLooper(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooperD1Ev"]
    pub fn SkLayerDrawLooper_SkLayerDrawLooper_destructor(this: *mut SkLayerDrawLooper);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17SkLayerDrawLooper11makeContextEP12SkArenaAlloc"]
    pub fn SkLayerDrawLooper_makeContext(
        this: *mut ::core::ffi::c_void,
        arg1: *mut SkArenaAlloc,
    ) -> *mut SkDrawLooper_Context;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17SkLayerDrawLooper13asABlurShadowEPN12SkDrawLooper13BlurShadowRecE"]
    pub fn SkLayerDrawLooper_asABlurShadow(
        this: *mut ::core::ffi::c_void,
        rec: *mut SkDrawLooper_BlurShadowRec,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17SkLayerDrawLooper7flattenER13SkWriteBuffer"]
    pub fn SkLayerDrawLooper_flatten(this: *mut ::core::ffi::c_void, arg1: *mut SkWriteBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkLayerDrawLooper22LayerDrawLooperContext4nextEPN12SkDrawLooper7Context4InfoEP7SkPaint"]
    pub fn SkLayerDrawLooper_LayerDrawLooperContext_next(
        this: *mut ::core::ffi::c_void,
        arg1: *mut SkDrawLooper_Context_Info,
        paint: *mut SkPaint,
    ) -> bool;
}
impl SkMatrixConvolutionImageFilter_TileMode {
    pub const Last: SkMatrixConvolutionImageFilter_TileMode =
        SkMatrixConvolutionImageFilter_TileMode::ClampToBlack;
}
impl SkMatrixConvolutionImageFilter_TileMode {
    pub const Max: SkMatrixConvolutionImageFilter_TileMode =
        SkMatrixConvolutionImageFilter_TileMode::ClampToBlack;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrixConvolutionImageFilter_TileMode {
    Clamp = 0,
    Repeat = 1,
    ClampToBlack = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathOp {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
}
extern "C" {
    #[link_name = "\u{1}_Z2OpRK6SkPathS1_8SkPathOpPS_"]
    pub fn Op(one: *const SkPath, two: *const SkPath, op: SkPathOp, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z8SimplifyRK6SkPathPS_"]
    pub fn Simplify(path: *const SkPath, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z11TightBoundsRK6SkPathP6SkRect"]
    pub fn TightBounds(path: *const SkPath, result: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z9AsWindingRK6SkPathPS_"]
    pub fn AsWinding(path: *const SkPath, result: *mut SkPath) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkOpBuilder {
    pub fPathRefs: [u64; 2usize],
    pub fOps: SkTDArray<SkPathOp>,
}
#[test]
fn bindgen_test_layout_SkOpBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkOpBuilder>(),
        32usize,
        concat!("Size of: ", stringify!(SkOpBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOpBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkOpBuilder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkOpBuilder>())).fPathRefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOpBuilder),
            "::",
            stringify!(fPathRefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkOpBuilder>())).fOps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOpBuilder),
            "::",
            stringify!(fOps)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkOpBuilder3addERK6SkPath8SkPathOp"]
    pub fn SkOpBuilder_add(this: *mut SkOpBuilder, path: *const SkPath, _operator: SkPathOp);
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkOpBuilder7resolveEP6SkPath"]
    pub fn SkOpBuilder_resolve(this: *mut SkOpBuilder, result: *mut SkPath) -> bool;
}
impl SkOpBuilder {
    #[inline]
    pub unsafe fn add(&mut self, path: *const SkPath, _operator: SkPathOp) {
        SkOpBuilder_add(self, path, _operator)
    }
    #[inline]
    pub unsafe fn resolve(&mut self, result: *mut SkPath) -> bool {
        SkOpBuilder_resolve(self, result)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect {
    pub _bindgen_opaque_blob: [u64; 17usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_Uniform {
    pub fName: SkString,
    pub fOffset: usize,
    pub fType: SkRuntimeEffect_Uniform_Type,
    pub fGPUType: GrSLType,
    pub fCount: ::std::os::raw::c_int,
    pub fFlags: u32,
    pub fMarker: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRuntimeEffect_Uniform_Type {
    Float = 0,
    Float2 = 1,
    Float3 = 2,
    Float4 = 3,
    Float2x2 = 4,
    Float3x3 = 5,
    Float4x4 = 6,
}
pub const SkRuntimeEffect_Uniform_Flags_kArray_Flag: SkRuntimeEffect_Uniform_Flags = 1;
pub const SkRuntimeEffect_Uniform_Flags_kMarker_Flag: SkRuntimeEffect_Uniform_Flags = 2;
pub const SkRuntimeEffect_Uniform_Flags_kMarkerNormals_Flag: SkRuntimeEffect_Uniform_Flags = 4;
pub const SkRuntimeEffect_Uniform_Flags_kSRGBUnpremul_Flag: SkRuntimeEffect_Uniform_Flags = 8;
pub type SkRuntimeEffect_Uniform_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Uniform() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Uniform>(),
        40usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Uniform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Uniform>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Uniform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fGPUType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fGPUType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fFlags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkRuntimeEffect_Uniform>())).fMarker as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(fMarker)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15SkRuntimeEffect7Uniform11sizeInBytesEv"]
    pub fn SkRuntimeEffect_Uniform_sizeInBytes(this: *const SkRuntimeEffect_Uniform) -> usize;
}
impl SkRuntimeEffect_Uniform {
    #[inline]
    pub unsafe fn sizeInBytes(&self) -> usize {
        SkRuntimeEffect_Uniform_sizeInBytes(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_Varying {
    pub fName: SkString,
    pub fWidth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Varying() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Varying>(),
        16usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Varying))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Varying>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Varying))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Varying>())).fName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Varying),
            "::",
            stringify!(fName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkRuntimeEffect_Varying>())).fWidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Varying),
            "::",
            stringify!(fWidth)
        )
    );
}
pub type SkRuntimeEffect_EffectResult = [u64; 2usize];
pub type SkRuntimeEffect_ByteCodeResult = u8;
#[test]
fn bindgen_test_layout_SkRuntimeEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect>(),
        136usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffect4MakeE8SkString"]
    pub fn SkRuntimeEffect_Make(sksl: SkString) -> SkRuntimeEffect_EffectResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffect10makeShaderE5sk_spI6SkDataEPS0_I8SkShaderEmPK8SkMatrixb"]
    pub fn SkRuntimeEffect_makeShader(
        this: *mut SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
        isOpaque: bool,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffect15makeColorFilterE5sk_spI6SkDataE"]
    pub fn SkRuntimeEffect_makeColorFilter(
        this: *mut SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffect15makeColorFilterE5sk_spI6SkDataEPS0_I13SkColorFilterEm"]
    pub fn SkRuntimeEffect_makeColorFilter1(
        this: *mut SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15SkRuntimeEffect11uniformSizeEv"]
    pub fn SkRuntimeEffect_uniformSize(this: *const SkRuntimeEffect) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15SkRuntimeEffect11findUniformEPKc"]
    pub fn SkRuntimeEffect_findUniform(
        this: *const SkRuntimeEffect,
        name: *const ::std::os::raw::c_char,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15SkRuntimeEffect9findChildEPKc"]
    pub fn SkRuntimeEffect_findChild(
        this: *const SkRuntimeEffect,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffect20RegisterFlattenablesEv"]
    pub fn SkRuntimeEffect_RegisterFlattenables();
}
impl SkRuntimeEffect {
    #[inline]
    pub unsafe fn Make(sksl: SkString) -> SkRuntimeEffect_EffectResult {
        SkRuntimeEffect_Make(sksl)
    }
    #[inline]
    pub unsafe fn makeShader(
        &mut self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
        isOpaque: bool,
    ) -> sk_sp<SkShader> {
        SkRuntimeEffect_makeShader(self, uniforms, children, childCount, localMatrix, isOpaque)
    }
    #[inline]
    pub unsafe fn makeColorFilter(&mut self, uniforms: sk_sp<SkData>) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter(self, uniforms)
    }
    #[inline]
    pub unsafe fn makeColorFilter1(
        &mut self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter1(self, uniforms, children, childCount)
    }
    #[inline]
    pub unsafe fn uniformSize(&self) -> usize {
        SkRuntimeEffect_uniformSize(self)
    }
    #[inline]
    pub unsafe fn findUniform(
        &self,
        name: *const ::std::os::raw::c_char,
    ) -> *const SkRuntimeEffect_Uniform {
        SkRuntimeEffect_findUniform(self, name)
    }
    #[inline]
    pub unsafe fn findChild(&self, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        SkRuntimeEffect_findChild(self, name)
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkRuntimeEffect_RegisterFlattenables()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15SkRuntimeEffectD1Ev"]
    pub fn SkRuntimeEffect_SkRuntimeEffect_destructor(this: *mut SkRuntimeEffect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTableMaskFilter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkTableMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Size of: ", stringify!(SkTableMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTableMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTableMaskFilter14MakeGammaTableEPhf"]
    pub fn SkTableMaskFilter_MakeGammaTable(table: *mut u8, gamma: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTableMaskFilter13MakeClipTableEPhhh"]
    pub fn SkTableMaskFilter_MakeClipTable(table: *mut u8, min: u8, max: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTableMaskFilter6CreateEPKh"]
    pub fn SkTableMaskFilter_Create(table: *const u8) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTableMaskFilter11CreateGammaEf"]
    pub fn SkTableMaskFilter_CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}_ZN17SkTableMaskFilter10CreateClipEhh"]
    pub fn SkTableMaskFilter_CreateClip(min: u8, max: u8) -> *mut SkMaskFilter;
}
impl SkTableMaskFilter {
    #[inline]
    pub unsafe fn MakeGammaTable(table: *mut u8, gamma: SkScalar) {
        SkTableMaskFilter_MakeGammaTable(table, gamma)
    }
    #[inline]
    pub unsafe fn MakeClipTable(table: *mut u8, min: u8, max: u8) {
        SkTableMaskFilter_MakeClipTable(table, min, max)
    }
    #[inline]
    pub unsafe fn Create(table: *const u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_Create(table)
    }
    #[inline]
    pub unsafe fn CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateGamma(gamma)
    }
    #[inline]
    pub unsafe fn CreateClip(min: u8, max: u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateClip(min, max)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTrimPathEffect_Mode {
    Normal = 0,
    Inverted = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPatch3D {
    pub fU: SkV3,
    pub fV: SkV3,
    pub fOrigin: SkV3,
}
#[test]
fn bindgen_test_layout_SkPatch3D() {
    assert_eq!(
        ::core::mem::size_of::<SkPatch3D>(),
        36usize,
        concat!("Size of: ", stringify!(SkPatch3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPatch3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPatch3D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPatch3D>())).fU as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fU)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPatch3D>())).fV as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fV)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkPatch3D>())).fOrigin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fOrigin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPatch3D5resetEv"]
    pub fn SkPatch3D_reset(this: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPatch3D9transformERK5SkM44PS_"]
    pub fn SkPatch3D_transform(this: *const SkPatch3D, arg1: *const SkM44, dst: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9SkPatch3D7dotWithEfff"]
    pub fn SkPatch3D_dotWith(
        this: *const SkPatch3D,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN9SkPatch3DC1Ev"]
    pub fn SkPatch3D_SkPatch3D(this: *mut SkPatch3D);
}
impl SkPatch3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPatch3D_reset(self)
    }
    #[inline]
    pub unsafe fn transform(&self, arg1: *const SkM44, dst: *mut SkPatch3D) {
        SkPatch3D_transform(self, arg1, dst)
    }
    #[inline]
    pub unsafe fn dotWith(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        SkPatch3D_dotWith(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPatch3D_SkPatch3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCamera3D {
    pub fLocation: SkV3,
    pub fAxis: SkV3,
    pub fZenith: SkV3,
    pub fObserver: SkV3,
    pub fOrientation: SkMatrix,
    pub fNeedToUpdate: bool,
}
#[test]
fn bindgen_test_layout_SkCamera3D() {
    assert_eq!(
        ::core::mem::size_of::<SkCamera3D>(),
        92usize,
        concat!("Size of: ", stringify!(SkCamera3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCamera3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCamera3D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fLocation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fLocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fAxis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fZenith as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fZenith)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fObserver as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fObserver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fOrientation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fOrientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCamera3D>())).fNeedToUpdate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fNeedToUpdate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkCamera3D5resetEv"]
    pub fn SkCamera3D_reset(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkCamera3D6updateEv"]
    pub fn SkCamera3D_update(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10SkCamera3D13patchToMatrixERK9SkPatch3DP8SkMatrix"]
    pub fn SkCamera3D_patchToMatrix(
        this: *const SkCamera3D,
        arg1: *const SkPatch3D,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SkCamera3DC1Ev"]
    pub fn SkCamera3D_SkCamera3D(this: *mut SkCamera3D);
}
impl SkCamera3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkCamera3D_reset(self)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        SkCamera3D_update(self)
    }
    #[inline]
    pub unsafe fn patchToMatrix(&self, arg1: *const SkPatch3D, matrix: *mut SkMatrix) {
        SkCamera3D_patchToMatrix(self, arg1, matrix)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCamera3D_SkCamera3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Sk3DView {
    pub fRec: *mut Sk3DView_Rec,
    pub fInitialRec: Sk3DView_Rec,
    pub fCamera: SkCamera3D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sk3DView_Rec {
    pub fNext: *mut Sk3DView_Rec,
    pub fMatrix: SkM44,
}
#[test]
fn bindgen_test_layout_Sk3DView_Rec() {
    assert_eq!(
        ::core::mem::size_of::<Sk3DView_Rec>(),
        72usize,
        concat!("Size of: ", stringify!(Sk3DView_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView_Rec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sk3DView_Rec>())).fNext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView_Rec),
            "::",
            stringify!(fNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sk3DView_Rec>())).fMatrix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView_Rec),
            "::",
            stringify!(fMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_Sk3DView() {
    assert_eq!(
        ::core::mem::size_of::<Sk3DView>(),
        176usize,
        concat!("Size of: ", stringify!(Sk3DView))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sk3DView>())).fRec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fRec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sk3DView>())).fInitialRec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fInitialRec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sk3DView>())).fCamera as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fCamera)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView4saveEv"]
    pub fn Sk3DView_save(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView7restoreEv"]
    pub fn Sk3DView_restore(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView9translateEfff"]
    pub fn Sk3DView_translate(this: *mut Sk3DView, x: SkScalar, y: SkScalar, z: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView7rotateXEf"]
    pub fn Sk3DView_rotateX(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView7rotateYEf"]
    pub fn Sk3DView_rotateY(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DView7rotateZEf"]
    pub fn Sk3DView_rotateZ(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8Sk3DView9getMatrixEP8SkMatrix"]
    pub fn Sk3DView_getMatrix(this: *const Sk3DView, arg1: *mut SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8Sk3DView13applyToCanvasEP8SkCanvas"]
    pub fn Sk3DView_applyToCanvas(this: *const Sk3DView, arg1: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8Sk3DView13dotWithNormalEfff"]
    pub fn Sk3DView_dotWithNormal(
        this: *const Sk3DView,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DViewC1Ev"]
    pub fn Sk3DView_Sk3DView(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}_ZN8Sk3DViewD1Ev"]
    pub fn Sk3DView_Sk3DView_destructor(this: *mut Sk3DView);
}
impl Sk3DView {
    #[inline]
    pub unsafe fn save(&mut self) {
        Sk3DView_save(self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        Sk3DView_restore(self)
    }
    #[inline]
    pub unsafe fn translate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) {
        Sk3DView_translate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn rotateX(&mut self, deg: SkScalar) {
        Sk3DView_rotateX(self, deg)
    }
    #[inline]
    pub unsafe fn rotateY(&mut self, deg: SkScalar) {
        Sk3DView_rotateY(self, deg)
    }
    #[inline]
    pub unsafe fn rotateZ(&mut self, deg: SkScalar) {
        Sk3DView_rotateZ(self, deg)
    }
    #[inline]
    pub unsafe fn getMatrix(&self, arg1: *mut SkMatrix) {
        Sk3DView_getMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn applyToCanvas(&self, arg1: *mut SkCanvas) {
        Sk3DView_applyToCanvas(self, arg1)
    }
    #[inline]
    pub unsafe fn dotWithNormal(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        Sk3DView_dotWithNormal(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Sk3DView_Sk3DView(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Sk3DView_Sk3DView_destructor(self)
    }
}
#[repr(C)]
pub struct SkCustomTypefaceBuilder {
    pub fPaths: [u64; 3usize],
    pub fAdvances: [u64; 3usize],
    pub fMetrics: SkFontMetrics,
    pub fStyle: SkFontStyle,
}
#[test]
fn bindgen_test_layout_SkCustomTypefaceBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkCustomTypefaceBuilder>(),
        120usize,
        concat!("Size of: ", stringify!(SkCustomTypefaceBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCustomTypefaceBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCustomTypefaceBuilder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCustomTypefaceBuilder>())).fPaths as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fPaths)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCustomTypefaceBuilder>())).fAdvances as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fAdvances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkCustomTypefaceBuilder>())).fMetrics as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fMetrics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkCustomTypefaceBuilder>())).fStyle as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fStyle)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder8setGlyphEtfRK6SkPath"]
    pub fn SkCustomTypefaceBuilder_setGlyph(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: *const SkPath,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder8setGlyphEtfRK6SkPathRK7SkPaint"]
    pub fn SkCustomTypefaceBuilder_setGlyph1(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: *const SkPath,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder8setGlyphEtf5sk_spI7SkImageEf"]
    pub fn SkCustomTypefaceBuilder_setGlyph2(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: sk_sp<SkImage>,
        scale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder8setGlyphEtf5sk_spI9SkPictureE"]
    pub fn SkCustomTypefaceBuilder_setGlyph3(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: sk_sp<SkPicture>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder10setMetricsERK13SkFontMetricsf"]
    pub fn SkCustomTypefaceBuilder_setMetrics(
        this: *mut SkCustomTypefaceBuilder,
        fm: *const SkFontMetrics,
        scale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder12setFontStyleE11SkFontStyle"]
    pub fn SkCustomTypefaceBuilder_setFontStyle(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkFontStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilder6detachEv"]
    pub fn SkCustomTypefaceBuilder_detach(this: *mut SkCustomTypefaceBuilder) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}_ZN23SkCustomTypefaceBuilderC1Ev"]
    pub fn SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(this: *mut SkCustomTypefaceBuilder);
}
impl SkCustomTypefaceBuilder {
    #[inline]
    pub unsafe fn setGlyph(&mut self, arg1: SkGlyphID, advance: f32, arg2: *const SkPath) {
        SkCustomTypefaceBuilder_setGlyph(self, arg1, advance, arg2)
    }
    #[inline]
    pub unsafe fn setGlyph1(
        &mut self,
        arg1: SkGlyphID,
        advance: f32,
        arg2: *const SkPath,
        arg3: *const SkPaint,
    ) {
        SkCustomTypefaceBuilder_setGlyph1(self, arg1, advance, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setGlyph2(
        &mut self,
        arg1: SkGlyphID,
        advance: f32,
        arg2: sk_sp<SkImage>,
        scale: f32,
    ) {
        SkCustomTypefaceBuilder_setGlyph2(self, arg1, advance, arg2, scale)
    }
    #[inline]
    pub unsafe fn setGlyph3(&mut self, arg1: SkGlyphID, advance: f32, arg2: sk_sp<SkPicture>) {
        SkCustomTypefaceBuilder_setGlyph3(self, arg1, advance, arg2)
    }
    #[inline]
    pub unsafe fn setMetrics(&mut self, fm: *const SkFontMetrics, scale: f32) {
        SkCustomTypefaceBuilder_setMetrics(self, fm, scale)
    }
    #[inline]
    pub unsafe fn setFontStyle(&mut self, arg1: SkFontStyle) {
        SkCustomTypefaceBuilder_setFontStyle(self, arg1)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkTypeface> {
        SkCustomTypefaceBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkInterpolatorBase {
    pub fFrameCount: i16,
    pub fElemCount: u8,
    pub fFlags: u8,
    pub fRepeat: SkScalar,
    pub fTimes: *mut SkInterpolatorBase_SkTimeCode,
    pub fStorage: *mut ::core::ffi::c_void,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkInterpolatorBase_Result {
    Normal_Result = 0,
    FreezeStart_Result = 1,
    FreezeEnd_Result = 2,
}
pub const SkInterpolatorBase_Flags_kMirror: SkInterpolatorBase_Flags = 1;
pub const SkInterpolatorBase_Flags_kReset: SkInterpolatorBase_Flags = 2;
pub const SkInterpolatorBase_Flags_kHasBlend: SkInterpolatorBase_Flags = 4;
pub type SkInterpolatorBase_Flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkInterpolatorBase_SkTimeCode {
    pub fTime: SkMSec,
    pub fBlend: [SkScalar; 4usize],
}
#[test]
fn bindgen_test_layout_SkInterpolatorBase_SkTimeCode() {
    assert_eq!(
        ::core::mem::size_of::<SkInterpolatorBase_SkTimeCode>(),
        20usize,
        concat!("Size of: ", stringify!(SkInterpolatorBase_SkTimeCode))
    );
    assert_eq!(
        ::core::mem::align_of::<SkInterpolatorBase_SkTimeCode>(),
        4usize,
        concat!("Alignment of ", stringify!(SkInterpolatorBase_SkTimeCode))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkInterpolatorBase_SkTimeCode>())).fTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase_SkTimeCode),
            "::",
            stringify!(fTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SkInterpolatorBase_SkTimeCode>())).fBlend as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase_SkTimeCode),
            "::",
            stringify!(fBlend)
        )
    );
}
#[test]
fn bindgen_test_layout_SkInterpolatorBase() {
    assert_eq!(
        ::core::mem::size_of::<SkInterpolatorBase>(),
        24usize,
        concat!("Size of: ", stringify!(SkInterpolatorBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SkInterpolatorBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SkInterpolatorBase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fFrameCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fFrameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fElemCount as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fElemCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fFlags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fRepeat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fRepeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fTimes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fTimes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolatorBase>())).fStorage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolatorBase),
            "::",
            stringify!(fStorage)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkInterpolatorBase5resetEii"]
    pub fn SkInterpolatorBase_reset(
        this: *mut SkInterpolatorBase,
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18SkInterpolatorBase11getDurationEPjS0_"]
    pub fn SkInterpolatorBase_getDuration(
        this: *const SkInterpolatorBase,
        startTime: *mut SkMSec,
        endTime: *mut SkMSec,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18SkInterpolatorBase7timeToTEjPfPiPb"]
    pub fn SkInterpolatorBase_timeToT(
        this: *const SkInterpolatorBase,
        time: SkMSec,
        T: *mut SkScalar,
        index: *mut ::std::os::raw::c_int,
        exact: *mut bool,
    ) -> SkInterpolatorBase_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkInterpolatorBase16ComputeRelativeTEjjjPKf"]
    pub fn SkInterpolatorBase_ComputeRelativeT(
        time: SkMSec,
        prevTime: SkMSec,
        nextTime: SkMSec,
        blend: *const SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkInterpolatorBaseC1Ev"]
    pub fn SkInterpolatorBase_SkInterpolatorBase(this: *mut SkInterpolatorBase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18SkInterpolatorBaseD1Ev"]
    pub fn SkInterpolatorBase_SkInterpolatorBase_destructor(this: *mut SkInterpolatorBase);
}
impl SkInterpolatorBase {
    #[inline]
    pub unsafe fn reset(
        &mut self,
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    ) {
        SkInterpolatorBase_reset(self, elemCount, frameCount)
    }
    #[inline]
    pub unsafe fn getDuration(&self, startTime: *mut SkMSec, endTime: *mut SkMSec) -> bool {
        SkInterpolatorBase_getDuration(self, startTime, endTime)
    }
    #[inline]
    pub unsafe fn timeToT(
        &self,
        time: SkMSec,
        T: *mut SkScalar,
        index: *mut ::std::os::raw::c_int,
        exact: *mut bool,
    ) -> SkInterpolatorBase_Result {
        SkInterpolatorBase_timeToT(self, time, T, index, exact)
    }
    #[inline]
    pub unsafe fn ComputeRelativeT(
        time: SkMSec,
        prevTime: SkMSec,
        nextTime: SkMSec,
        blend: *const SkScalar,
    ) -> SkScalar {
        SkInterpolatorBase_ComputeRelativeT(time, prevTime, nextTime, blend)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkInterpolatorBase_SkInterpolatorBase(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkInterpolatorBase_SkInterpolatorBase_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkInterpolator {
    pub _base: SkInterpolatorBase,
    pub fValues: *mut SkScalar,
}
pub type SkInterpolator_INHERITED = SkInterpolatorBase;
#[test]
fn bindgen_test_layout_SkInterpolator() {
    assert_eq!(
        ::core::mem::size_of::<SkInterpolator>(),
        32usize,
        concat!("Size of: ", stringify!(SkInterpolator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkInterpolator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkInterpolator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SkInterpolator>())).fValues as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkInterpolator),
            "::",
            stringify!(fValues)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkInterpolator5resetEii"]
    pub fn SkInterpolator_reset(
        this: *mut SkInterpolator,
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkInterpolator11setKeyFrameEijPKfS1_"]
    pub fn SkInterpolator_setKeyFrame(
        this: *mut SkInterpolator,
        index: ::std::os::raw::c_int,
        time: SkMSec,
        values: *const SkScalar,
        blend: *const SkScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14SkInterpolator12timeToValuesEjPf"]
    pub fn SkInterpolator_timeToValues(
        this: *const SkInterpolator,
        time: SkMSec,
        values: *mut SkScalar,
    ) -> SkInterpolatorBase_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkInterpolatorC1Ev"]
    pub fn SkInterpolator_SkInterpolator(this: *mut SkInterpolator);
}
extern "C" {
    #[link_name = "\u{1}_ZN14SkInterpolatorC1Eii"]
    pub fn SkInterpolator_SkInterpolator1(
        this: *mut SkInterpolator,
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    );
}
impl SkInterpolator {
    #[inline]
    pub unsafe fn reset(
        &mut self,
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    ) {
        SkInterpolator_reset(self, elemCount, frameCount)
    }
    #[inline]
    pub unsafe fn setKeyFrame(
        &mut self,
        index: ::std::os::raw::c_int,
        time: SkMSec,
        values: *const SkScalar,
        blend: *const SkScalar,
    ) -> bool {
        SkInterpolator_setKeyFrame(self, index, time, values, blend)
    }
    #[inline]
    pub unsafe fn timeToValues(
        &self,
        time: SkMSec,
        values: *mut SkScalar,
    ) -> SkInterpolatorBase_Result {
        SkInterpolator_timeToValues(self, time, values)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkInterpolator_SkInterpolator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        elemCount: ::std::os::raw::c_int,
        frameCount: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkInterpolator_SkInterpolator1(__bindgen_tmp.as_mut_ptr(), elemCount, frameCount);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_Z17SkUnitCubicInterpfffff"]
    pub fn SkUnitCubicInterp(
        value: SkScalar,
        bx: SkScalar,
        by: SkScalar,
        cx: SkScalar,
        cy: SkScalar,
    ) -> SkScalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkParsePath {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkParsePath() {
    assert_eq!(
        ::core::mem::size_of::<SkParsePath>(),
        1usize,
        concat!("Size of: ", stringify!(SkParsePath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkParsePath>(),
        1usize,
        concat!("Alignment of ", stringify!(SkParsePath))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkParsePath13FromSVGStringEPKcP6SkPath"]
    pub fn SkParsePath_FromSVGString(
        str_: *const ::std::os::raw::c_char,
        arg1: *mut SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkParsePath11ToSVGStringERK6SkPathP8SkString"]
    pub fn SkParsePath_ToSVGString(arg1: *const SkPath, arg2: *mut SkString);
}
impl SkParsePath {
    #[inline]
    pub unsafe fn FromSVGString(str_: *const ::std::os::raw::c_char, arg1: *mut SkPath) -> bool {
        SkParsePath_FromSVGString(str_, arg1)
    }
    #[inline]
    pub unsafe fn ToSVGString(arg1: *const SkPath, arg2: *mut SkString) {
        SkParsePath_ToSVGString(arg1, arg2)
    }
}
pub const SkShadowFlags_kNone_ShadowFlag: SkShadowFlags = 0;
pub const SkShadowFlags_kTransparentOccluder_ShadowFlag: SkShadowFlags = 1;
pub const SkShadowFlags_kGeometricOnly_ShadowFlag: SkShadowFlags = 2;
pub const SkShadowFlags_kAll_ShadowFlag: SkShadowFlags = 3;
pub type SkShadowFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShadowUtils {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkShadowUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkShadowUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkShadowUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShadowUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkShadowUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkShadowUtils10DrawShadowEP8SkCanvasRK6SkPathRK8SkPoint3S7_fjjj"]
    pub fn SkShadowUtils_DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13SkShadowUtils18ComputeTonalColorsEjjPjS0_"]
    pub fn SkShadowUtils_ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    );
}
impl SkShadowUtils {
    #[inline]
    pub unsafe fn DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    ) {
        SkShadowUtils_DrawShadow(
            canvas,
            path,
            zPlaneParams,
            lightPos,
            lightRadius,
            ambientColor,
            spotColor,
            flags,
        )
    }
    #[inline]
    pub unsafe fn ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    ) {
        SkShadowUtils_ComputeTonalColors(inAmbientColor, inSpotColor, outAmbientColor, outSpotColor)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextUtils {
    pub _address: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextUtils_Align {
    Left = 0,
    Center = 1,
    Right = 2,
}
#[test]
fn bindgen_test_layout_SkTextUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkTextUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkTextUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTextUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkTextUtils4DrawEP8SkCanvasPKvm14SkTextEncodingffRK6SkFontRK7SkPaintNS_5AlignE"]
    pub fn SkTextUtils_Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkTextUtils7GetPathEPKvm14SkTextEncodingffRK6SkFontP6SkPath"]
    pub fn SkTextUtils_GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    );
}
impl SkTextUtils {
    #[inline]
    pub unsafe fn Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    ) {
        SkTextUtils_Draw(arg1, text, size, arg2, x, y, arg3, arg4, arg5)
    }
    #[inline]
    pub unsafe fn GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    ) {
        SkTextUtils_GetPath(text, length, arg1, x, y, arg2, arg3)
    }
}
extern "C" {
    pub fn C_SkCodec_MakeFromData(data: *mut SkData) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkCodec_getInfo(self_: *const SkCodec, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCodec_dimensions(self_: *const SkCodec) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_bounds(self_: *const SkCodec) -> SkIRect;
}
extern "C" {
    pub fn C_SkCodec_getOrigin(self_: *const SkCodec) -> SkEncodedOrigin;
}
extern "C" {
    pub fn C_SkCodec_getScaledDimensions(self_: *const SkCodec, desiredScale: f32) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_getValidSubset(self_: *const SkCodec, desiredSubset: *mut SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkCodec_getEncodedFormat(self_: *const SkCodec) -> SkEncodedImageFormat;
}
extern "C" {
    pub fn C_SkEncodedOriginToMatrix(
        origin: SkEncodedOrigin,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    pub fn C_Core_Types(
        arg1: *mut SkGraphics,
        arg2: *mut SkCoverageMode,
        arg3: *mut SkColorChannelFlag,
    );
}
extern "C" {
    pub fn C_SkCubicMap_computeFromT(self_: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    pub fn C_SkSurface_MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_width(self_: *const SkSurface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkSurface_height(self_: *const SkSurface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkSurface_imageInfo(self_: *mut SkSurface, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkSurface_makeImageSnapshot(
        self_: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkSurface_makeSurface(
        self_: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_makeSurface2(
        self_: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_props(self_: *const SkSurface) -> *const SkSurfaceProps;
}
extern "C" {
    pub fn C_SkSurface_draw(
        self_: *mut SkSurface,
        displayList: *const SkDeferredDisplayList,
    ) -> bool;
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_Construct(uninitialized: *mut SkSurfaceCharacterization);
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_CopyConstruct(
        uninitialized: *mut SkSurfaceCharacterization,
        from: *const SkSurfaceCharacterization,
    );
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_destruct(self_: *mut SkSurfaceCharacterization);
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_equals(
        self_: *const SkSurfaceCharacterization,
        rhs: *const SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_createColorSpace(
        self_: *const SkSurfaceCharacterization,
        cs: *mut SkColorSpace,
        out: *mut SkSurfaceCharacterization,
    );
}
extern "C" {
    pub fn C_SkImage_MakeRasterFromCompressed(
        data: *mut SkData,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeRasterData(
        info: *const SkImageInfo,
        pixels: *mut SkData,
        rowBytes: usize,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromBitmap(bitmap: *const SkBitmap) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromGenerator(imageGenerator: *mut SkImageGenerator) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromEncoded(encoded: *mut SkData) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromPicture(
        picture: *mut SkPicture,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeShader(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_scalePixels(
        self_: *const SkImage,
        dst: *const SkPixmap,
        filterQuality: SkFilterQuality,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    pub fn C_SkImage_makeShaderWithCubicResampler(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        cubicResampler: SkCubicResampler,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_makeShaderWithQuality(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        localMatrix: *const SkMatrix,
        filterQuality: SkFilterQuality,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_encodeToData(
        self_: *const SkImage,
        imageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImage_refEncodedData(self_: *const SkImage) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImage_makeSubset(
        self_: *const SkImage,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_withDefaultMipmaps(self_: *const SkImage) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeNonTextureImage(self_: *const SkImage) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeRasterImage(
        self_: *const SkImage,
        cachingHint: SkImage_CachingHint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeWithFilter(
        self_: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeColorSpace(
        self_: *const SkImage,
        target: *mut SkColorSpace,
        direct: *mut GrDirectContext,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_reinterpretColorSpace(
        self_: *const SkImage,
        newColorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkEncodePixmap(
        src: *const SkPixmap,
        format: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkEncodeBitmap(
        src: *const SkBitmap,
        format: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_ref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unique(self_: *const SkData) -> bool;
}
extern "C" {
    pub fn C_SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeUninitialized(length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithoutCopy(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeEmpty() -> *mut SkData;
}
extern "C" {
    pub fn C_SkPaint_destruct(self_: *mut SkPaint);
}
extern "C" {
    pub fn C_SkPaint_copy(self_: *mut SkPaint, rhs: *const SkPaint);
}
extern "C" {
    pub fn C_SkPaint_Equals(lhs: *const SkPaint, rhs: *const SkPaint) -> bool;
}
extern "C" {
    pub fn C_SkPaint_getFilterQuality(self_: *const SkPaint) -> SkFilterQuality;
}
extern "C" {
    pub fn C_SkPaint_getStyle(self_: *const SkPaint) -> SkPaint_Style;
}
extern "C" {
    pub fn C_SkPaint_getAlpha(self_: *const SkPaint) -> u8;
}
extern "C" {
    pub fn C_SkPaint_getStrokeCap(self_: *const SkPaint) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkPaint_getStrokeJoin(self_: *const SkPaint) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkPaint_setShader(self_: *mut SkPaint, shader: *mut SkShader);
}
extern "C" {
    pub fn C_SkPaint_setColorFilter(self_: *mut SkPaint, colorFilter: *mut SkColorFilter);
}
extern "C" {
    pub fn C_SkPaint_getBlendMode(self_: *const SkPaint) -> SkBlendMode;
}
extern "C" {
    pub fn C_SkPaint_setPathEffect(self_: *mut SkPaint, pathEffect: *mut SkPathEffect);
}
extern "C" {
    pub fn C_SkPaint_setMaskFilter(self_: *mut SkPaint, maskFilter: *mut SkMaskFilter);
}
extern "C" {
    pub fn C_SkPaint_setImageFilter(self_: *mut SkPaint, imageFilter: *mut SkImageFilter);
}
extern "C" {
    pub fn C_SkPath_Construct(uninitialized: *mut SkPath);
}
extern "C" {
    pub fn C_SkPath_Make(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        vbs: *const u8,
        verbCount: ::std::os::raw::c_int,
        ws: *const SkScalar,
        wCount: ::std::os::raw::c_int,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_Rect(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_Oval(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_OvalWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRect,
        dir: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Circle(
        uninitialized: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        r: SkScalar,
        dir: SkPathDirection,
    );
}
extern "C" {
    pub fn C_SkPath_RRect(uninitialized: *mut SkPath, rr: *const SkRRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_RRectWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRRect,
        dir: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Polygon(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_destruct(self_: *const SkPath);
}
extern "C" {
    pub fn C_SkPath_Equals(lhs: *const SkPath, rhs: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_serialize(self_: *const SkPath) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPath_isValid(self_: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_Iter_destruct(self_: *mut SkPath_Iter);
}
extern "C" {
    pub fn C_SkPath_Iter_isCloseLine(self_: *const SkPath_Iter) -> bool;
}
extern "C" {
    pub fn C_SkPath_RawIter_Construct(uninitialized: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_destruct(self_: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_peek(self_: *const SkPath_RawIter) -> SkPath_Verb;
}
extern "C" {
    pub fn C_SkPath_getFillType(self_: *const SkPath) -> SkPathFillType;
}
extern "C" {
    pub fn C_SkPath_isConvex(self_: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_isEmpty(self_: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_isFinite(self_: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_getPoint(self_: *const SkPath, index: ::std::os::raw::c_int) -> SkPoint;
}
extern "C" {
    pub fn C_SkPath_getBounds(self_: *const SkPath) -> *const SkRect;
}
extern "C" {
    pub fn C_SkPath_computeTightBounds(self_: *const SkPath) -> SkRect;
}
extern "C" {
    pub fn C_SkPath_getSegmentMasks(self_: *const SkPath) -> u32;
}
extern "C" {
    pub fn C_SkPathBuilder_Construct(uninitialized: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_Construct3(uninitialized: *mut SkPathBuilder, path: *const SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_computeBounds(self_: *const SkPathBuilder) -> SkRect;
}
extern "C" {
    pub fn C_SkPathBuilder_CopyConstruct(
        uninitialized: *mut SkPathBuilder,
        pathBuilder: *const SkPathBuilder,
    );
}
extern "C" {
    pub fn C_SkPathBuilder_destruct(self_: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_snapshot(self_: *const SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_detach(self_: *mut SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathMeasure_destruct(self_: *const SkPathMeasure);
}
extern "C" {
    pub fn C_SkPathTypes_Types(
        arg1: *mut SkPathFillType,
        arg2: *mut SkPathDirection,
        arg3: *mut SkPathSegmentMask,
        arg4: *mut SkPathVerb,
    );
}
extern "C" {
    pub fn C_SkCanvas_newEmpty() -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newWidthHeightAndProps(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmap(bitmap: *const SkBitmap) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmapAndProps(
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_delete(self_: *const SkCanvas);
}
extern "C" {
    pub fn C_SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        row_bytes: usize,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_imageInfo(self_: *const SkCanvas, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCanvas_getBaseLayerSize(self_: *const SkCanvas, size: *mut SkISize);
}
extern "C" {
    pub fn C_SkCanvas_makeSurface(
        self_: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkCanvas_clipShader(self_: *mut SkCanvas, shader: *mut SkShader, op: SkClipOp);
}
extern "C" {
    pub fn C_SkCanvas_getLocalClipBounds(self_: *const SkCanvas) -> SkRect;
}
extern "C" {
    pub fn C_SkCanvas_getDeviceClipBounds(self_: *const SkCanvas) -> SkIRect;
}
extern "C" {
    pub fn C_SkCanvas_isClipEmpty(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_isClipRect(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_getLocalToDevice(self_: *const SkCanvas, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkCanvas_getTotalMatrix(self_: *const SkCanvas, matrix: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkCanvas_discard(self_: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_Construct(
        uninitialized: *mut SkAutoCanvasRestore,
        canvas: *mut SkCanvas,
        doSave: bool,
    );
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_destruct(self_: *const SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_restore(self_: *mut SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkColorInfo_Construct(uninitialized: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Construct2(
        uninitialized: *mut SkColorInfo,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
    );
}
extern "C" {
    pub fn C_SkColorInfo_destruct(self_: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Copy(from: *const SkColorInfo, to: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Equals(lhs: *const SkColorInfo, rhs: *const SkColorInfo) -> bool;
}
extern "C" {
    pub fn C_SkColorInfo_gammaCloseToSRGB(self_: *const SkColorInfo) -> bool;
}
extern "C" {
    pub fn C_SkImageInfo_Construct(uninitialized: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_destruct(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Copy(from: *const SkImageInfo, to: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Equals(lhs: *const SkImageInfo, rhs: *const SkImageInfo) -> bool;
}
extern "C" {
    pub fn C_SkImageInfo_Make(
        self_: *mut SkImageInfo,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeS32(
        self_: *mut SkImageInfo,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    );
}
extern "C" {
    pub fn C_SkImageInfo_reset(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkColorSpace_Types(arg1: *mut SkColorSpacePrimaries);
}
extern "C" {
    pub fn C_SkColorSpace_ref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unique(self_: *const SkColorSpace) -> bool;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGB() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGBLinear() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeLinearGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeSRGBGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeColorSpin(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_serialize(self_: *const SkColorSpace) -> *mut SkData;
}
extern "C" {
    pub fn C_SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkM44_Types(arg1: *mut SkV2);
}
extern "C" {
    pub fn C_SkM44_equals(self_: *const SkM44, other: *const SkM44) -> bool;
}
extern "C" {
    pub fn C_SkM44_transpose(self_: *const SkM44, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_map(self_: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    pub fn C_Sk3LookAt(
        eye: *const SkV3,
        center: *const SkV3,
        up: *const SkV3,
        uninitialized: *mut SkM44,
    );
}
extern "C" {
    pub fn C_Sk3Perspective(near: f32, far: f32, angle: f32, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkMatrix44_ConstructIdentity(uninitialized: *mut SkMatrix44);
}
extern "C" {
    pub fn C_SkMatrix44_ConstructNaN(uninitialized: *mut SkMatrix44);
}
extern "C" {
    pub fn C_SkMatrix44_Equals(self_: *const SkMatrix44, rhs: *const SkMatrix44) -> bool;
}
extern "C" {
    pub fn C_SkMatrix44_SkMatrix(self_: *const SkMatrix44, m: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkMatrix44_Mul(
        self_: *const SkMatrix44,
        rhs: *const SkMatrix44,
        result: *mut SkMatrix44,
    );
}
extern "C" {
    pub fn C_SkMatrix44_MulV4(
        self_: *const SkMatrix44,
        rhs: *const SkVector4,
        result: *mut SkVector4,
    );
}
extern "C" {
    pub fn C_SkMatrix_Equals(self_: *const SkMatrix, rhs: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_SubscriptMut(self_: *mut SkMatrix, index: usize) -> *mut SkScalar;
}
extern "C" {
    pub fn C_SkMatrix_getType(self_: *const SkMatrix) -> SkMatrix_TypeMask;
}
extern "C" {
    pub fn C_SkMatrix_rectStaysRect(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_hasPerspective(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_invert(self_: *const SkMatrix, inverse: *mut SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_setScaleTranslate(
        self_: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        tx: SkScalar,
        ty: SkScalar,
    );
}
extern "C" {
    pub fn C_SkMatrix_isFinite(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
extern "C" {
    pub fn C_SkMatrix_normalizePerspective(self_: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkSurfaceProps_Equals(
        self_: *const SkSurfaceProps,
        rhs: *const SkSurfaceProps,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_Construct(uninitialized: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_destruct(self_: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_Copy(from: *const SkBitmap, to: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_ComputeIsOpaque(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocN32Pixels(
        self_: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocPixels(self_: *mut SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_pixelRefOrigin(self_: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    pub fn C_SkBitmap_setPixelRef(
        self_: *mut SkBitmap,
        pixelRef: *mut SkPixelRef,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkBitmap_readyToDraw(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_eraseARGB(self_: *const SkBitmap, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    pub fn C_SkBitmap_getAlphaf(
        self_: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    pub fn C_SkBitmap_extractAlpha(
        self_: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_makeShader(
        self_: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData(data: *const SkData) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData2(
        data: *const ::core::ffi::c_void,
        size: usize,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_serialize(self_: *const SkPicture) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPicture_MakePlaceholder(cull: *const SkRect) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_playback(self_: *const SkPicture, canvas: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkPicture_cullRect(self_: *const SkPicture) -> SkRect;
}
extern "C" {
    pub fn C_SkPicture_uniqueID(self_: *const SkPicture) -> u32;
}
extern "C" {
    pub fn C_SkPicture_approximateOpCount(
        self_: *const SkPicture,
        nested: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPicture_approximateBytesUsed(self_: *const SkPicture, out: *mut usize);
}
extern "C" {
    pub fn C_SkPicture_makeShader(
        self_: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRRect_Construct(uninitialized: *mut SkRRect);
}
extern "C" {
    pub fn C_SkRRect_getType(self_: *const SkRRect) -> SkRRect_Type;
}
extern "C" {
    pub fn C_SkRRect_setRect(self_: *mut SkRRect, rect: *const SkRect);
}
extern "C" {
    pub fn C_SkRRect_setOval(self_: *mut SkRRect, oval: *const SkRect);
}
extern "C" {
    pub fn C_SkRRect_dumpToString(self_: *const SkRRect, asHex: bool, str_: *mut SkString);
}
extern "C" {
    pub fn C_SkRRect_Equals(lhs: *const SkRRect, rhs: *const SkRRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_destruct(region: *mut SkRegion);
}
extern "C" {
    pub fn C_SkRegion_Equals(lhs: *const SkRegion, rhs: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_set(self_: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_quickContains(self_: *const SkRegion, r: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_Iterator_Construct(uninitialized: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_destruct(self_: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_rgn(self_: *const SkRegion_Iterator) -> *const SkRegion;
}
extern "C" {
    pub fn C_SkRegion_Cliperator_destruct(self_: *mut SkRegion_Cliperator);
}
extern "C" {
    pub fn C_SkRegion_Spanerator_destruct(self_: *mut SkRegion_Spanerator);
}
extern "C" {
    pub fn C_SkFontStyle_Construct(uninitialized: *mut SkFontStyle);
}
extern "C" {
    pub fn C_SkFontStyle_Construct2(
        uninitialized: *mut SkFontStyle,
        weight: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        slant: SkFontStyle_Slant,
    );
}
extern "C" {
    pub fn C_SkFontStyle_Equals(lhs: *const SkFontStyle, rhs: *const SkFontStyle) -> bool;
}
extern "C" {
    pub fn C_SkFontStyle_weight(self_: *const SkFontStyle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_width(self_: *const SkFontStyle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_slant(self_: *const SkFontStyle) -> SkFontStyle_Slant;
}
extern "C" {
    pub fn C_SkTextBlob_ref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unique(self_: *const SkTextBlob) -> bool;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_Iter_destruct(self_: *mut SkTextBlob_Iter);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_destruct(self_: *mut SkTextBlobBuilder);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_make(self_: *mut SkTextBlobBuilder) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTypeface_isBold(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_isItalic(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_MakeDefault() -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromData(
        data: *mut SkData,
        index: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_makeClone(
        self_: *const SkTypeface,
        arguments: *const SkFontArguments,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_serialize(
        self_: *const SkTypeface,
        behavior: SkTypeface_SerializeBehavior,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_MakeDeserialize(stream: *mut SkStream) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_copyTableData(self_: *const SkTypeface, tag: SkFontTableTag)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_getBounds(self_: *const SkTypeface) -> SkRect;
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_unref(self_: *mut SkTypeface_LocalizedStrings);
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_next(
        self_: *mut SkTypeface_LocalizedStrings,
        string: *mut SkString,
        language: *mut SkString,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVAIndex_AreValidIndices(
        yuvaIndices: *const SkYUVAIndex,
        numPlanes: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVASizeInfo_equals(l: *const SkYUVASizeInfo, r: *const SkYUVASizeInfo) -> bool;
}
extern "C" {
    pub fn C_SkFlattenable_getTypeName(
        self_: *const SkFlattenable,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_SkFlattenable_serialize(self_: *const SkFlattenable) -> *mut SkData;
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypeface(uninitialized: *mut SkFont, typeface: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSize(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSizeScaleAndSkew(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_Equals(self_: *const SkFont, other: *const SkFont) -> bool;
}
extern "C" {
    pub fn C_SkFont_getEdging(self_: *const SkFont) -> SkFont_Edging;
}
extern "C" {
    pub fn C_SkFont_getHinting(self_: *const SkFont) -> SkFontHinting;
}
extern "C" {
    pub fn C_SkFont_makeWithSize(self_: *const SkFont, size: SkScalar, result: *mut SkFont);
}
extern "C" {
    pub fn C_SkFont_getTypeface(self_: *mut SkFont) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFont_setTypeface(self_: *mut SkFont, tf: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_destruct(self_: *mut SkFont);
}
extern "C" {
    pub fn C_SkFontArguments_construct(uninitialized: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_destruct(self_: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_setCollectionIndex(
        self_: *mut SkFontArguments,
        collectionIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkFontArguments_setVariationDesignPosition(
        self_: *mut SkFontArguments,
        position: SkFontArguments_VariationPosition,
    );
}
extern "C" {
    pub fn C_SkFontArguments_getVariationDesignPosition(
        self_: *const SkFontArguments,
    ) -> SkFontArguments_VariationPosition;
}
extern "C" {
    pub fn C_SkFontStyleSet_count(self_: *mut SkFontStyleSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyleSet_getStyle(
        self_: *mut SkFontStyleSet,
        index: ::std::os::raw::c_int,
        fontStyle: *mut SkFontStyle,
        style: *mut SkString,
    );
}
extern "C" {
    pub fn C_SkFontStyleSet_createTypeface(
        self_: *mut SkFontStyleSet,
        index: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontStyleSet_matchStyle(
        self_: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_makeFromStream(
        self_: *const SkFontMgr,
        stream: *mut SkStreamAsset,
        ttcIndex: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_RefDefault() -> *mut SkFontMgr;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_isHidden(
        self_: *const SkFontParameters_Variation_Axis,
    ) -> bool;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_setHidden(
        self_: *mut SkFontParameters_Variation_Axis,
        hidden: bool,
    );
}
extern "C" {
    pub fn C_SkVertices_ref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unique(self_: *const SkVertices) -> bool;
}
extern "C" {
    pub fn C_SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkVertices_Builder_destruct(builder: *mut SkVertices_Builder);
}
extern "C" {
    pub fn C_SkVertices_Builder_detach(builder: *mut SkVertices_Builder) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkPictureRecorder_Construct(uninitialized: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_destruct(self_: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsPicture(
        self_: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsDrawable(
        self_: *mut SkPictureRecorder,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkPixelRef_width(self_: *const SkPixelRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_height(self_: *const SkPixelRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_pixels(self_: *const SkPixelRef) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn C_SkPixelRef_rowBytes(self_: *const SkPixelRef) -> usize;
}
extern "C" {
    pub fn C_SkPixelRef_isImmutable(self_: *const SkPixelRef) -> bool;
}
extern "C" {
    pub fn C_SkPixelRef_notifyAddedToCache(self_: *mut SkPixelRef);
}
extern "C" {
    pub fn C_SkPoint_isFinite(self_: *const SkPoint) -> bool;
}
extern "C" {
    pub fn C_SkIRect_isEmpty(self_: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkIRect_contains(self_: *const SkIRect, rect: *const SkRect) -> bool;
}
extern "C" {
    pub fn C_SkRect_round(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundIn(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundOut(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRefCntBase_ref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unique(self_: *const SkRefCntBase) -> bool;
}
extern "C" {
    pub fn C_SkColorFilter_makeComposed(
        self_: *const SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_filterColor4f(
        self_: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    pub fn C_SkColorFilters_Compose(
        outer: *mut SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Blend(c: SkColor, blendMode: SkBlendMode) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Matrix(colorMatrix: *const SkColorMatrix) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_MatrixRowMajor(array: *const SkScalar) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrixOfColorMatrix(
        colorMatrix: *const SkColorMatrix,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrix(rowMajor: *const f32) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_LinearToSRGBGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_SRGBToLinearGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Lerp(
        t: f32,
        dst: *mut SkColorFilter,
        src: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkContourMeasureIter_destruct(self_: *mut SkContourMeasureIter);
}
extern "C" {
    pub fn C_SkContourMeasureIter_next(self_: *mut SkContourMeasureIter) -> *mut SkContourMeasure;
}
extern "C" {
    pub fn C_SkContourMeasure_length(self_: *const SkContourMeasure) -> SkScalar;
}
extern "C" {
    pub fn C_SkContourMeasure_isClosed(self_: *const SkContourMeasure) -> bool;
}
extern "C" {
    pub fn C_SkDataTable_count(self_: *const SkDataTable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkDataTable_MakeEmpty() -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDeferredDisplayListRecorder_destruct(self_: *mut SkDeferredDisplayListRecorder);
}
extern "C" {
    pub fn C_SkDeferredDisplayListRecorder_detach(
        self_: *mut SkDeferredDisplayListRecorder,
    ) -> *mut SkDeferredDisplayList;
}
extern "C" {
    pub fn C_SkDeferredDisplayList_ref(self_: *const SkDeferredDisplayList);
}
extern "C" {
    pub fn C_SkDeferredDisplayList_unref(self_: *const SkDeferredDisplayList);
}
extern "C" {
    pub fn C_SkDeferredDisplayList_unique(self_: *const SkDeferredDisplayList) -> bool;
}
extern "C" {
    pub fn C_SkDrawLooper_asABlurShadow(
        self_: *const SkDrawLooper,
        br: *mut SkDrawLooper_BlurShadowRec,
    ) -> bool;
}
extern "C" {
    pub fn C_SkDrawLooper_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkDrawLooper;
}
extern "C" {
    pub fn C_SkDrawable_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkDrawable_getBounds(self_: *mut SkDrawable) -> SkRect;
}
extern "C" {
    pub fn C_SkImageFilter_computeFastBounds(
        self_: *const SkImageFilter,
        bounds: *const SkRect,
    ) -> SkRect;
}
extern "C" {
    pub fn C_SkImageFilter_makeWithLocalMatrix(
        self_: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_MakeMatrixFilter(
        matrix: *const SkMatrix,
        quality: SkFilterQuality,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_filterBounds(
        self_: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        mapDirection: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect;
}
extern "C" {
    pub fn C_SkImageFilter_isColorFilterNode(
        self_: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    pub fn C_SkImageFilter_countInputs(self_: *const SkImageFilter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkImageFilter_getInput(
        self_: *const SkImageFilter,
        i: ::std::os::raw::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    pub fn C_SkImageGenerator_delete(self_: *mut SkImageGenerator);
}
extern "C" {
    pub fn C_SkImageGenerator_refEncodedData(self_: *mut SkImageGenerator) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImageGenerator_MakeFromEncoded(data: *mut SkData) -> *mut SkImageGenerator;
}
extern "C" {
    pub fn C_SkImageGenerator_MakeFromPicture(
        size: *const SkISize,
        picture: *mut SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bd: SkImage_BitDepth,
        cs: *mut SkColorSpace,
    ) -> *mut SkImageGenerator;
}
extern "C" {
    pub fn C_SkString_destruct(self_: *mut SkString);
}
extern "C" {
    pub fn C_SkString_c_str_size(
        self_: *const SkString,
        size: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_SkStrings_construct(
        uninitialized: *mut SkStrings,
        string: *mut SkString,
        count: usize,
    );
}
extern "C" {
    pub fn C_SkStrings_destruct(self_: *mut SkStrings);
}
extern "C" {
    pub fn C_SkStrings_ptr_count(self_: *const SkStrings, count: *mut usize) -> *const SkString;
}
extern "C" {
    pub fn C_SkStrokeRec_destruct(self_: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_copy(self_: *const SkStrokeRec, other: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_getCap(self_: *const SkStrokeRec) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkStrokeRec_getJoin(self_: *const SkStrokeRec) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkStrokeRec_hasEqualEffect(
        self_: *const SkStrokeRec,
        other: *const SkStrokeRec,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPathEffect_MakeSum(
        first: *mut SkPathEffect,
        second: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_MakeCompose(
        outer: *mut SkPathEffect,
        inner: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_PointData_Construct(unitialized: *mut SkPathEffect_PointData);
}
extern "C" {
    pub fn C_SkPathEffect_PointData_deletePoints(self_: *mut SkPathEffect_PointData);
}
extern "C" {
    pub fn C_SkPathEffect_DashInfo_Construct(uninitialized: *mut SkPathEffect_DashInfo);
}
extern "C" {
    pub fn C_SkPathEffect_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPixmap_destruct(self_: *mut SkPixmap);
}
extern "C" {
    pub fn C_SkPixmap_scalePixels(
        self_: *const SkPixmap,
        dst: *const SkPixmap,
        filterQuality: SkFilterQuality,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPixmap_setColorSpace(self_: *mut SkPixmap, colorSpace: *mut SkColorSpace);
}
extern "C" {
    pub fn C_SkPixmap_dimensions(self_: *const SkPixmap) -> SkISize;
}
extern "C" {
    pub fn C_SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkMaskFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkSize_toRound(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toCeil(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toFloor(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkShader_isOpaque(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_isAImage(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_asAGradient(
        self_: *const SkShader,
        info: *mut SkShader_GradientInfo,
    ) -> SkShader_GradientType;
}
extern "C" {
    pub fn C_SkShader_makeWithLocalMatrix(
        self_: *const SkShader,
        matrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_makeWithColorFilter(
        self_: *const SkShader,
        colorFilter: *mut SkColorFilter,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Empty() -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color(color: SkColor) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color2(
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Blend(
        mode: SkBlendMode,
        dst: *mut SkShader,
        src: *mut SkShader,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Lerp(t: f32, dst: *mut SkShader, src: *mut SkShader) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_Deserialize(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkShader;
}
extern "C" {
    pub fn C_SkStream_delete(stream: *mut SkStream);
}
extern "C" {
    pub fn C_SkWStream_destruct(self_: *mut SkWStream);
}
extern "C" {
    pub fn C_SkWStream_write(
        self_: *mut SkWStream,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn C_SkMemoryStream_MakeDirect(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMemoryStream;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_Construct(uninitialized: *mut SkDynamicMemoryWStream);
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsData(self_: *mut SkDynamicMemoryWStream)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsStream(
        self_: *mut SkDynamicMemoryWStream,
    ) -> *mut SkStreamAsset;
}
extern "C" {
    pub fn C_Effects_Types(arg1: *mut SkTableMaskFilter);
}
extern "C" {
    pub fn C_SkGradientShader_Types(arg1: *mut SkGradientShader);
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinear2(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadial2(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConical2(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweep2(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPerlinNoiseShader_MakeFractalNoise(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::std::os::raw::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPerlinNoiseShader_MakeTurbulence(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::std::os::raw::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPerlinNoiseShader_MakeImprovedNoise(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::std::os::raw::c_int,
        z: SkScalar,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPath1DPathEffect_Make(
        path: *const SkPath,
        advance: SkScalar,
        phase: SkScalar,
        style: SkPath1DPathEffect_Style,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkLine2DPathEffect_Make(width: SkScalar, matrix: *const SkMatrix)
        -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPath2DPathEffect_Make(
        matrix: *const SkMatrix,
        path: *const SkPath,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkAlphaThresholdFilter_Make(
        region: *const SkRegion,
        innerMin: SkScalar,
        outerMax: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkArithmeticImageFilter_Make(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePMColor: bool,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkBlurDrawLooper_Make(
        color: SkColor,
        sigma: SkScalar,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkDrawLooper;
}
extern "C" {
    pub fn C_SkBlurDrawLooper_Make2(
        color: SkColor4f,
        cs: *const SkColorSpace,
        sigma: SkScalar,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkDrawLooper;
}
extern "C" {
    pub fn C_SkBlurImageFilter_Make(
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
        tileMode: SkBlurImageFilter_TileMode,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkColorFilterImageFilter_Make(
        cf: *mut SkColorFilter,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkColorMatrix_Construct(uninitialized: *mut SkColorMatrix);
}
extern "C" {
    pub fn C_SkColorMatrix_Construct2(
        uninitialized: *mut SkColorMatrix,
        m00: f32,
        m01: f32,
        m02: f32,
        m03: f32,
        m04: f32,
        m10: f32,
        m11: f32,
        m12: f32,
        m13: f32,
        m14: f32,
        m20: f32,
        m21: f32,
        m22: f32,
        m23: f32,
        m24: f32,
        m30: f32,
        m31: f32,
        m32: f32,
        m33: f32,
        m34: f32,
    );
}
extern "C" {
    pub fn C_SkColorMatrix_setRowMajor(self_: *mut SkColorMatrix, src: *const f32);
}
extern "C" {
    pub fn C_SkColorMatrix_getRowMajor(self_: *const SkColorMatrix, dst: *mut f32);
}
extern "C" {
    pub fn C_SkColorMatrixFilter_MakeLightingFilter(
        mul: SkColor,
        add: SkColor,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkComposeImageFilter_Make(
        outer: *mut SkImageFilter,
        inner: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkCornerPathEffect_Make(radius: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDashPathEffect_Make(
        intervals: *const SkScalar,
        count: ::std::os::raw::c_int,
        phase: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDiscretePathEffect_Make(
        segLength: SkScalar,
        dev: SkScalar,
        seedAssist: u32,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDisplacementMapEffect_Make(
        xChannelSelector: SkDisplacementMapEffect_ChannelSelectorType,
        yChannelSelector: SkDisplacementMapEffect_ChannelSelectorType,
        scale: SkScalar,
        displacement: *mut SkImageFilter,
        color: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkDropShadowImageFilter_Make(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        shadowMode: SkDropShadowImageFilter_ShadowMode,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkHighContrastFilter_Make(config: *const SkHighContrastConfig) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkImageSource_Make(image: *mut SkImage) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageSource_Make2(
        image: *mut SkImage,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        filterQuality: SkFilterQuality,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLayerDrawLooper_Types(arg1: *mut SkLayerDrawLooper);
}
extern "C" {
    pub fn C_SkLayerDrawLooper_Builder_destruct(self_: *mut SkLayerDrawLooper_Builder);
}
extern "C" {
    pub fn C_SkLayerDrawLooper_Builder_detach(
        self_: *mut SkLayerDrawLooper_Builder,
    ) -> *mut SkDrawLooper;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakeDistantLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakePointLitDiffuse(
        location: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakeSpotLitDiffuse(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakeDistantLitSpecular(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakePointLitSpecular(
        location: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLightingImageFilter_MakeSpotLitSpecular(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkLumaColorFilter_Make() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkMagnifierImageFilter_Make(
        srcRect: *const SkRect,
        inset: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkMatrixConvolutionImageFilter_Make(
        kernelSize: *const SkISize,
        kernel: *const SkScalar,
        gain: SkScalar,
        bias: SkScalar,
        kernelOffset: *const SkIPoint,
        tileMode: SkMatrixConvolutionImageFilter_TileMode,
        convolveAlpha: bool,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkMergeImageFilter_Make(
        filters: *const *mut SkImageFilter,
        count: ::std::os::raw::c_int,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkDilateImageFilter_Make(
        radiusX: ::std::os::raw::c_int,
        radiusY: ::std::os::raw::c_int,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkErodeImageFilter_Make(
        radiusX: ::std::os::raw::c_int,
        radiusY: ::std::os::raw::c_int,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkOffsetImageFilter_Make(
        dx: SkScalar,
        dy: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkMergePathEffect_Make(
        one: *mut SkPathEffect,
        two: *mut SkPathEffect,
        op: SkPathOp,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_MakeTranslate(dx: SkScalar, dy: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_Make(m: *const SkMatrix) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkStrokePathEffect_Make(
        width: SkScalar,
        join: SkPaint_Join,
        cap: SkPaint_Cap,
        miter: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkOverdrawColorFilter_MakeWithSkColors(colors: *const SkColor) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkPaintImageFilter_Make(
        paint: *const SkPaint,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkPictureImageFilter_Make(
        picture: *mut SkPicture,
        cropRect: *const SkRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_Make(
        sksl: *const SkString,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeShader(
        self_: *mut SkRuntimeEffect,
        inputs: *mut SkData,
        children: *mut *mut SkShader,
        childCount: usize,
        localMatrix: *const SkMatrix,
        isOpaque: bool,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeColorFilter(
        self_: *mut SkRuntimeEffect,
        inputs: *mut SkData,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_source(self_: *const SkRuntimeEffect) -> *const SkString;
}
extern "C" {
    pub fn C_SkRuntimeEffect_uniforms(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    pub fn C_SkRuntimeEffect_children(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkString;
}
extern "C" {
    pub fn C_SkRuntimeEffect_varyings(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Varying;
}
extern "C" {
    pub fn C_SkShaderMaskFilter_Make(shader: *mut SkShader) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkStrokeAndFillePathEffect_Make() -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkTableColorFilter_Make(table: *const u8) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkTableColorFilter_MakeARGB(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkTileImageFilter_Make(
        src: *const SkRect,
        dst: *const SkRect,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkTrimPathEffect_Make(
        startT: SkScalar,
        stopT: SkScalar,
        mode: SkTrimPathEffect_Mode,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkXfermodeImageFilter_Make(
        mode: SkBlendMode,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilter_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_AlphaThreshold(
        region: *const SkRegion,
        innerMin: SkScalar,
        outerMax: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePMColor: bool,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Blur(
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        tileMode: SkTileMode,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_ColorFilter(
        cf: *mut SkColorFilter,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Compose(
        outer: *mut SkImageFilter,
        inner: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DisplacementMap(
        xChannelSelector: SkColorChannel,
        yChannelSelector: SkColorChannel,
        scale: SkScalar,
        displacement: *mut SkImageFilter,
        color: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadow(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadowOnly(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Image(
        image: *mut SkImage,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        filterQuality: SkFilterQuality,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Magnifier(
        srcRect: *const SkRect,
        inset: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixConvolution(
        kernelSize: *const SkISize,
        kernel: *const SkScalar,
        gain: SkScalar,
        bias: SkScalar,
        kernelOffset: *const SkIPoint,
        tileMode: SkTileMode,
        convolveAlpha: bool,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixTransform(
        matrix: *const SkMatrix,
        filterQuality: SkFilterQuality,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Merge(
        filters: *const *mut SkImageFilter,
        count: ::std::os::raw::c_int,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Offset(
        dx: SkScalar,
        dy: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Paint(
        paint: *const SkPaint,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Picture(
        pic: *mut SkPicture,
        targetRect: *const SkRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Tile(
        src: *const SkRect,
        dst: *const SkRect,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Xfermode(
        blendMode: SkBlendMode,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Dilate(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Erode(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DistantLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitDiffuse(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_ImageFilters_DistantLitSpecular(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitSpecular(
        location: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitSpecular(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkIRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkPDF_AttributeList_destruct(self_: *mut SkPDF_AttributeList);
}
extern "C" {
    pub fn C_SkPDF_AttributeList_appendFloatArray(
        self_: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const f32,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_AttributeList_appendStringArray(
        self_: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const SkString,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_New() -> *mut SkPDF_StructureElementNode;
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_delete(self_: *mut SkPDF_StructureElementNode);
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_setChildVector(
        self_: *mut SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructElementNode_appendChild(
        self_: *mut SkPDF_StructureElementNode,
        node: *mut SkPDF_StructureElementNode,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_getChildVector(
        self_: *const SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
    ) -> usize;
}
extern "C" {
    pub fn C_SkPDF_Metadata_Construct(uninitialized: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_Metadata_destruct(self_: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_MakeDocument(
        stream: *mut SkWStream,
        metadata: *const SkPDF_Metadata,
    ) -> *mut SkDocument;
}
extern "C" {
    pub fn C_SkOpBuilder_Construct(uninitialized: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_SkOpBuilder_destruct(self_: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_Utils_Types(
        arg1: *mut SkShadowFlags,
        arg2: *mut SkShadowUtils,
        arg3: *mut SkTextUtils,
        arg4: *mut SkParsePath,
        arg5: *mut SkCustomTypefaceBuilder,
    );
}
extern "C" {
    pub fn C_Sk3DView_new() -> *mut Sk3DView;
}
extern "C" {
    pub fn C_Sk3DView_delete(self_: *mut Sk3DView);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_destruct(self_: *mut SkCustomTypefaceBuilder);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_detach(self_: *mut SkCustomTypefaceBuilder)
        -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkInterpolator_destruct(self_: *mut SkInterpolator);
}
extern "C" {
    pub fn C_SkInterpolator_setRepeatCount(self_: *mut SkInterpolator, repeatCount: SkScalar);
}
extern "C" {
    pub fn C_SkInterpolator_setReset(self_: *mut SkInterpolator, reset: bool);
}
extern "C" {
    pub fn C_SkInterpolator_setMirror(self_: *mut SkInterpolator, mirror: bool);
}
extern "C" {
    pub fn C_SkMakeNullCanvas() -> *mut SkCanvas;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSVGCanvas {
    pub _address: u8,
}
pub const SkSVGCanvas_kConvertTextToPaths_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kConvertTextToPaths_Flag;
pub const SkSVGCanvas_kNoPrettyXML_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kNoPrettyXML_Flag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSVGCanvas__bindgen_ty_1 {
    kConvertTextToPaths_Flag = 1,
    kNoPrettyXML_Flag = 2,
}
#[test]
fn bindgen_test_layout_SkSVGCanvas() {
    assert_eq!(
        ::core::mem::size_of::<SkSVGCanvas>(),
        1usize,
        concat!("Size of: ", stringify!(SkSVGCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSVGCanvas>(),
        1usize,
        concat!("Alignment of ", stringify!(SkSVGCanvas))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11SkSVGCanvas4MakeERK6SkRectP9SkWStreamj"]
    pub fn SkSVGCanvas_Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64;
}
impl SkSVGCanvas {
    #[inline]
    pub unsafe fn Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64 {
        SkSVGCanvas_Make(bounds, arg1, flags)
    }
}
extern "C" {
    pub fn C_SVG_Types(arg1: *mut SkSVGCanvas);
}
extern "C" {
    pub fn C_SkSVGCanvas_Make(
        bounds: *const SkRect,
        writer: *mut SkWStream,
        flags: u32,
    ) -> *mut SkCanvas;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_2()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMarkerStack_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMarkerStack>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMarkerStack>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMarkerStack>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMarkerStack>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkGlyphRunBuilder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_ptr_SkIDChangeListener_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<*mut SkIDChangeListener>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<*mut SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<*mut SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<*mut SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkContourMeasureIter_Impl_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMipmap_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_36() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_37() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_38() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkPoint_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkPoint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkPoint>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkPoint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkPoint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_uint8_t_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<u8>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkScalar_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkScalar>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkScalar>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_39() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRecorder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkRecord_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMiniRecorder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_40() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDFArray_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_SkPDF_StructureElementNode_std_default_delete_open2_SkPDF_StructureElementNode_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation_1(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawLooper_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawLooper>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawLooper>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawLooper>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawLooper>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkPathOp_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkPathOp>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkPathOp>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkPathOp>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkPathOp>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_41() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_42() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_43() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkPath_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
